lazy_ostream.hpp:33:29:boost::unit_test::lazy_ostream::~lazy_ostream()	16	static
lazy_ostream.hpp:33:29:virtual boost::unit_test::lazy_ostream::~lazy_ostream()	32	static
lazy_ostream.hpp:35:29:static boost::unit_test::lazy_ostream& boost::unit_test::lazy_ostream::instance()	16	static
lazy_ostream.hpp:43:29:virtual std::ostream& boost::unit_test::lazy_ostream::operator()(std::ostream&) const	16	static
lazy_ostream.hpp:45:29:boost::unit_test::lazy_ostream::lazy_ostream(bool)	16	static
char_traits.h:329:7:static constexpr std::size_t std::char_traits<char>::length(const char_type*)	48	static
typeinfo:120:10:bool std::type_info::operator==(const std::type_info&) const	32	static
new:173:33:void* operator new(std::size_t, void*)	16	static
limits:1204:7:static constexpr long int std::numeric_limits<long int>::min()	16	static
limits:1207:7:static constexpr long int std::numeric_limits<long int>::max()	16	static
limits:1740:7:static constexpr double std::numeric_limits<double>::min()	16	static
limits:1743:7:static constexpr double std::numeric_limits<double>::max()	16	static
limits:1781:7:static constexpr double std::numeric_limits<double>::infinity()	16	static
basic_string.h:6546:3:std::string std::__cxx11::to_string(int)	48	static
basic_string.h:6557:3:std::string std::__cxx11::to_string(long int)	48	static
ios_base.h:705:5:std::streamsize std::ios_base::precision(std::streamsize)	16	static
atomic:759:17:constexpr std::atomic<int>::atomic(std::atomic<int>::__integral_type)	32	static
sp_counted_base_std_atomic.hpp:30:13:void boost::detail::atomic_increment(std::atomic_int_least32_t*)	16	static
sp_counted_base_std_atomic.hpp:35:27:int_least32_t boost::detail::atomic_decrement(std::atomic_int_least32_t*)	16	static
sp_counted_base_std_atomic.hpp:74:5:boost::detail::sp_counted_base::sp_counted_base()	32	static
sp_counted_base_std_atomic.hpp:78:13:boost::detail::sp_counted_base::~sp_counted_base()	16	static
sp_counted_base_std_atomic.hpp:78:13:virtual boost::detail::sp_counted_base::~sp_counted_base()	32	static
sp_counted_base_std_atomic.hpp:89:18:virtual void boost::detail::sp_counted_base::destroy()	32	static
sp_counted_base_std_atomic.hpp:98:10:void boost::detail::sp_counted_base::add_ref_copy()	32	static
sp_counted_base_std_atomic.hpp:108:10:void boost::detail::sp_counted_base::release()	32	static
sp_counted_base_std_atomic.hpp:122:10:void boost::detail::sp_counted_base::weak_release()	32	static
type_traits:62:17:constexpr std::integral_constant<_Tp, __v>::operator std::integral_constant<_Tp, __v>::value_type() const [with _Tp = bool; _Tp __v = true]	16	static
shared_count.hpp:122:21:constexpr boost::detail::shared_count::shared_count()	16	static
shared_count.hpp:425:5:boost::detail::shared_count::~shared_count()	32	static
shared_count.hpp:433:5:boost::detail::shared_count::shared_count(const boost::detail::shared_count&)	32	static
shared_count.hpp:470:10:void boost::detail::shared_count::swap(boost::detail::shared_count&)	16	static
shared_ptr.hpp:242:13:)	16	static
assertion_result.hpp:45:25:void boost::test_tools::assertion_result::dummy::nonnull()	16	static
shared_ptr.hpp:341:25:boost::shared_ptr<boost::basic_wrap_stringstream<char> >::~shared_ptr()	32	static
assertion_result.hpp:52:5:boost::test_tools::assertion_result::assertion_result(bool)	32	static
assertion_result.hpp:60:25:bool boost::test_tools::assertion_result::operator!() const	32	static
assertion_result.hpp:62:5:boost::test_tools::assertion_result::operator boost::test_tools::assertion_result::safe_bool() const	48	static
assertion_result.hpp:65:5:boost::test_tools::assertion_result::readonly_property65::readonly_property65(write_param_t)	32	static
wrap_stringstream.hpp:40:7:boost::basic_wrap_stringstream<char>::basic_wrap_stringstream()	32	static
assertion_result.hpp:69:25:boost::wrap_stringstream& boost::test_tools::assertion_result::message()	48	static
assertion_result.hpp:76:25:boost::test_tools::assertion_result::const_string boost::test_tools::assertion_result::message() const	32	static
fwd.hpp:45:13:bool boost::test_tools::tt_detail::dummy_cond()	16	static
assertion_result.hpp:39:23:boost::test_tools::assertion_result::~assertion_result()	32	static
stl_type_index.hpp:93:12:boost::typeindex::stl_type_index::stl_type_index(const type_info_t&)	16	static
stl_type_index.hpp:117:43:const type_info_t& boost::typeindex::stl_type_index::type_info() const	16	static
stl_type_index.hpp:206:13:bool boost::typeindex::stl_type_index::equal(const boost::typeindex::stl_type_index&) const	32	static
function_base.hpp:603:3:boost::function_base::function_base()	16	static
function_base.hpp:689:8:bool boost::function_base::has_trivial_copy_and_destroy() const	16	static
fixture.hpp:37:13:boost::unit_test::test_unit_fixture::~test_unit_fixture()	16	static
fixture.hpp:37:13:virtual boost::unit_test::test_unit_fixture::~test_unit_fixture()	32	static
fixture.hpp:35:23:constexpr boost::unit_test::test_unit_fixture::test_unit_fixture()	16	static
function_template.hpp:1048:7:boost::function<void()>::~function()	32	static
decorator.hpp:94:13:boost::unit_test::decorator::base::~base()	16	static
decorator.hpp:94:13:virtual boost::unit_test::decorator::base::~base()	32	static
decorator.hpp:82:23:constexpr boost::unit_test::decorator::base::base()	16	static
shared_ptr.hpp:341:25:boost::shared_ptr<boost::unit_test::test_unit_fixture>::~shared_ptr()	32	static
decorator.hpp:233:29:boost::unit_test::decorator::fixture_t::fixture_t(boost::unit_test::test_unit_fixture_ptr)	32	static
test_unit.hpp:265:1:boost::unit_test::test_case* boost::unit_test::make_test_case(const boost::function<void()>&, boost::unit_test::const_string, boost::unit_test::const_string, std::size_t)	176	static
unit_test_suite.hpp:386:6:bool init_unit_test()	16	static
unit_test.hpp:61:1:int main(int, char**)	32	static
complex:1232:26:constexpr std::complex<double>::complex(double, double)	16	static
complex:1252:7:constexpr double std::complex<double>::real() const	16	static
complex:1256:7:constexpr double std::complex<double>::imag() const	16	static
complex:1287:7:std::complex<double>& std::complex<double>::operator+=(double)	16	static
complex:1301:7:std::complex<double>& std::complex<double>::operator*=(double)	16	static
complex:1361:36:constexpr std::complex<double>::_ComplexT std::complex<double>::__rep() const	16	static
core.hpp:265:1:boost::multi::blas::{anonymous}::v boost::multi::blas::rotg(const s&, const s&, boost::multi::blas::{anonymous}::s&, boost::multi::blas::{anonymous}::s&)	48	static
core.hpp:265:16:boost::multi::blas::{anonymous}::v boost::multi::blas::rotg(const d&, const d&, boost::multi::blas::{anonymous}::d&, boost::multi::blas::{anonymous}::d&)	48	static
core.hpp:266:1:boost::multi::blas::{anonymous}::v boost::multi::blas::rotmg(boost::multi::blas::{anonymous}::s&, boost::multi::blas::{anonymous}::s&, boost::multi::blas::{anonymous}::s&, const s&, boost::multi::blas::{anonymous}::s (&)[5])	64	static
core.hpp:266:16:boost::multi::blas::{anonymous}::v boost::multi::blas::rotmg(boost::multi::blas::{anonymous}::d&, boost::multi::blas::{anonymous}::d&, boost::multi::blas::{anonymous}::d&, const d&, boost::multi::blas::{anonymous}::d (&)[5])	64	static
core.hpp:273:1:boost::multi::blas::core::scal(int64_t, const s*, boost::multi::blas::{anonymous}::s*, int64_t)::<lambda(auto:31)> [with auto:31 = long int]	32	static
core.hpp:273:1:boost::multi::blas::core::scal(int64_t, const s*, boost::multi::blas::{anonymous}::s*, int64_t)::<lambda(auto:32)> [with auto:32 = long int]	32	static
core.hpp:273:1:boost::multi::blas::{anonymous}::s* boost::multi::blas::core::scal(int64_t, const s*, boost::multi::blas::{anonymous}::s*, int64_t)	80	static
core.hpp:273:16:boost::multi::blas::core::scal(int64_t, const d*, boost::multi::blas::{anonymous}::d*, int64_t)::<lambda(auto:33)> [with auto:33 = long int]	32	static
core.hpp:273:16:boost::multi::blas::core::scal(int64_t, const d*, boost::multi::blas::{anonymous}::d*, int64_t)::<lambda(auto:34)> [with auto:34 = long int]	32	static
core.hpp:273:16:boost::multi::blas::{anonymous}::d* boost::multi::blas::core::scal(int64_t, const d*, boost::multi::blas::{anonymous}::d*, int64_t)	80	static
core.hpp:273:31:boost::multi::blas::core::scal(int64_t, const c*, boost::multi::blas::{anonymous}::c*, int64_t)::<lambda(auto:35)> [with auto:35 = long int]	32	static
core.hpp:273:31:boost::multi::blas::core::scal(int64_t, const c*, boost::multi::blas::{anonymous}::c*, int64_t)::<lambda(auto:36)> [with auto:36 = long int]	32	static
core.hpp:273:31:boost::multi::blas::{anonymous}::c* boost::multi::blas::core::scal(int64_t, const c*, boost::multi::blas::{anonymous}::c*, int64_t)	80	static
core.hpp:273:46:boost::multi::blas::core::scal(int64_t, const z*, boost::multi::blas::{anonymous}::z*, int64_t)::<lambda(auto:37)> [with auto:37 = long int]	32	static
core.hpp:273:46:boost::multi::blas::core::scal(int64_t, const z*, boost::multi::blas::{anonymous}::z*, int64_t)::<lambda(auto:38)> [with auto:38 = long int]	32	static
core.hpp:273:46:boost::multi::blas::{anonymous}::z* boost::multi::blas::core::scal(int64_t, const z*, boost::multi::blas::{anonymous}::z*, int64_t)	80	static
core.hpp:273:61:boost::multi::blas::core::scal(int64_t, const d*, boost::multi::blas::{anonymous}::z*, int64_t)::<lambda(auto:39)> [with auto:39 = long int]	32	static
core.hpp:273:61:boost::multi::blas::core::scal(int64_t, const d*, boost::multi::blas::{anonymous}::z*, int64_t)::<lambda(auto:40)> [with auto:40 = long int]	32	static
core.hpp:273:61:boost::multi::blas::{anonymous}::z* boost::multi::blas::core::scal(int64_t, const d*, boost::multi::blas::{anonymous}::z*, int64_t)	80	static
core.hpp:273:77:boost::multi::blas::core::scal(int64_t, const s*, boost::multi::blas::{anonymous}::c*, int64_t)::<lambda(auto:41)> [with auto:41 = long int]	32	static
core.hpp:273:77:boost::multi::blas::core::scal(int64_t, const s*, boost::multi::blas::{anonymous}::c*, int64_t)::<lambda(auto:42)> [with auto:42 = long int]	32	static
core.hpp:273:77:boost::multi::blas::{anonymous}::c* boost::multi::blas::core::scal(int64_t, const s*, boost::multi::blas::{anonymous}::c*, int64_t)	80	static
type_traits:62:17:constexpr std::integral_constant<_Tp, __v>::operator std::integral_constant<_Tp, __v>::value_type() const [with _Tp = bool; _Tp __v = false]	16	static
index_range.hpp:96:12:constexpr boost::multi::range<IndexType, IndexTypeLast>::range(IndexType, IndexTypeLast) [with IndexType = long int; IndexTypeLast = long int]	16	static
layout.hpp:117:25:constexpr const base_& boost::multi::extensions_t<1>::base() const	16	static
layout.hpp:118:12:constexpr boost::multi::extensions_t<1>::extensions_t(const std::tuple<boost::multi::extension_t<long int, long int> >&)	16	static
layout.hpp:298:56:constexpr boost::multi::layout_t<1>::extensions_type boost::multi::operator*(const index_extension&, const extensions_type&)	80	static
layout.hpp:466:56:constexpr boost::multi::layout_t<2>::extensions_type boost::multi::operator*(const index_extension&, const extensions_type&)	48	static
filling.hpp:25:9:boost::multi::blas::filling boost::multi::blas::flip(boost::multi::blas::filling)	16	static
filling.hpp:32:9:boost::multi::blas::filling boost::multi::blas::operator-(boost::multi::blas::filling)	24	static
filling.hpp:33:9:boost::multi::blas::filling boost::multi::blas::operator+(boost::multi::blas::filling)	16	static
side.hpp:26:6:boost::multi::blas::side boost::multi::blas::swap(boost::multi::blas::side)	16	static
wrap_stringstream.hpp:40:7:boost::basic_wrap_stringstream<char>::~basic_wrap_stringstream()	32	static
trsm.cpp:41:1:void multi_blas_trsm_double_0x0_invoker()	496	static
adl.hpp:105:39:) const [with As = {boost::multi::array_iterator<double, 1, const double*>, boost::multi::array_iterator<double, 1, const double*>, boost::multi::array_iterator<double, 1, double*>}]	96	dynamic,bounded
array.hpp:25:34:boost::multi::array_allocator<std::allocator<double> >::~array_allocator()	32	static
array.hpp:277:2:boost::multi::static_array<T, D, Alloc>::static_array() [with T = double; long int D = 2; Alloc = std::allocator<double>]	48	static
array.hpp:745:2:boost::multi::array<T, D, A>::array() [with T = double; long int D = 2; Alloc = std::allocator<double>]	32	static
array.hpp:929:2:boost::multi::array<T, D, A>::~array() [with T = double; long int D = 2; Alloc = std::allocator<double>]	32	static
numeric.hpp:247:12:constexpr boost::multi::blas::is_conjugated<A>::operator bool() const [with A = boost::multi::array<double, 2>]	48	static
layout.hpp:378:29:constexpr boost::multi::layout_t<2>::size_type boost::multi::size(const boost::multi::layout_t<2>&)	32	static
array_ref.hpp:570:31:constexpr boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> > boost::multi::operator~(const boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >&)	48	static
array_ref.hpp:566:24:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout> boost::multi::basic_array<T, D, ElementPtr, Layout>::transposed() const & [with T = double; long int D = 2; ElementPtr = double*; Layout = boost::multi::layout_t<2>]	96	static
array_ref.hpp:348:12:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::basic_array(const layout_type&, const ElementPtr&) [with T = double; long int D = 2; ElementPtr = double*; Layout = boost::multi::layout_t<2>]	48	static
array_ref.hpp:348:12:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::basic_array(const layout_type&, const ElementPtr&) [with T = double; long int D = 2; ElementPtr = double*; Layout = boost::multi::layout_t<2>]	48	static
layout.hpp:428:22:constexpr boost::multi::layout_t<D, SSize>& boost::multi::layout_t<D, SSize>::transpose() [with long int D = 2; SSize = long int]	32	static
range_access.h:242:5:size()) std::size(const _Container&) [with _Container = boost::multi::array<double, 2>]	32	static
layout.hpp:373:22:constexpr boost::multi::layout_t<D, SSize>::size_type boost::multi::layout_t<D, SSize>::size() const [with long int D = 2; SSize = long int]	32	static
layout.hpp:383:25:constexpr boost::multi::layout_t<2>::index boost::multi::stride(const boost::multi::layout_t<2>&)	32	static
layout.hpp:381:18:constexpr boost::multi::layout_t<D, SSize>::index boost::multi::layout_t<D, SSize>::stride() const [with long int D = 2; SSize = long int]	16	static
numeric.hpp:247:12:constexpr boost::multi::blas::is_conjugated<A>::operator bool() const [with A = boost::multi::array<double, 2>&]	48	static
trsm.hpp:26:16:decltype(auto) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, boost::multi::blas::diagonal, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::array<double, 2>; B2D = boost::multi::array<double, 2>&]	1920	dynamic,bounded
trsm.hpp:74:16:decltype(auto) boost::multi::blas::trsm(boost::multi::blas::side, boost::multi::blas::filling, boost::multi::blas::diagonal, typename A2D::element_type, const A2D&, B2D&&) [with A2D = boost::multi::array<double, 2>; B2D = boost::multi::array<double, 2>&]	112	static
trsm.cpp:41:1:void multi_blas_trsm_double_0x0::test_method()	176	static
trsm.cpp:51:1:void multi_blas_trsm_double_1x1_invoker()	496	static
initializer_list:75:7:constexpr const _E* std::initializer_list<_E>::begin() const [with _E = boost::multi::array<double, 1, std::allocator<double> >]	16	static
initializer_list:75:7:constexpr const _E* std::initializer_list<_E>::begin() const [with _E = double]	16	static
array.hpp:743:17:constexpr boost::multi::array<double, 1, std::allocator<double> >::array(std::initializer_list<double>) [inherited from boost::multi::static_array<double, 1, std::allocator<double> >]	48	static
array.hpp:929:2:boost::multi::array<T, D, A>::~array() [with T = double; long int D = 1; Alloc = std::allocator<double>]	32	static
array.hpp:247:12:constexpr boost::multi::static_array<T, D, Alloc>::static_array(std::initializer_list<typename std::conditional<(boost::multi::static_array<T, D, Alloc>::dimensionality > 1), boost::multi::array<typename boost::multi::static_array<T, D, Alloc>::element, (boost::multi::static_array<T, D, Alloc>::dimensionality - 1), typename boost::multi::static_array<T, D, Alloc>::allocator_type>, typename std::conditional<(boost::multi::static_array<T, D, Alloc>::dimensionality == 1), typename boost::multi::static_array<T, D, Alloc>::element, typename boost::multi::static_array<T, D, Alloc>::element>::type>::type>) [with T = double; long int D = 1; Alloc = std::allocator<double>]	80	static
array.hpp:743:17:constexpr boost::multi::array<double, 2>::array(std::initializer_list<boost::multi::array<double, 1, std::allocator<double> > >) [inherited from boost::multi::static_array<double, 2, std::allocator<double> >]	48	static
array.hpp:746:2:boost::multi::array<T, D, A>::array(const boost::multi::array<T, D, A>&) [with T = double; long int D = 2; Alloc = std::allocator<double>]	32	static
gemm.hpp:325:6:auto boost::multi::blas::gemm(Scalar, const A2D&, const B2D&) [with Scalar = double; A2D = boost::multi::array<double, 2>; B2D = boost::multi::array<double, 2>]	80	static
array_ref.hpp:1160:47:constexpr typename boost::multi::basic_array<T, 1, ElementPtr, Layout>::reference boost::multi::basic_array<T, 1, ElementPtr, Layout>::operator[](boost::multi::index) && [with T = double; ElementPtr = const double*; Layout = boost::multi::layout_t<1>]	32	static
layout.hpp:327:17:constexpr auto boost::multi::layout_t<D, SSize>::operator()(boost::multi::layout_t<D, SSize>::index) const [with long int D = 2; SSize = long int]	16	static
array_ref.hpp:1077:15:constexpr boost::multi::basic_array<double, 1, double*, boost::multi::layout_t<1> >::basic_array(const layout_t&, double* const&) [inherited from boost::multi::array_types<double, 1, double*, boost::multi::layout_t<1> >]	48	static
array_ref.hpp:404:20:constexpr auto boost::multi::basic_array<T, D, ElementPtr, Layout>::at_(boost::multi::index) const [with T = double; long int D = 2; ElementPtr = double*; Layout = boost::multi::layout_t<2>]	144	static
array_ref.hpp:408:31:constexpr typename boost::multi::basic_array<T, D, ElementPtr, Layout>::types::const_reference boost::multi::basic_array<T, D, ElementPtr, Layout>::operator[](boost::multi::index) const & [with T = double; long int D = 2; ElementPtr = double*; Layout = boost::multi::layout_t<2>]	96	static
array_ref.hpp:1122:12:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::basic_array(BasicArray&&) [with BasicArray = boost::multi::basic_array<double, 1, double*, boost::multi::layout_t<1> >; <template-parameter-2-2> = void; <template-parameter-2-3> = boost::multi::array_types<double, 1, const double*, boost::multi::layout_t<1> >; T = double; ElementPtr = const double*; Layout = boost::multi::layout_t<1>]	48	static
array_ref.hpp:345:24:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::layout_type boost::multi::basic_array<T, D, ElementPtr, Layout>::layout() const [with T = double; long int D = 2; ElementPtr = double*; Layout = boost::multi::layout_t<2>]	48	static
array_ref.hpp:96:28:constexpr const layout_t& boost::multi::array_types<T, D, ElementPtr, Layout>::layout() const [with T = double; long int D = 2; ElementPtr = double*; Layout = boost::multi::layout_t<2>]	16	static
trsm.cpp:51:1:void multi_blas_trsm_double_1x1::test_method()	864	dynamic,bounded
trsm.cpp:90:1:void multi_blas_trsm_real_square_invoker()	496	static
trsm.cpp:26:6:auto triangular(boost::multi::blas::filling, const Matrix&) [with Matrix = boost::multi::array<double, 2>]	224	static
trsm.hpp:85:16:decltype(auto) boost::multi::blas::trsm(boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with A2D = boost::multi::array<double, 2>; B2D = boost::multi::array<double, 2>&]	96	static
layout.hpp:293:24:constexpr boost::multi::layout_t<1, SSize>& boost::multi::layout_t<1, SSize>::rotate(boost::multi::dimensionality_type) [with SSize = long int]	16	static
layout.hpp:435:22:constexpr boost::multi::layout_t<D, SSize>& boost::multi::layout_t<D, SSize>::rotate() [with long int D = 2; SSize = long int]	32	static
layout.hpp:451:22:constexpr boost::multi::layout_t<D, SSize>& boost::multi::layout_t<D, SSize>::rotate(boost::multi::layout_t<D, SSize>::dimensionality_type) [with long int D = 2; SSize = long int]	32	static
array.hpp:397:17:constexpr auto boost::multi::static_array<T, D, Alloc>::rotated(boost::multi::dimensionality_type) const & [with T = double; long int D = 2; Alloc = std::allocator<double>]	144	static
array.hpp:415:34:constexpr decltype(auto) boost::multi::rotated(const boost::multi::static_array<double, 2, std::allocator<double> >&)	48	static
operations.hpp:15:34:decltype(auto) boost::multi::blas::transposed(const M&) [with M = boost::multi::array<double, 2>]	48	static
operations.hpp:79:34:decltype(auto) boost::multi::blas::T(A&&) [with A = const boost::multi::array<double, 2>&]	48	static
numeric.hpp:247:12:constexpr boost::multi::blas::is_conjugated<A>::operator bool() const [with A = boost::multi::basic_array<double, 2, const double*, boost::multi::layout_t<2> >]	48	static
array_ref.hpp:570:31:constexpr boost::multi::basic_array<double, 2, const double*, boost::multi::layout_t<2> > boost::multi::operator~(const boost::multi::basic_array<double, 2, const double*, boost::multi::layout_t<2> >&)	48	static
array_ref.hpp:566:24:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout> boost::multi::basic_array<T, D, ElementPtr, Layout>::transposed() const & [with T = double; long int D = 2; ElementPtr = const double*; Layout = boost::multi::layout_t<2>]	96	static
array_ref.hpp:348:12:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::basic_array(const layout_type&, const ElementPtr&) [with T = double; long int D = 2; ElementPtr = const double*; Layout = boost::multi::layout_t<2>]	48	static
trsm.hpp:26:16:decltype(auto) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, boost::multi::blas::diagonal, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::basic_array<double, 2, const double*, boost::multi::layout_t<2> >; B2D = boost::multi::array<double, 2>&]	1920	dynamic,bounded
trsm.hpp:85:16:decltype(auto) boost::multi::blas::trsm(boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with A2D = boost::multi::basic_array<double, 2, const double*, boost::multi::layout_t<2> >; B2D = boost::multi::array<double, 2>&]	96	static
gemm.hpp:325:6:auto boost::multi::blas::gemm(Scalar, const A2D&, const B2D&) [with Scalar = double; A2D = boost::multi::basic_array<double, 2, const double*, boost::multi::layout_t<2> >; B2D = boost::multi::array<double, 2>]	80	static
array.hpp:402:17:constexpr auto boost::multi::static_array<T, D, Alloc>::rotated(boost::multi::dimensionality_type) & [with T = double; long int D = 2; Alloc = std::allocator<double>]	128	static
array.hpp:414:34:constexpr decltype(auto) boost::multi::rotated(boost::multi::static_array<double, 2, std::allocator<double> >&)	48	static
operations.hpp:38:16:decltype(auto) boost::multi::blas::transposed(A&&) [with A = boost::multi::array<double, 2>&]	48	static
operations.hpp:79:34:decltype(auto) boost::multi::blas::T(A&&) [with A = boost::multi::array<double, 2>&]	48	static
numeric.hpp:247:12:constexpr boost::multi::blas::is_conjugated<A>::operator bool() const [with A = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >]	48	static
trsm.hpp:26:16:decltype(auto) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, boost::multi::blas::diagonal, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::basic_array<double, 2, const double*, boost::multi::layout_t<2> >; B2D = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >]	1920	dynamic,bounded
trsm.hpp:85:16:decltype(auto) boost::multi::blas::trsm(boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with A2D = boost::multi::basic_array<double, 2, const double*, boost::multi::layout_t<2> >; B2D = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >]	96	static
gemm.hpp:325:6:auto boost::multi::blas::gemm(Scalar, const A2D&, const B2D&) [with Scalar = double; A2D = boost::multi::basic_array<double, 2, const double*, boost::multi::layout_t<2> >; B2D = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >]	80	static
trsm.hpp:26:16:decltype(auto) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, boost::multi::blas::diagonal, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::array<double, 2>; B2D = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >]	1920	dynamic,bounded
trsm.hpp:85:16:decltype(auto) boost::multi::blas::trsm(boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with A2D = boost::multi::array<double, 2>; B2D = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >]	96	static
trsm.cpp:90:1:void multi_blas_trsm_real_square::test_method()	1488	dynamic,bounded
trsm.cpp:149:1:void multi_blas_trsm_complex_invoker()	496	static
adl.hpp:105:39:) const [with As = {boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>}]	80	static
initializer_list:75:7:constexpr const _E* std::initializer_list<_E>::begin() const [with _E = boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >]	16	static
initializer_list:75:7:constexpr const _E* std::initializer_list<_E>::begin() const [with _E = std::complex<double>]	16	static
array.hpp:743:17:constexpr boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >::array(std::initializer_list<std::complex<double> >) [inherited from boost::multi::static_array<std::complex<double>, 1, std::allocator<std::complex<double> > >]	48	static
array.hpp:929:2:boost::multi::array<T, D, A>::~array() [with T = std::complex<double>; long int D = 1; Alloc = std::allocator<std::complex<double> >]	32	static
array.hpp:743:17:constexpr boost::multi::array<std::complex<double>, 2>::array(std::initializer_list<boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > > >) [inherited from boost::multi::static_array<std::complex<double>, 2, std::allocator<std::complex<double> > >]	48	static
array.hpp:929:2:boost::multi::array<T, D, A>::~array() [with T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	32	static
complex:571:5:constexpr _Tp std::imag(const std::complex<_Tp>&) [with _Tp = double]	32	static
numeric.hpp:260:16:decltype(auto) boost::multi::blas::conj(A&&) [with A = const boost::multi::array<std::complex<double>, 2>&; D = boost::multi::array<std::complex<double>, 2>; Elem = std::complex<double>; Ptr = std::complex<double>*; typename std::enable_if<((! boost::multi::blas::is_conjugated<A>{}) && boost::multi::blas::is_complex_array<A>{}), int>::type <anonymous> = 0]	48	static
operations.hpp:38:16:decltype(auto) boost::multi::blas::transposed(A&&) [with A = boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >]	48	static
operations.hpp:18:16:decltype(auto) boost::multi::blas::conjugated_transposed(A&&) [with A = const boost::multi::array<std::complex<double>, 2>&; D = boost::multi::array<std::complex<double>, 2>; E = std::complex<double>]	112	static
operations.hpp:35:16:decltype(auto) boost::multi::blas::hermitized(A&&) [with A = const boost::multi::array<std::complex<double>, 2>&]	48	static
operations.hpp:47:17:decltype(auto) boost::multi::blas::operators::<unnamed struct>::operator()(A&&) const [with A = const boost::multi::array<std::complex<double>, 2>&; typename std::enable_if<(typename std::decay<_Tp>::type::dimensionality == 2), int>::type <anonymous> = 0]	64	static
numeric.hpp:247:12:constexpr boost::multi::blas::is_conjugated<A>::operator bool() const [with A = boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >]	48	static
range_access.h:242:5:size()) std::size(const _Container&) [with _Container = boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >]	32	static
array_ref.hpp:570:31:constexpr boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> > boost::multi::operator~(const boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >&)	48	static
array_ref.hpp:566:24:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout> boost::multi::basic_array<T, D, ElementPtr, Layout>::transposed() const & [with T = std::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<2>]	96	static
array_ref.hpp:348:12:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::basic_array(const layout_type&, const ElementPtr&) [with T = std::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<2>]	48	static
range_access.h:242:5:size()) std::size(const _Container&) [with _Container = boost::multi::array<std::complex<double>, 2>]	32	static
range_access.h:242:5:size()) std::size(const _Container&) [with _Container = boost::multi::basic_array<std::complex<double>, 2, std::complex<double>*, boost::multi::layout_t<2> >]	32	static
array_ref.hpp:570:31:constexpr boost::multi::basic_array<std::complex<double>, 2, std::complex<double>*, boost::multi::layout_t<2> > boost::multi::operator~(const boost::multi::basic_array<std::complex<double>, 2, std::complex<double>*, boost::multi::layout_t<2> >&)	48	static
array_ref.hpp:566:24:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout> boost::multi::basic_array<T, D, ElementPtr, Layout>::transposed() const & [with T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<2>]	96	static
array_ref.hpp:348:12:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::basic_array(const layout_type&, const ElementPtr&) [with T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<2>]	48	static
array_ref.hpp:348:12:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::basic_array(const layout_type&, const ElementPtr&) [with T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<2>]	48	static
numeric.hpp:247:12:constexpr boost::multi::blas::is_conjugated<A>::operator bool() const [with A = boost::multi::array<std::complex<double>, 2>&]	48	static
trsm.hpp:26:16:decltype(auto) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, boost::multi::blas::diagonal, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >; B2D = boost::multi::array<std::complex<double>, 2>&]	1936	dynamic,bounded
trsm.hpp:85:16:decltype(auto) boost::multi::blas::trsm(boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with A2D = boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >; B2D = boost::multi::array<std::complex<double>, 2>&]	128	static
trsm.cpp:149:1:void multi_blas_trsm_complex::test_method()	960	dynamic,bounded
trsm.cpp:167:1:void multi_blas_trsm_complex_rectangular_invoker()	496	static
trsm.cpp:167:1:void multi_blas_trsm_complex_rectangular::test_method()	864	dynamic,bounded
trsm.cpp:185:1:void multi_blas_trsm_complex_column_invoker()	496	static
trsm.cpp:185:1:void multi_blas_trsm_complex_column::test_method()	864	dynamic,bounded
trsm.cpp:203:1:void multi_blas_trsm_complex_column_cpu_invoker()	496	static
trsm.cpp:203:1:void multi_blas_trsm_complex_column_cpu::test_method()	864	dynamic,bounded
trsm.cpp:221:1:void multi_blas_trsm_hydrogen_inq_case_real_invoker()	496	static
array_ref.hpp:1160:47:constexpr typename boost::multi::basic_array<T, 1, ElementPtr, Layout>::reference boost::multi::basic_array<T, 1, ElementPtr, Layout>::operator[](boost::multi::index) && [with T = double; ElementPtr = double*; Layout = boost::multi::layout_t<1>]	32	static
array_ref.hpp:410:31:constexpr typename boost::multi::basic_array<T, D, ElementPtr, Layout>::types::reference boost::multi::basic_array<T, D, ElementPtr, Layout>::operator[](boost::multi::index) & [with T = double; long int D = 2; ElementPtr = double*; Layout = boost::multi::layout_t<2>]	64	static
trsm.cpp:221:1:void multi_blas_trsm_hydrogen_inq_case_real::test_method()	848	dynamic,bounded
trsm.cpp:242:1:void multi_blas_trsm_hydrogen_inq_case_complex_invoker()	496	static
array.hpp:247:12:constexpr boost::multi::static_array<T, D, Alloc>::static_array(std::initializer_list<typename std::conditional<(boost::multi::static_array<T, D, Alloc>::dimensionality > 1), boost::multi::array<typename boost::multi::static_array<T, D, Alloc>::element, (boost::multi::static_array<T, D, Alloc>::dimensionality - 1), typename boost::multi::static_array<T, D, Alloc>::allocator_type>, typename std::conditional<(boost::multi::static_array<T, D, Alloc>::dimensionality == 1), typename boost::multi::static_array<T, D, Alloc>::element, typename boost::multi::static_array<T, D, Alloc>::element>::type>::type>) [with T = std::complex<double>; long int D = 1; Alloc = std::allocator<std::complex<double> >]	80	static
array.hpp:746:2:boost::multi::array<T, D, A>::array(const boost::multi::array<T, D, A>&) [with T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	32	static
numeric.hpp:247:12:constexpr boost::multi::blas::is_conjugated<A>::operator bool() const [with A = boost::multi::array<std::complex<double>, 2>]	48	static
trsm.hpp:26:16:decltype(auto) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, boost::multi::blas::diagonal, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::array<std::complex<double>, 2>; B2D = boost::multi::array<std::complex<double>, 2>&]	1936	dynamic,bounded
trsm.hpp:85:16:decltype(auto) boost::multi::blas::trsm(boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with A2D = boost::multi::array<std::complex<double>, 2>; B2D = boost::multi::array<std::complex<double>, 2>&]	112	static
numeric.hpp:260:16:decltype(auto) boost::multi::blas::conj(A&&) [with A = boost::multi::array<std::complex<double>, 2>&; D = boost::multi::array<std::complex<double>, 2>; Elem = std::complex<double>; Ptr = std::complex<double>*; typename std::enable_if<((! boost::multi::blas::is_conjugated<A>{}) && boost::multi::blas::is_complex_array<A>{}), int>::type <anonymous> = 0]	48	static
operations.hpp:18:16:decltype(auto) boost::multi::blas::conjugated_transposed(A&&) [with A = boost::multi::array<std::complex<double>, 2>&; D = boost::multi::array<std::complex<double>, 2>; E = std::complex<double>]	112	static
operations.hpp:35:16:decltype(auto) boost::multi::blas::hermitized(A&&) [with A = boost::multi::array<std::complex<double>, 2>&]	48	static
operations.hpp:47:17:decltype(auto) boost::multi::blas::operators::<unnamed struct>::operator()(A&&) const [with A = boost::multi::array<std::complex<double>, 2>&; typename std::enable_if<(typename std::decay<_Tp>::type::dimensionality == 2), int>::type <anonymous> = 0]	64	static
trsm.hpp:26:16:decltype(auto) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, boost::multi::blas::diagonal, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::array<std::complex<double>, 2>; B2D = boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >]	1936	dynamic,bounded
trsm.hpp:85:16:decltype(auto) boost::multi::blas::trsm(boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with A2D = boost::multi::array<std::complex<double>, 2>; B2D = boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >]	112	static
numeric.hpp:187:17:decltype(auto) boost::multi::blas::conjugate::operator()(T&&) const [with T = const std::complex<double>&]	32	static
gemm.hpp:325:6:auto boost::multi::blas::gemm(Scalar, const A2D&, const B2D&) [with Scalar = double; A2D = boost::multi::array<std::complex<double>, 2>; B2D = boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >]	80	static
trsm.cpp:242:1:void multi_blas_trsm_hydrogen_inq_case_complex::test_method()	1104	dynamic,bounded
trsm.cpp:276:1:void multi_blas_trsm_real_nonsquare_invoker()	496	static
gemm.hpp:325:6:auto boost::multi::blas::gemm(Scalar, const A2D&, const B2D&) [with Scalar = double; A2D = boost::multi::array<double, 2>; B2D = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >]	80	static
array_ref.hpp:754:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::begin() && [with T = double; long int D = 2; ElementPtr = double*; Layout = boost::multi::layout_t<2>]	48	static
array_ref.hpp:759:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::begin() const & [with T = double; long int D = 2; ElementPtr = double*; Layout = boost::multi::layout_t<2>]	64	dynamic,bounded
array.hpp:743:17:>&, const allocator_type&) [with TT = double; Args = {double*, boost::multi::layout_t<2, long int>}; <template-parameter-1-3> = void; <template-parameter-1-4> = boost::multi::array_iterator<double, 2, double*>][inherited from boost::multi::static_array<double, 2, std::allocator<double> >]	48	static
trsm.hpp:26:16:decltype(auto) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, boost::multi::blas::diagonal, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >; B2D = boost::multi::array<double, 2>&]	1920	dynamic,bounded
trsm.hpp:85:16:decltype(auto) boost::multi::blas::trsm(boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with A2D = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >; B2D = boost::multi::array<double, 2>&]	96	static
trsm.hpp:26:16:decltype(auto) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, boost::multi::blas::diagonal, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >; B2D = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >]	1920	dynamic,bounded
trsm.hpp:85:16:decltype(auto) boost::multi::blas::trsm(boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with A2D = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >; B2D = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >]	96	static
trsm.cpp:276:1:void multi_blas_trsm_real_nonsquare::test_method()	1552	dynamic,bounded
trsm.cpp:351:1:void multi_blas_trsm_complex_nonsquare_default_diagonal_hermitized_gemm_check_no_const_invoker()	496	static
trsm.cpp:351:1:void multi_blas_trsm_complex_nonsquare_default_diagonal_hermitized_gemm_check_no_const::test_method()	848	dynamic,bounded
trsm.cpp:370:1:void multi_blas_trsm_complex_nonsquare_default_diagonal_hermitized_gemm_check_invoker()	496	static
trsm.cpp:370:1:void multi_blas_trsm_complex_nonsquare_default_diagonal_hermitized_gemm_check::test_method()	1024	dynamic,bounded
trsm.cpp:409:1:void multi_blas_trsm_real_1x1_check_invoker()	496	static
trsm.cpp:409:1:void multi_blas_trsm_real_1x1_check::test_method()	544	dynamic,bounded
trsm.cpp:439:1:void multi_blas_trsm_complex_1x1_check_invoker()	496	static
gemm.hpp:325:6:auto boost::multi::blas::gemm(Scalar, const A2D&, const B2D&) [with Scalar = double; A2D = boost::multi::array<std::complex<double>, 2>; B2D = boost::multi::array<std::complex<double>, 2>]	80	static
gemm.hpp:325:6:auto boost::multi::blas::gemm(Scalar, const A2D&, const B2D&) [with Scalar = std::complex<double>; A2D = boost::multi::array<std::complex<double>, 2>; B2D = boost::multi::array<std::complex<double>, 2>]	96	static
trsm.cpp:439:1:void multi_blas_trsm_complex_1x1_check::test_method()	880	dynamic,bounded
trsm.cpp:463:1:void multi_blas_trsm_complex_thrust_nonsquare_default_diagonal_hermitized_gemm_check_invoker()	496	static
initializer_list:75:7:constexpr const _E* std::initializer_list<_E>::begin() const [with _E = boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >]	16	static
initializer_list:75:7:constexpr const _E* std::initializer_list<_E>::begin() const [with _E = thrust::complex<double>]	16	static
array.hpp:743:17:constexpr boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >::array(std::initializer_list<thrust::complex<double> >) [inherited from boost::multi::static_array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >]	48	static
array.hpp:929:2:boost::multi::array<T, D, A>::~array() [with T = thrust::complex<double>; long int D = 1; Alloc = std::allocator<thrust::complex<double> >]	32	static
array.hpp:743:17:constexpr boost::multi::array<thrust::complex<double>, 2>::array(std::initializer_list<boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > > >) [inherited from boost::multi::static_array<thrust::complex<double>, 2, std::allocator<thrust::complex<double> > >]	48	static
array.hpp:929:2:boost::multi::array<T, D, A>::~array() [with T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	32	static
numeric.hpp:260:16:decltype(auto) boost::multi::blas::conj(A&&) [with A = const boost::multi::array<thrust::complex<double>, 2>&; D = boost::multi::array<thrust::complex<double>, 2>; Elem = thrust::complex<double>; Ptr = thrust::complex<double>*; typename std::enable_if<((! boost::multi::blas::is_conjugated<A>{}) && boost::multi::blas::is_complex_array<A>{}), int>::type <anonymous> = 0]	48	static
operations.hpp:38:16:decltype(auto) boost::multi::blas::transposed(A&&) [with A = boost::multi::basic_array<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >]	48	static
operations.hpp:18:16:decltype(auto) boost::multi::blas::conjugated_transposed(A&&) [with A = const boost::multi::array<thrust::complex<double>, 2>&; D = boost::multi::array<thrust::complex<double>, 2>; E = thrust::complex<double>]	112	static
operations.hpp:35:16:decltype(auto) boost::multi::blas::hermitized(A&&) [with A = const boost::multi::array<thrust::complex<double>, 2>&]	48	static
operations.hpp:47:17:decltype(auto) boost::multi::blas::operators::<unnamed struct>::operator()(A&&) const [with A = const boost::multi::array<thrust::complex<double>, 2>&; typename std::enable_if<(typename std::decay<_Tp>::type::dimensionality == 2), int>::type <anonymous> = 0]	64	static
numeric.hpp:247:12:constexpr boost::multi::blas::is_conjugated<A>::operator bool() const [with A = boost::multi::basic_array<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >]	48	static
array_ref.hpp:570:31:constexpr boost::multi::basic_array<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> > boost::multi::operator~(const boost::multi::basic_array<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >&)	48	static
array_ref.hpp:566:24:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout> boost::multi::basic_array<T, D, ElementPtr, Layout>::transposed() const & [with T = thrust::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<2>]	96	static
array_ref.hpp:348:12:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::basic_array(const layout_type&, const ElementPtr&) [with T = thrust::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<2>]	48	static
range_access.h:242:5:size()) std::size(const _Container&) [with _Container = boost::multi::array<thrust::complex<double>, 2>]	32	static
array_ref.hpp:570:31:constexpr boost::multi::basic_array<thrust::complex<double>, 2, thrust::complex<double>*, boost::multi::layout_t<2> > boost::multi::operator~(const boost::multi::basic_array<thrust::complex<double>, 2, thrust::complex<double>*, boost::multi::layout_t<2> >&)	48	static
array_ref.hpp:566:24:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout> boost::multi::basic_array<T, D, ElementPtr, Layout>::transposed() const & [with T = thrust::complex<double>; long int D = 2; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<2>]	96	static
array_ref.hpp:348:12:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::basic_array(const layout_type&, const ElementPtr&) [with T = thrust::complex<double>; long int D = 2; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<2>]	48	static
array_ref.hpp:348:12:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::basic_array(const layout_type&, const ElementPtr&) [with T = thrust::complex<double>; long int D = 2; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<2>]	48	static
numeric.hpp:247:12:constexpr boost::multi::blas::is_conjugated<A>::operator bool() const [with A = boost::multi::array<thrust::complex<double>, 2>&]	48	static
trsm.hpp:26:16:decltype(auto) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, boost::multi::blas::diagonal, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::basic_array<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >; B2D = boost::multi::array<thrust::complex<double>, 2>&]	1936	dynamic,bounded
trsm.hpp:85:16:decltype(auto) boost::multi::blas::trsm(boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with A2D = boost::multi::basic_array<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >; B2D = boost::multi::array<thrust::complex<double>, 2>&]	128	static
array.hpp:746:2:boost::multi::array<T, D, A>::array(const boost::multi::array<T, D, A>&) [with T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	32	static
numeric.hpp:260:16:decltype(auto) boost::multi::blas::conj(A&&) [with A = boost::multi::array<thrust::complex<double>, 2>&; D = boost::multi::array<thrust::complex<double>, 2>; Elem = thrust::complex<double>; Ptr = thrust::complex<double>*; typename std::enable_if<((! boost::multi::blas::is_conjugated<A>{}) && boost::multi::blas::is_complex_array<A>{}), int>::type <anonymous> = 0]	48	static
operations.hpp:18:16:decltype(auto) boost::multi::blas::conjugated_transposed(A&&) [with A = boost::multi::array<thrust::complex<double>, 2>&; D = boost::multi::array<thrust::complex<double>, 2>; E = thrust::complex<double>]	112	static
operations.hpp:35:16:decltype(auto) boost::multi::blas::hermitized(A&&) [with A = boost::multi::array<thrust::complex<double>, 2>&]	48	static
operations.hpp:47:17:decltype(auto) boost::multi::blas::operators::<unnamed struct>::operator()(A&&) const [with A = boost::multi::array<thrust::complex<double>, 2>&; typename std::enable_if<(typename std::decay<_Tp>::type::dimensionality == 2), int>::type <anonymous> = 0]	64	static
numeric.hpp:247:12:constexpr boost::multi::blas::is_conjugated<A>::operator bool() const [with A = boost::multi::array<thrust::complex<double>, 2>]	48	static
trsm.hpp:26:16:decltype(auto) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, boost::multi::blas::diagonal, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::array<thrust::complex<double>, 2>; B2D = boost::multi::basic_array<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >]	1936	dynamic,bounded
trsm.hpp:85:16:decltype(auto) boost::multi::blas::trsm(boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with A2D = boost::multi::array<thrust::complex<double>, 2>; B2D = boost::multi::basic_array<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >]	112	static
trsm.cpp:463:1:void multi_blas_trsm_complex_thrust_nonsquare_default_diagonal_hermitized_gemm_check::test_method()	1024	dynamic,bounded
char_traits.h:100:7:static constexpr bool __gnu_cxx::char_traits<_CharT>::eq(const char_type&, const char_type&) [with _CharT = char]	16	static
char_traits.h:161:5:static constexpr std::size_t __gnu_cxx::char_traits<_CharT>::length(const char_type*) [with _CharT = char]	64	static
string_conversions.h:99:5:) [with _String = std::__cxx11::basic_string<char>; _CharT = char]	304	dynamic
basic_string.h:150:14:std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider()	32	static
basic_string.h:6097:5:std::__cxx11::basic_string<_CharT, _Traits, _Allocator> std::operator+(std::__cxx11::basic_string<_CharT, _Traits, _Allocator>&&, std::__cxx11::basic_string<_CharT, _Traits, _Allocator>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]	80	static
basic_string.h:6109:5:std::__cxx11::basic_string<_CharT, _Traits, _Allocator> std::operator+(const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Allocator>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]	48	static
basic_cstring.hpp:197:1:boost::unit_test::basic_cstring<CharT>::basic_cstring(const boost::unit_test::basic_cstring<CharT>&) [with CharT = const char]	16	static
basic_cstring.hpp:187:1:boost::unit_test::basic_cstring<CharT>::basic_cstring() [with CharT = const char]	32	static
atomic_base.h:279:17:constexpr std::__atomic_base<_IntTp>::__atomic_base(std::__atomic_base<_IntTp>::__int_type) [with _ITp = int]	16	static
shared_ptr.hpp:352:21:constexpr boost::shared_ptr<T>::shared_ptr() [with T = boost::basic_wrap_stringstream<char>]	32	static
class_properties.hpp:60:21:bool boost::unit_test::class_property<PropertyType>::operator!() const [with PropertyType = bool]	16	static
class_properties.hpp:131:21:boost::unit_test::readonly_property<PropertyType>::readonly_property(boost::unit_test::readonly_property<PropertyType>::write_param_t) [with PropertyType = bool]	32	static
operator_bool.hpp:61:10:bool boost::shared_ptr<T>::operator!() const [with T = boost::basic_wrap_stringstream<char>]	16	static
shared_ptr.hpp:696:28:void boost::shared_ptr<T>::reset(Y*) [with Y = boost::basic_wrap_stringstream<char>; T = boost::basic_wrap_stringstream<char>]	64	static
shared_ptr.hpp:726:55:typename boost::detail::sp_dereference<T>::type boost::shared_ptr<T>::operator*() const [with T = boost::basic_wrap_stringstream<char>]	32	static
shared_ptr.hpp:732:57:typename boost::detail::sp_member_access<T>::type boost::shared_ptr<T>::operator->() const [with T = boost::basic_wrap_stringstream<char>]	32	static
wrap_stringstream.hpp:92:1:const std::__cxx11::basic_string<_CharT>& boost::basic_wrap_stringstream<CharT>::str() [with CharT = char]	80	static
basic_cstring.hpp:207:1:boost::unit_test::basic_cstring<CharT>::basic_cstring(const std_string&) [with CharT = const char]	48	static
basic_string.h:525:7:std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, const _Alloc&) [with <template-parameter-2-1> = std::allocator<char>; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]	64	static
function_template.hpp:756:5:boost::function0<R>::~function0() [with R = void]	32	static
shared_ptr.hpp:422:5:boost::shared_ptr<T>::shared_ptr(const boost::shared_ptr<T>&) [with T = boost::unit_test::test_unit_fixture]	32	static
basic_cstring.hpp:479:1:boost::unit_test::basic_cstring<CharT>::value_type* boost::unit_test::basic_cstring<CharT>::begin() [with CharT = const char]	16	static
basic_cstring.hpp:258:1:boost::unit_test::basic_cstring<CharT>::size_type boost::unit_test::basic_cstring<CharT>::size() const [with CharT = const char]	16	static
basic_cstring.hpp:79:5:boost::unit_test::basic_cstring<CharT>::basic_cstring(boost::unit_test::basic_cstring<CharT>::pointer, LenType) [with LenType = long unsigned int; CharT = const char]	16	static
basic_cstring.hpp:217:1:boost::unit_test::basic_cstring<CharT>::basic_cstring(boost::unit_test::basic_cstring<CharT>::pointer) [with CharT = const char]	48	static
basic_cstring.hpp:393:1:boost::unit_test::basic_cstring<CharT>::self_type& boost::unit_test::basic_cstring<CharT>::trim(boost::unit_test::basic_cstring<CharT>) [with CharT = const char]	64	static
tuple:588:19: (_Elements) >= 1)), bool>::type <anonymous> = true; _Elements = {boost::multi::extension_t<long int, long int>}]	32	static
tuple:1326:5:>&) [with long unsigned int __i = 0; _Elements = {boost::multi::extension_t<long int, long int>}]	32	static
index_range.hpp:143:22:constexpr boost::multi::range<IndexType, IndexTypeLast>::size_type boost::multi::range<IndexType, IndexTypeLast>::size() const [with IndexType = long int; IndexTypeLast = long int]	16	static
tuple:1470:5:) [with _Elements = {const boost::multi::extension_t<long int, long int>&}]	32	static
layout.hpp:164:12:I = {0, 1}; <template-parameter-2-3> = std::tuple<boost::multi::extension_t<long int, long int>, boost::multi::extension_t<long int, long int> >; long int D = 2]	48	static
layout.hpp:137:12:constexpr boost::multi::extensions_t<D>::extensions_t(const Array&) [with Array = std::tuple<boost::multi::extension_t<long int, long int>, boost::multi::extension_t<long int, long int> >; <template-parameter-2-2> = boost::multi::extension_t<long int>&&; long int D = 2]	32	static
tuple:1597:5:) [with _Tpls = {std::tuple<boost::multi::extension_t<long int, long int> >, const std::tuple<boost::multi::extension_t<long int, long int> >&}; <template-parameter-1-2> = void]	80	static
layout.hpp:138:12:constexpr boost::multi::extensions_t<D>::extensions_t(const index_extension&, const typename boost::multi::layout_t<(D - 1)>::extensions_type&) [with long int D = 2]	128	static
wrap_stringstream.hpp:83:1:boost::basic_wrap_stringstream<CharT>& boost::basic_wrap_stringstream<CharT>::ref() [with CharT = char]	16	static
wrap_stringstream.hpp:64:1:boost::basic_wrap_stringstream<CharT>& boost::operator<<(boost::basic_wrap_stringstream<CharT>&, const T&) [with CharT = char; T = char]	32	static
wrap_stringstream.hpp:64:1:boost::basic_wrap_stringstream<CharT>& boost::operator<<(boost::basic_wrap_stringstream<CharT>&, const T&) [with CharT = char; T = char [27]]	32	static
wrap_stringstream.hpp:64:1:boost::basic_wrap_stringstream<CharT>& boost::operator<<(boost::basic_wrap_stringstream<CharT>&, const T&) [with CharT = char; T = char [15]]	32	static
wrap_stringstream.hpp:64:1:boost::basic_wrap_stringstream<CharT>& boost::operator<<(boost::basic_wrap_stringstream<CharT>&, const T&) [with CharT = char; T = char [16]]	32	static
fixture.hpp:112:6:void boost::unit_test::setup_conditional(U&) [with U = multi_blas_trsm_double_0x0]	48	static
wrap_stringstream.hpp:64:1:boost::basic_wrap_stringstream<CharT>& boost::operator<<(boost::basic_wrap_stringstream<CharT>&, const T&) [with CharT = char; T = char [13]]	32	static
wrap_stringstream.hpp:64:1:boost::basic_wrap_stringstream<CharT>& boost::operator<<(boost::basic_wrap_stringstream<CharT>&, const T&) [with CharT = char; T = char [19]]	32	static
fixture.hpp:118:6:void boost::unit_test::teardown_conditional(U&) [with U = multi_blas_trsm_double_0x0]	48	static
function_template.hpp:1061:3:boost::function<R()>::function(Functor, typename boost::enable_if_<(! boost::is_integral<Functor>::value), int>::type) [with Functor = void (*)(); R = void]	48	static
fpc_tolerance.hpp:76:1:boost::unit_test::decorator::fixture_t boost::unit_test::decorator::tolerance(FPT) [with FPT = double]	80	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array_iterator<double, 1, const double*>]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array_iterator<double, 1, double*>]	16	static
adl.hpp:96:48:constexpr decltype (std::copy(first, last, d_first)) boost::multi::adl_copy_fn__::_(boost::multi::priority<1>, InputIt, InputIt, OutputIt) const [with InputIt = boost::multi::array_iterator<double, 1, const double*>; OutputIt = boost::multi::array_iterator<double, 1, double*>; <template-parameter-1-3> = void]	80	static
allocator.h:138:7:std::allocator< <template-parameter-1-1> >::allocator() [with _Tp = double]	32	static
allocator.h:153:7:std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = double]	32	static
array.hpp:30:2:boost::multi::array_allocator<Allocator>::array_allocator(const allocator_type&) [with Allocator = std::allocator<double>]	32	static
layout.hpp:221:2:constexpr boost::multi::layout_t<1, SSize>::layout_t() [with SSize = long int]	16	static
layout.hpp:338:2:constexpr boost::multi::layout_t<D, SSize>::layout_t() [with long int D = 2; SSize = long int]	32	static
array_ref.hpp:1403:12:constexpr boost::multi::array_ref<T, D, ElementPtr>::array_ref() [with T = double; long int D = 2; ElementPtr = double*]	128	static
array.hpp:278:2:boost::multi::static_array<T, D, Alloc>::~static_array() [with T = double; long int D = 2; Alloc = std::allocator<double>]	32	static
array_ref.hpp:93:29:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::element_ptr boost::multi::array_types<T, D, ElementPtr, Layout>::base() const [with T = double; long int D = 2; ElementPtr = double*; Layout = boost::multi::layout_t<2>]	16	static
array.hpp:326:53:constexpr boost::multi::static_array<T, D, Alloc>::element_const_ptr boost::multi::static_array<T, D, Alloc>::base() const [with T = double; long int D = 2; Alloc = std::allocator<double>]	32	static
core.hpp:573:16:boost::multi::blas::context* boost::multi::blas::default_context_of(const TPtr&) [with TPtr = const double*; typename std::enable_if<std::is_convertible<TPtr, typename std::pointer_traits<_Ptr>::element_type*>{}, int>::type <anonymous> = 0]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array<double, 2>&]	16	static
array_ref.hpp:109:12:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::array_types(const layout_t&, const element_ptr&) [with T = double; long int D = 2; ElementPtr = double*; Layout = boost::multi::layout_t<2>]	24	static
move.h:99:5:constexpr typename std::remove_reference<_Tp>::type&& std::move(_Tp&&) [with _Tp = long int&]	16	static
move.h:182:5:typename std::enable_if<std::__and_<std::__not_<std::__is_tuple_like<_Tp> >, std::is_move_constructible<_Tp>, std::is_move_assignable<_Tp> >::value>::type std::swap(_Tp&, _Tp&) [with _Tp = long int]	48	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::blas::context*]	16	static
array.hpp:328:50:const double* boost::multi::base(const boost::multi::static_array<double, 2, std::allocator<double> >&)	32	static
array.hpp:327:50:double* boost::multi::base(boost::multi::static_array<double, 2, std::allocator<double> >&)	32	static
core.hpp:547:14:) [with As = {char, char, char, char, long int, long int, double&, const double*, long int, double*, long int}]	192	dynamic,bounded
basic_string.h:6121:5:std::__cxx11::basic_string<_CharT, _Traits, _Allocator> std::operator+(std::__cxx11::basic_string<_CharT, _Traits, _Allocator>&&, const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]	48	static
basic_string.h:6127:5:std::__cxx11::basic_string<_CharT, _Traits, _Allocator> std::operator+(std::__cxx11::basic_string<_CharT, _Traits, _Allocator>&&, _CharT) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]	48	static
fixture.hpp:112:6:void boost::unit_test::setup_conditional(U&) [with U = multi_blas_trsm_double_1x1]	48	static
fixture.hpp:118:6:void boost::unit_test::teardown_conditional(U&) [with U = multi_blas_trsm_double_1x1]	48	static
array.hpp:278:2:boost::multi::static_array<T, D, Alloc>::~static_array() [with T = double; long int D = 1; Alloc = std::allocator<double>]	32	static
initializer_list:79:7:constexpr const _E* std::initializer_list<_E>::end() const [with _E = double]	48	static
layout.hpp:261:22:constexpr boost::multi::layout_t<1, SSize>::size_type boost::multi::layout_t<1, SSize>::num_elements() const [with SSize = long int]	32	static
layout.hpp:223:12:constexpr boost::multi::layout_t<1, SSize>::layout_t(boost::multi::layout_t<1, SSize>::index_extension, const boost::multi::layout_t<0>&) [with SSize = long int]	48	static
tuple:1320:5:>&) [with long unsigned int __i = 0; _Elements = {boost::multi::extension_t<long int, long int>}]	32	static
layout.hpp:192:12:constexpr boost::multi::layout_t<0, SSize>::layout_t(const extensions_type&) [with SSize = long int]	16	static
layout.hpp:230:12:constexpr boost::multi::layout_t<1, SSize>::layout_t(boost::multi::layout_t<1, SSize>::extensions_type) [with SSize = long int]	80	static
index_range.hpp:213:12:constexpr boost::multi::extension_t<IndexType, IndexTypeLast>::extension_t(IndexType) [with IndexType = long int; IndexTypeLast = long int]	32	static
adl.hpp:392:39:) const [with As = {const double*&, const double*&}]	80	static
utility.hpp:375:64:constexpr boost::multi::layout_t<0>::extensions_type boost::multi::extensions(const T&) [with T = double; <template-parameter-1-2> = void]	16	static
adl.hpp:387:48:) const [with As = {const double*&, const double*&}]	64	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const double*&]	16	static
stl_iterator_base_funcs.h:138:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = const double*]	32	static
adl.hpp:343:16:constexpr auto boost::multi::xtd::alloc_uninitialized_copy(std::allocator<_CharT>&, InputIt, InputIt, ForwardIt) [with T = double; InputIt = const double*; ForwardIt = boost::multi::array_iterator<double, 1, double*>]	64	static
adl.hpp:482:39:) const [with As = {std::allocator<double>&, const double*&, const double*&, boost::multi::array_iterator<double, 1, double*>}]	112	static
array.hpp:146:2:boost::multi::static_array<T, D, Alloc>::static_array(It, It, const allocator_type&) [with It = const double*; <template-parameter-2-2> = long int; T = double; long int D = 1; Alloc = std::allocator<double>]	176	static
array.hpp:247:12:constexpr boost::multi::static_array<T, D, Alloc>::static_array(std::initializer_list<typename std::conditional<(boost::multi::static_array<T, D, Alloc>::dimensionality > 1), boost::multi::array<typename boost::multi::static_array<T, D, Alloc>::element, (boost::multi::static_array<T, D, Alloc>::dimensionality - 1), typename boost::multi::static_array<T, D, Alloc>::allocator_type>, typename std::conditional<(boost::multi::static_array<T, D, Alloc>::dimensionality == 1), typename boost::multi::static_array<T, D, Alloc>::element, typename boost::multi::static_array<T, D, Alloc>::element>::type>::type>) [with T = double; long int D = 2; Alloc = std::allocator<double>]	80	static
layout.hpp:366:22:constexpr boost::multi::layout_t<D, SSize>::size_type boost::multi::layout_t<D, SSize>::num_elements() const [with long int D = 2; SSize = long int]	48	static
utility.hpp:156:16:num_elements())> boost::multi::num_elements(const A&) [with A = boost::multi::static_array<double, 2, std::allocator<double> >; <template-parameter-1-2> = void]	32	static
adl.hpp:292:39:) const [with As = {const double*&, long int&, double*&}]	80	static
adl.hpp:307:16:constexpr auto boost::multi::xtd::alloc_uninitialized_copy_n(std::allocator<_CharT>&, InputIt, Size, ForwardIt) [with T = double; InputIt = const double*; Size = long int; ForwardIt = double*]	48	static
adl.hpp:486:48:) const [with As = {std::allocator<double>&, const double*&, long int&, double*&}]	96	static
adl.hpp:490:39:) const [with As = {std::allocator<double>&, const double*&, long int&, double*&}]	112	static
array.hpp:39:7:auto boost::multi::array_allocator<Allocator>::uninitialized_copy_n(It, boost::multi::size_type, typename std::allocator_traits<_Alloc>::pointer) [with It = const double*; Allocator = std::allocator<double>]	48	static
array.hpp:82:29:auto boost::multi::static_array<T, D, Alloc>::uninitialized_copy_elements(It) [with It = const double*; T = double; long int D = 2; Alloc = std::allocator<double>]	48	static
array.hpp:239:2:boost::multi::static_array<T, D, Alloc>::static_array(const boost::multi::static_array<T, D, Alloc>&) [with T = double; long int D = 2; Alloc = std::allocator<double>]	96	static
assertion.hpp:393:5:boost::test_tools::assertion::value_expr<T> boost::test_tools::assertion::seed::operator->*(T&&) const [with T = double&]	48	static
assertion.hpp:216:5:boost::test_tools::assertion::binary_expr<ExprType, T, boost::test_tools::assertion::op::EQ<ValType, typename boost::test_tools::assertion::expression_base<ExprType, ValType>::RhsT<T>::type> > boost::test_tools::assertion::expression_base<ExprType, ValType>::operator==(T&&) [with T = double; ExprType = boost::test_tools::assertion::value_expr<double&>; ValType = double]	64	static
assertion_result.hpp:39:23:boost::test_tools::assertion_result::assertion_result(const boost::test_tools::assertion_result&)	32	static
assertion.hpp:361:33:boost::test_tools::assertion_result boost::test_tools::assertion::binary_expr<Lhs, Rhs, OP>::evaluate(bool) const [with LExpr = boost::test_tools::assertion::value_expr<double&>; Rhs = double; OP = boost::test_tools::assertion::op::EQ<double, double, void>]	576	static
lazy_ostream.hpp:79:1:boost::unit_test::lazy_ostream_impl<boost::unit_test::lazy_ostream, T> boost::unit_test::operator<<(const boost::unit_test::lazy_ostream&, const T&) [with T = boost::unit_test::basic_cstring<const char>]	48	static
gemm.hpp:317:1:boost::multi::blas::gemm_range<ContextPtr, Scalar, typename A2D::const_iterator, typename B2D::const_iterator, typename A2D::decay_type> boost::multi::blas::gemm(ContextPtr, Scalar, const A2D&, const B2D&) [with ContextPtr = boost::multi::blas::context*; Scalar = double; A2D = boost::multi::array<double, 2>; B2D = boost::multi::array<double, 2>; <template-parameter-1-5> = void]	336	dynamic,bounded
array_ref.hpp:247:27:constexpr decltype(auto) boost::multi::array_iterator<Element, D, ElementPtr>::operator->() const [with Element = double; long int D = 2; ElementPtr = const double*]	16	static
array.hpp:743:17:boost::multi::array<double, 2>::array(Range&&) [with Range = const boost::multi::blas::gemm_range<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array<double, 2> >&; <template-parameter-1-2> = void; <template-parameter-1-3> = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >; <template-parameter-1-4> = void][inherited from boost::multi::static_array<double, 2, std::allocator<double> >]	32	static
gemm.hpp:307:13:boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::decay_type boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::operator+() const [with ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<double, 2, const double*>; ItB = boost::multi::array_iterator<double, 2, const double*>; DecayType = boost::multi::array<double, 2>]	32	static
array_ref.hpp:409:31:constexpr typename boost::multi::basic_array<T, D, ElementPtr, Layout>::types::reference boost::multi::basic_array<T, D, ElementPtr, Layout>::operator[](boost::multi::index) && [with T = double; long int D = 2; ElementPtr = double*; Layout = boost::multi::layout_t<2>]	64	static
assertion.hpp:216:5:boost::test_tools::assertion::binary_expr<ExprType, T, boost::test_tools::assertion::op::EQ<ValType, typename boost::test_tools::assertion::expression_base<ExprType, ValType>::RhsT<T>::type> > boost::test_tools::assertion::expression_base<ExprType, ValType>::operator==(T&&) [with T = const double&; ExprType = boost::test_tools::assertion::value_expr<double&>; ValType = double]	64	static
assertion.hpp:361:33:boost::test_tools::assertion_result boost::test_tools::assertion::binary_expr<Lhs, Rhs, OP>::evaluate(bool) const [with LExpr = boost::test_tools::assertion::value_expr<double&>; Rhs = const double&; OP = boost::test_tools::assertion::op::EQ<double, double, void>]	576	static
layout.hpp:283:17:constexpr auto boost::multi::layout_t<1, SSize>::operator()(boost::multi::layout_t<1, SSize>::index) const [with SSize = long int]	16	static
array_ref.hpp:1157:53:constexpr typename boost::multi::basic_array<T, 1, ElementPtr, Layout>::reference boost::multi::basic_array<T, 1, ElementPtr, Layout>::operator[](boost::multi::index) & [with T = double; ElementPtr = const double*; Layout = boost::multi::layout_t<1>]	48	static
array_ref.hpp:109:12:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::array_types(const layout_t&, const element_ptr&) [with T = double; long int D = 1; ElementPtr = double*; Layout = boost::multi::layout_t<1>]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::basic_array<double, 1, double*, boost::multi::layout_t<1> >]	16	static
array_ref.hpp:116:12:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::array_types(const ArrayTypes&) [with ArrayTypes = boost::multi::basic_array<double, 1, double*, boost::multi::layout_t<1> >; <template-parameter-2-2> = void; <template-parameter-2-3> = const double*; T = double; long int D = 1; ElementPtr = const double*; Layout = boost::multi::layout_t<1>]	16	static
wrap_stringstream.hpp:64:1:boost::basic_wrap_stringstream<CharT>& boost::operator<<(boost::basic_wrap_stringstream<CharT>&, const T&) [with CharT = char; T = char [28]]	32	static
fixture.hpp:112:6:void boost::unit_test::setup_conditional(U&) [with U = multi_blas_trsm_real_square]	48	static
fixture.hpp:118:6:void boost::unit_test::teardown_conditional(U&) [with U = multi_blas_trsm_real_square]	48	static
array_ref.hpp:399:20:boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >::decay_type boost::multi::operator+(const boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >&)	48	static
stl_algobase.h:198:5:constexpr const _Tp& std::min(const _Tp&, const _Tp&) [with _Tp = long int]	16	static
array.hpp:435:44:constexpr boost::multi::static_array<T, D, Alloc>::iterator boost::multi::static_array<T, D, Alloc>::begin() [with T = double; long int D = 2; Alloc = std::allocator<double>]	48	static
trsm.hpp:80:6:decltype (boost::multi::blas::trsm(forward<Context>(ctxt), a_side, a_fill, boost::multi::blas::diagonal::general, alpha, a, forward<B2D>(b))) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::array<double, 2>; B2D = boost::multi::array<double, 2>&]	80	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::array<double, 2>&]	16	static
array_ref.hpp:93:29:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::element_ptr boost::multi::array_types<T, D, ElementPtr, Layout>::base() const [with T = double; long int D = 2; ElementPtr = const double*; Layout = boost::multi::layout_t<2>]	16	static
array_ref.hpp:345:24:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::layout_type boost::multi::basic_array<T, D, ElementPtr, Layout>::layout() const [with T = double; long int D = 2; ElementPtr = const double*; Layout = boost::multi::layout_t<2>]	48	static
array_ref.hpp:109:12:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::array_types(const layout_t&, const element_ptr&) [with T = double; long int D = 2; ElementPtr = const double*; Layout = boost::multi::layout_t<2>]	24	static
array_ref.hpp:95:31:constexpr const double* boost::multi::base(const boost::multi::array_types<double, 2, const double*, boost::multi::layout_t<2> >&)	32	static
trsm.hpp:80:6:decltype (boost::multi::blas::trsm(forward<Context>(ctxt), a_side, a_fill, boost::multi::blas::diagonal::general, alpha, a, forward<B2D>(b))) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::basic_array<double, 2, const double*, boost::multi::layout_t<2> >; B2D = boost::multi::array<double, 2>&]	80	static
gemm.hpp:317:1:boost::multi::blas::gemm_range<ContextPtr, Scalar, typename A2D::const_iterator, typename B2D::const_iterator, typename A2D::decay_type> boost::multi::blas::gemm(ContextPtr, Scalar, const A2D&, const B2D&) [with ContextPtr = boost::multi::blas::context*; Scalar = double; A2D = boost::multi::basic_array<double, 2, const double*, boost::multi::layout_t<2> >; B2D = boost::multi::array<double, 2>; <template-parameter-1-5> = void]	336	dynamic,bounded
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >]	16	static
array_ref.hpp:95:31:constexpr double* boost::multi::base(const boost::multi::array_types<double, 2, double*, boost::multi::layout_t<2> >&)	32	static
trsm.hpp:80:6:decltype (boost::multi::blas::trsm(forward<Context>(ctxt), a_side, a_fill, boost::multi::blas::diagonal::general, alpha, a, forward<B2D>(b))) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::basic_array<double, 2, const double*, boost::multi::layout_t<2> >; B2D = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >]	80	static
gemm.hpp:317:1:boost::multi::blas::gemm_range<ContextPtr, Scalar, typename A2D::const_iterator, typename B2D::const_iterator, typename A2D::decay_type> boost::multi::blas::gemm(ContextPtr, Scalar, const A2D&, const B2D&) [with ContextPtr = boost::multi::blas::context*; Scalar = double; A2D = boost::multi::basic_array<double, 2, const double*, boost::multi::layout_t<2> >; B2D = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >; <template-parameter-1-5> = void]	336	dynamic,bounded
trsm.hpp:80:6:decltype (boost::multi::blas::trsm(forward<Context>(ctxt), a_side, a_fill, boost::multi::blas::diagonal::general, alpha, a, forward<B2D>(b))) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::array<double, 2>; B2D = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >]	80	static
wrap_stringstream.hpp:64:1:boost::basic_wrap_stringstream<CharT>& boost::operator<<(boost::basic_wrap_stringstream<CharT>&, const T&) [with CharT = char; T = char [24]]	32	static
fixture.hpp:112:6:void boost::unit_test::setup_conditional(U&) [with U = multi_blas_trsm_complex]	48	static
fixture.hpp:118:6:void boost::unit_test::teardown_conditional(U&) [with U = multi_blas_trsm_complex]	48	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>]	16	static
adl.hpp:101:48:) const [with As = {boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>}]	64	static
complex:409:5:std::complex<_Tp> std::operator*(const _Tp&, const std::complex<_Tp>&) [with _Tp = double]	64	static
complex:349:5:std::complex<_Tp> std::operator+(const _Tp&, const std::complex<_Tp>&) [with _Tp = double]	64	static
complex:379:5:std::complex<_Tp> std::operator-(const _Tp&, const std::complex<_Tp>&) [with _Tp = double]	64	static
array.hpp:25:34:boost::multi::array_allocator<std::allocator<std::complex<double> > >::~array_allocator()	32	static
array.hpp:278:2:boost::multi::static_array<T, D, Alloc>::~static_array() [with T = std::complex<double>; long int D = 1; Alloc = std::allocator<std::complex<double> >]	32	static
array.hpp:247:12:constexpr boost::multi::static_array<T, D, Alloc>::static_array(std::initializer_list<typename std::conditional<(boost::multi::static_array<T, D, Alloc>::dimensionality > 1), boost::multi::array<typename boost::multi::static_array<T, D, Alloc>::element, (boost::multi::static_array<T, D, Alloc>::dimensionality - 1), typename boost::multi::static_array<T, D, Alloc>::allocator_type>, typename std::conditional<(boost::multi::static_array<T, D, Alloc>::dimensionality == 1), typename boost::multi::static_array<T, D, Alloc>::element, typename boost::multi::static_array<T, D, Alloc>::element>::type>::type>) [with T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	80	static
array.hpp:278:2:boost::multi::static_array<T, D, Alloc>::~static_array() [with T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	32	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::array<std::complex<double>, 2>&]	16	static
numeric.hpp:139:21:constexpr boost::multi::blas::involuter<It, F, Reference>::involuter(It, F) [with It = std::complex<double>*; F = boost::multi::blas::conjugate; Reference = boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate>]	48	static
array_ref.hpp:858:35:constexpr boost::multi::basic_array<T2, D, P2> boost::multi::basic_array<T, D, ElementPtr, Layout>::static_array_cast() const [with T2 = std::complex<double>; P2 = boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >; T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<2>]	112	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = std::complex<double>&]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >]	16	static
array_ref.hpp:586:37:constexpr boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> > boost::multi::rotated(boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >&&)	48	static
array_ref.hpp:93:29:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::element_ptr boost::multi::array_types<T, D, ElementPtr, Layout>::base() const [with T = std::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<2>]	16	static
numeric.hpp:161:35:constexpr std::complex<double>* boost::multi::blas::underlying(const boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >&)	16	static
core.hpp:573:16:boost::multi::blas::context* boost::multi::blas::default_context_of(const TPtr&) [with TPtr = std::complex<double>*; typename std::enable_if<std::is_convertible<TPtr, typename std::pointer_traits<_Ptr>::element_type*>{}, int>::type <anonymous> = 0]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array<std::complex<double>, 2>&]	16	static
array_ref.hpp:345:24:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::layout_type boost::multi::basic_array<T, D, ElementPtr, Layout>::layout() const [with T = std::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<2>]	48	static
array_ref.hpp:109:12:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::array_types(const layout_t&, const element_ptr&) [with T = std::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<2>]	24	static
array_ref.hpp:345:24:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::layout_type boost::multi::basic_array<T, D, ElementPtr, Layout>::layout() const [with T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<2>]	48	static
array_ref.hpp:109:12:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::array_types(const layout_t&, const element_ptr&) [with T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<2>]	24	static
array_ref.hpp:95:31:constexpr boost::multi::array_types<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >::element_ptr boost::multi::base(const boost::multi::array_types<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >&)	32	static
array.hpp:327:50:std::complex<double>* boost::multi::base(boost::multi::static_array<std::complex<double>, 2, std::allocator<std::complex<double> > >&)	32	static
core.hpp:547:14:) [with As = {char, char, char, char, long int, long int, std::complex<double>&, std::complex<double>*, long int, std::complex<double>*, long int}]	192	dynamic,bounded
trsm.hpp:80:6:decltype (boost::multi::blas::trsm(forward<Context>(ctxt), a_side, a_fill, boost::multi::blas::diagonal::general, alpha, a, forward<B2D>(b))) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >; B2D = boost::multi::array<std::complex<double>, 2>&]	80	static
array_ref.hpp:1077:15:constexpr boost::multi::basic_array<std::complex<double>, 1, std::complex<double>*, boost::multi::layout_t<1> >::basic_array(const layout_t&, std::complex<double>* const&) [inherited from boost::multi::array_types<std::complex<double>, 1, std::complex<double>*, boost::multi::layout_t<1> >]	48	static
array_ref.hpp:404:20:constexpr auto boost::multi::basic_array<T, D, ElementPtr, Layout>::at_(boost::multi::index) const [with T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<2>]	144	static
array_ref.hpp:410:31:constexpr typename boost::multi::basic_array<T, D, ElementPtr, Layout>::types::reference boost::multi::basic_array<T, D, ElementPtr, Layout>::operator[](boost::multi::index) & [with T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<2>]	64	static
array_ref.hpp:1160:47:constexpr typename boost::multi::basic_array<T, 1, ElementPtr, Layout>::reference boost::multi::basic_array<T, 1, ElementPtr, Layout>::operator[](boost::multi::index) && [with T = std::complex<double>; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<1>]	32	static
complex:566:5:constexpr _Tp std::real(const std::complex<_Tp>&) [with _Tp = double]	32	static
assertion.hpp:393:5:boost::test_tools::assertion::value_expr<T> boost::test_tools::assertion::seed::operator->*(T&&) const [with T = double]	48	static
assertion.hpp:216:5:boost::test_tools::assertion::binary_expr<ExprType, T, boost::test_tools::assertion::op::EQ<ValType, typename boost::test_tools::assertion::expression_base<ExprType, ValType>::RhsT<T>::type> > boost::test_tools::assertion::expression_base<ExprType, ValType>::operator==(T&&) [with T = double; ExprType = boost::test_tools::assertion::value_expr<double>; ValType = double]	64	static
assertion.hpp:361:33:boost::test_tools::assertion_result boost::test_tools::assertion::binary_expr<Lhs, Rhs, OP>::evaluate(bool) const [with LExpr = boost::test_tools::assertion::value_expr<double>; Rhs = double; OP = boost::test_tools::assertion::op::EQ<double, double, void>]	576	static
wrap_stringstream.hpp:64:1:boost::basic_wrap_stringstream<CharT>& boost::operator<<(boost::basic_wrap_stringstream<CharT>&, const T&) [with CharT = char; T = char [36]]	32	static
fixture.hpp:112:6:void boost::unit_test::setup_conditional(U&) [with U = multi_blas_trsm_complex_rectangular]	48	static
fixture.hpp:118:6:void boost::unit_test::teardown_conditional(U&) [with U = multi_blas_trsm_complex_rectangular]	48	static
wrap_stringstream.hpp:64:1:boost::basic_wrap_stringstream<CharT>& boost::operator<<(boost::basic_wrap_stringstream<CharT>&, const T&) [with CharT = char; T = char [31]]	32	static
fixture.hpp:112:6:void boost::unit_test::setup_conditional(U&) [with U = multi_blas_trsm_complex_column]	48	static
fixture.hpp:118:6:void boost::unit_test::teardown_conditional(U&) [with U = multi_blas_trsm_complex_column]	48	static
wrap_stringstream.hpp:64:1:boost::basic_wrap_stringstream<CharT>& boost::operator<<(boost::basic_wrap_stringstream<CharT>&, const T&) [with CharT = char; T = char [35]]	32	static
fixture.hpp:112:6:void boost::unit_test::setup_conditional(U&) [with U = multi_blas_trsm_complex_column_cpu]	48	static
fixture.hpp:118:6:void boost::unit_test::teardown_conditional(U&) [with U = multi_blas_trsm_complex_column_cpu]	48	static
wrap_stringstream.hpp:64:1:boost::basic_wrap_stringstream<CharT>& boost::operator<<(boost::basic_wrap_stringstream<CharT>&, const T&) [with CharT = char; T = char [39]]	32	static
fixture.hpp:112:6:void boost::unit_test::setup_conditional(U&) [with U = multi_blas_trsm_hydrogen_inq_case_real]	48	static
fixture.hpp:118:6:void boost::unit_test::teardown_conditional(U&) [with U = multi_blas_trsm_hydrogen_inq_case_real]	48	static
array_ref.hpp:1157:53:constexpr typename boost::multi::basic_array<T, 1, ElementPtr, Layout>::reference boost::multi::basic_array<T, 1, ElementPtr, Layout>::operator[](boost::multi::index) & [with T = double; ElementPtr = double*; Layout = boost::multi::layout_t<1>]	48	static
array_ref.hpp:1077:15:constexpr boost::multi::basic_array<double, 1, const double*, boost::multi::layout_t<1> >::basic_array(const layout_t&, const double* const&) [inherited from boost::multi::array_types<double, 1, const double*, boost::multi::layout_t<1> >]	48	static
array_ref.hpp:404:20:constexpr auto boost::multi::basic_array<T, D, ElementPtr, Layout>::at_(boost::multi::index) const [with T = double; long int D = 2; ElementPtr = const double*; Layout = boost::multi::layout_t<2>]	144	static
array_ref.hpp:409:31:constexpr typename boost::multi::basic_array<T, D, ElementPtr, Layout>::types::reference boost::multi::basic_array<T, D, ElementPtr, Layout>::operator[](boost::multi::index) && [with T = double; long int D = 2; ElementPtr = const double*; Layout = boost::multi::layout_t<2>]	64	static
wrap_stringstream.hpp:64:1:boost::basic_wrap_stringstream<CharT>& boost::operator<<(boost::basic_wrap_stringstream<CharT>&, const T&) [with CharT = char; T = char [42]]	32	static
fixture.hpp:112:6:void boost::unit_test::setup_conditional(U&) [with U = multi_blas_trsm_hydrogen_inq_case_complex]	48	static
fixture.hpp:118:6:void boost::unit_test::teardown_conditional(U&) [with U = multi_blas_trsm_hydrogen_inq_case_complex]	48	static
initializer_list:79:7:constexpr const _E* std::initializer_list<_E>::end() const [with _E = std::complex<double>]	48	static
allocator.h:138:7:std::allocator< <template-parameter-1-1> >::allocator() [with _Tp = std::complex<double>]	32	static
allocator.h:153:7:std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = std::complex<double>]	32	static
adl.hpp:392:39:) const [with As = {const std::complex<double>*&, const std::complex<double>*&}]	80	static
utility.hpp:375:64:constexpr boost::multi::layout_t<0>::extensions_type boost::multi::extensions(const T&) [with T = std::complex<double>; <template-parameter-1-2> = void]	16	static
adl.hpp:388:48:) const [with As = {const std::complex<double>*&, const std::complex<double>*&}]	64	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const std::complex<double>*&]	16	static
stl_iterator_base_funcs.h:138:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = const std::complex<double>*]	32	static
adl.hpp:343:16:constexpr auto boost::multi::xtd::alloc_uninitialized_copy(std::allocator<_CharT>&, InputIt, InputIt, ForwardIt) [with T = std::complex<double>; InputIt = const std::complex<double>*; ForwardIt = boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>]	64	static
adl.hpp:482:39:) const [with As = {std::allocator<std::complex<double> >&, const std::complex<double>*&, const std::complex<double>*&, boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>}]	112	static
array.hpp:146:2:boost::multi::static_array<T, D, Alloc>::static_array(It, It, const allocator_type&) [with It = const std::complex<double>*; <template-parameter-2-2> = long int; T = std::complex<double>; long int D = 1; Alloc = std::allocator<std::complex<double> >]	176	static
utility.hpp:156:16:num_elements())> boost::multi::num_elements(const A&) [with A = boost::multi::static_array<std::complex<double>, 2, std::allocator<std::complex<double> > >; <template-parameter-1-2> = void]	32	static
adl.hpp:292:39:) const [with As = {const std::complex<double>*&, long int&, std::complex<double>*&}]	80	static
adl.hpp:307:16:constexpr auto boost::multi::xtd::alloc_uninitialized_copy_n(std::allocator<_CharT>&, InputIt, Size, ForwardIt) [with T = std::complex<double>; InputIt = const std::complex<double>*; Size = long int; ForwardIt = std::complex<double>*]	48	static
adl.hpp:486:48:) const [with As = {std::allocator<std::complex<double> >&, const std::complex<double>*&, long int&, std::complex<double>*&}]	96	static
adl.hpp:490:39:) const [with As = {std::allocator<std::complex<double> >&, const std::complex<double>*&, long int&, std::complex<double>*&}]	112	static
array.hpp:39:7:auto boost::multi::array_allocator<Allocator>::uninitialized_copy_n(It, boost::multi::size_type, typename std::allocator_traits<_Alloc>::pointer) [with It = const std::complex<double>*; Allocator = std::allocator<std::complex<double> >]	48	static
array.hpp:82:29:auto boost::multi::static_array<T, D, Alloc>::uninitialized_copy_elements(It) [with It = const std::complex<double>*; T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	48	static
array.hpp:239:2:boost::multi::static_array<T, D, Alloc>::static_array(const boost::multi::static_array<T, D, Alloc>&) [with T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	96	static
array_ref.hpp:93:29:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::element_ptr boost::multi::array_types<T, D, ElementPtr, Layout>::base() const [with T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<2>]	16	static
array.hpp:326:53:constexpr boost::multi::static_array<T, D, Alloc>::element_const_ptr boost::multi::static_array<T, D, Alloc>::base() const [with T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	32	static
core.hpp:573:16:boost::multi::blas::context* boost::multi::blas::default_context_of(const TPtr&) [with TPtr = const std::complex<double>*; typename std::enable_if<std::is_convertible<TPtr, typename std::pointer_traits<_Ptr>::element_type*>{}, int>::type <anonymous> = 0]	16	static
array.hpp:328:50:const std::complex<double>* boost::multi::base(const boost::multi::static_array<std::complex<double>, 2, std::allocator<std::complex<double> > >&)	32	static
core.hpp:547:14:) [with As = {char, char, char, char, long int, long int, std::complex<double>&, const std::complex<double>*, long int, std::complex<double>*, long int}]	192	dynamic,bounded
trsm.hpp:80:6:decltype (boost::multi::blas::trsm(forward<Context>(ctxt), a_side, a_fill, boost::multi::blas::diagonal::general, alpha, a, forward<B2D>(b))) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::array<std::complex<double>, 2>; B2D = boost::multi::array<std::complex<double>, 2>&]	80	static
array_ref.hpp:408:31:constexpr typename boost::multi::basic_array<T, D, ElementPtr, Layout>::types::const_reference boost::multi::basic_array<T, D, ElementPtr, Layout>::operator[](boost::multi::index) const & [with T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<2>]	96	static
array_ref.hpp:1160:47:constexpr typename boost::multi::basic_array<T, 1, ElementPtr, Layout>::reference boost::multi::basic_array<T, 1, ElementPtr, Layout>::operator[](boost::multi::index) && [with T = std::complex<double>; ElementPtr = const std::complex<double>*; Layout = boost::multi::layout_t<1>]	32	static
complex:421:5:std::complex<_Tp> std::operator/(const std::complex<_Tp>&, const std::complex<_Tp>&) [with _Tp = double]	64	static
complex:463:5:constexpr bool std::operator==(const std::complex<_Tp>&, const std::complex<_Tp>&) [with _Tp = double]	48	static
complex:706:5:std::complex<_Tp> std::conj(const std::complex<_Tp>&) [with _Tp = double]	64	static
core.hpp:547:14:) [with As = {char, char, char, char, long int, long int, std::complex<double>, const std::complex<double>*, long int, std::complex<double>*, long int}]	192	dynamic,bounded
trsm.hpp:80:6:decltype (boost::multi::blas::trsm(forward<Context>(ctxt), a_side, a_fill, boost::multi::blas::diagonal::general, alpha, a, forward<B2D>(b))) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::array<std::complex<double>, 2>; B2D = boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >]	80	static
gemm.hpp:317:1:boost::multi::blas::gemm_range<ContextPtr, Scalar, typename A2D::const_iterator, typename B2D::const_iterator, typename A2D::decay_type> boost::multi::blas::gemm(ContextPtr, Scalar, const A2D&, const B2D&) [with ContextPtr = boost::multi::blas::context*; Scalar = double; A2D = boost::multi::array<std::complex<double>, 2>; B2D = boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >; <template-parameter-1-5> = void]	352	dynamic,bounded
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const std::complex<double>&]	16	static
complex.hpp:21:29:) const [with As = {const std::complex<double>&}]	48	static
array_ref.hpp:247:27:constexpr decltype(auto) boost::multi::array_iterator<Element, D, ElementPtr>::operator->() const [with Element = std::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >]	24	static
array.hpp:743:17:boost::multi::array<std::complex<double>, 2>::array(Range&&) [with Range = const boost::multi::blas::gemm_range<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >, boost::multi::array<std::complex<double>, 2> >&; <template-parameter-1-2> = void; <template-parameter-1-3> = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >; <template-parameter-1-4> = void][inherited from boost::multi::static_array<std::complex<double>, 2, std::allocator<std::complex<double> > >]	32	static
gemm.hpp:307:13:boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::decay_type boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::operator+() const [with ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >; DecayType = boost::multi::array<std::complex<double>, 2>]	32	static
array_ref.hpp:409:31:constexpr typename boost::multi::basic_array<T, D, ElementPtr, Layout>::types::reference boost::multi::basic_array<T, D, ElementPtr, Layout>::operator[](boost::multi::index) && [with T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<2>]	64	static
array.hpp:913:7:>&) const [with TT = std::complex<double>; Args = {std::complex<double>*, boost::multi::layout_t<2, long int>}; T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	32	static
fixture.hpp:112:6:void boost::unit_test::setup_conditional(U&) [with U = multi_blas_trsm_real_nonsquare]	48	static
fixture.hpp:118:6:void boost::unit_test::teardown_conditional(U&) [with U = multi_blas_trsm_real_nonsquare]	48	static
array.hpp:913:7:>&) const [with TT = double; Args = {double*, boost::multi::layout_t<2, long int>}; T = double; long int D = 2; Alloc = std::allocator<double>]	32	static
gemm.hpp:317:1:boost::multi::blas::gemm_range<ContextPtr, Scalar, typename A2D::const_iterator, typename B2D::const_iterator, typename A2D::decay_type> boost::multi::blas::gemm(ContextPtr, Scalar, const A2D&, const B2D&) [with ContextPtr = boost::multi::blas::context*; Scalar = double; A2D = boost::multi::array<double, 2>; B2D = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >; <template-parameter-1-5> = void]	336	dynamic,bounded
array_ref.hpp:749:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::begin() & [with T = double; long int D = 2; ElementPtr = double*; Layout = boost::multi::layout_t<2>]	64	dynamic,bounded
array_ref.hpp:186:12:constexpr boost::multi::basic_array_ptr<Ref, Layout>::basic_array_ptr(typename Ref::element_ptr, const Layout&) [with Ref = boost::multi::basic_array<double, 1, const double*, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	48	static
array_ref.hpp:252:12:constexpr boost::multi::array_iterator<Element, D, ElementPtr>::array_iterator(typename boost::multi::basic_array<Element, (D - 1), ElementPtr>::element_ptr, boost::multi::layout_t<(D - 1), long int>, boost::multi::index) [with Element = double; long int D = 2; ElementPtr = const double*]	48	static
adl.hpp:105:39:) const [with As = {boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, double*>}]	224	dynamic,bounded
array.hpp:220:2:>&, const allocator_type&) [with TT = double; Args = {double*, boost::multi::layout_t<2, long int>}; <template-parameter-2-3> = void; <template-parameter-2-4> = boost::multi::array_iterator<double, 2, double*>; T = double; long int D = 2; Alloc = std::allocator<double>]	256	static
core.hpp:573:16:boost::multi::blas::context* boost::multi::blas::default_context_of(const TPtr&) [with TPtr = double*; typename std::enable_if<std::is_convertible<TPtr, typename std::pointer_traits<_Ptr>::element_type*>{}, int>::type <anonymous> = 0]	16	static
core.hpp:547:14:) [with As = {char, char, char, char, long int, long int, double&, double*, long int, double*, long int}]	192	dynamic,bounded
trsm.hpp:80:6:decltype (boost::multi::blas::trsm(forward<Context>(ctxt), a_side, a_fill, boost::multi::blas::diagonal::general, alpha, a, forward<B2D>(b))) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >; B2D = boost::multi::array<double, 2>&]	80	static
trsm.hpp:80:6:decltype (boost::multi::blas::trsm(forward<Context>(ctxt), a_side, a_fill, boost::multi::blas::diagonal::general, alpha, a, forward<B2D>(b))) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >; B2D = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >]	80	static
wrap_stringstream.hpp:64:1:boost::basic_wrap_stringstream<CharT>& boost::operator<<(boost::basic_wrap_stringstream<CharT>&, const T&) [with CharT = char; T = char [82]]	32	static
fixture.hpp:112:6:void boost::unit_test::setup_conditional(U&) [with U = multi_blas_trsm_complex_nonsquare_default_diagonal_hermitized_gemm_check_no_const]	48	static
fixture.hpp:118:6:void boost::unit_test::teardown_conditional(U&) [with U = multi_blas_trsm_complex_nonsquare_default_diagonal_hermitized_gemm_check_no_const]	48	static
wrap_stringstream.hpp:64:1:boost::basic_wrap_stringstream<CharT>& boost::operator<<(boost::basic_wrap_stringstream<CharT>&, const T&) [with CharT = char; T = char [73]]	32	static
fixture.hpp:112:6:void boost::unit_test::setup_conditional(U&) [with U = multi_blas_trsm_complex_nonsquare_default_diagonal_hermitized_gemm_check]	48	static
fixture.hpp:118:6:void boost::unit_test::teardown_conditional(U&) [with U = multi_blas_trsm_complex_nonsquare_default_diagonal_hermitized_gemm_check]	48	static
array_ref.hpp:399:20:boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >::decay_type boost::multi::operator+(const boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >&)	48	static
fixture.hpp:112:6:void boost::unit_test::setup_conditional(U&) [with U = multi_blas_trsm_real_1x1_check]	48	static
fixture.hpp:118:6:void boost::unit_test::teardown_conditional(U&) [with U = multi_blas_trsm_real_1x1_check]	48	static
wrap_stringstream.hpp:64:1:boost::basic_wrap_stringstream<CharT>& boost::operator<<(boost::basic_wrap_stringstream<CharT>&, const T&) [with CharT = char; T = char [34]]	32	static
fixture.hpp:112:6:void boost::unit_test::setup_conditional(U&) [with U = multi_blas_trsm_complex_1x1_check]	48	static
fixture.hpp:118:6:void boost::unit_test::teardown_conditional(U&) [with U = multi_blas_trsm_complex_1x1_check]	48	static
array_ref.hpp:399:20:boost::multi::basic_array<std::complex<double>, 2, std::complex<double>*, boost::multi::layout_t<2> >::decay_type boost::multi::operator+(const boost::multi::basic_array<std::complex<double>, 2, std::complex<double>*, boost::multi::layout_t<2> >&)	48	static
gemm.hpp:317:1:boost::multi::blas::gemm_range<ContextPtr, Scalar, typename A2D::const_iterator, typename B2D::const_iterator, typename A2D::decay_type> boost::multi::blas::gemm(ContextPtr, Scalar, const A2D&, const B2D&) [with ContextPtr = boost::multi::blas::context*; Scalar = double; A2D = boost::multi::array<std::complex<double>, 2>; B2D = boost::multi::array<std::complex<double>, 2>; <template-parameter-1-5> = void]	336	dynamic,bounded
array_ref.hpp:247:27:constexpr decltype(auto) boost::multi::array_iterator<Element, D, ElementPtr>::operator->() const [with Element = std::complex<double>; long int D = 2; ElementPtr = const std::complex<double>*]	16	static
array.hpp:743:17:boost::multi::array<std::complex<double>, 2>::array(Range&&) [with Range = const boost::multi::blas::gemm_range<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array<std::complex<double>, 2> >&; <template-parameter-1-2> = void; <template-parameter-1-3> = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >; <template-parameter-1-4> = void][inherited from boost::multi::static_array<std::complex<double>, 2, std::allocator<std::complex<double> > >]	32	static
gemm.hpp:307:13:boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::decay_type boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::operator+() const [with ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; DecayType = boost::multi::array<std::complex<double>, 2>]	32	static
complex:391:5:std::complex<_Tp> std::operator*(const std::complex<_Tp>&, const std::complex<_Tp>&) [with _Tp = double]	64	static
complex:439:5:std::complex<_Tp> std::operator/(const _Tp&, const std::complex<_Tp>&) [with _Tp = double]	64	static
gemm.hpp:317:1:boost::multi::blas::gemm_range<ContextPtr, Scalar, typename A2D::const_iterator, typename B2D::const_iterator, typename A2D::decay_type> boost::multi::blas::gemm(ContextPtr, Scalar, const A2D&, const B2D&) [with ContextPtr = boost::multi::blas::context*; Scalar = std::complex<double>; A2D = boost::multi::array<std::complex<double>, 2>; B2D = boost::multi::array<std::complex<double>, 2>; <template-parameter-1-5> = void]	336	dynamic,bounded
array.hpp:743:17:boost::multi::array<std::complex<double>, 2>::array(Range&&) [with Range = const boost::multi::blas::gemm_range<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array<std::complex<double>, 2> >&; <template-parameter-1-2> = void; <template-parameter-1-3> = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >; <template-parameter-1-4> = void][inherited from boost::multi::static_array<std::complex<double>, 2, std::allocator<std::complex<double> > >]	32	static
gemm.hpp:307:13:boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::decay_type boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::operator+() const [with ContextPtr = boost::multi::blas::context*; Scalar = std::complex<double>; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; DecayType = boost::multi::array<std::complex<double>, 2>]	32	static
complex.h:402:5:T thrust::complex<T>::real() const [with T = double]	16	static
complex.h:407:5:T thrust::complex<T>::imag() const [with T = double]	16	static
complex.inl:55:1:thrust::complex<T>::complex(const T&, const T&) [with T = double]	16	static
wrap_stringstream.hpp:64:1:boost::basic_wrap_stringstream<CharT>& boost::operator<<(boost::basic_wrap_stringstream<CharT>&, const T&) [with CharT = char; T = char [80]]	32	static
fixture.hpp:112:6:void boost::unit_test::setup_conditional(U&) [with U = multi_blas_trsm_complex_thrust_nonsquare_default_diagonal_hermitized_gemm_check]	48	static
fixture.hpp:118:6:void boost::unit_test::teardown_conditional(U&) [with U = multi_blas_trsm_complex_thrust_nonsquare_default_diagonal_hermitized_gemm_check]	48	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>]	16	static
arithmetic.h:106:1:thrust::complex<typename thrust::detail::promoted_numerical_type<T0, T1>::type> thrust::operator*(const T0&, const thrust::complex<T1>&) [with T0 = double; T1 = double]	112	static
arithmetic.h:49:1:thrust::complex<typename thrust::detail::promoted_numerical_type<T0, T1>::type> thrust::operator+(const T0&, const thrust::complex<T1>&) [with T0 = double; T1 = double]	112	static
arithmetic.h:77:1:thrust::complex<typename thrust::detail::promoted_numerical_type<T0, T1>::type> thrust::operator-(const T0&, const thrust::complex<T1>&) [with T0 = double; T1 = double]	112	static
complex.inl:39:1:thrust::complex<T>::complex(const T&) [with T = double]	16	static
array.hpp:247:12:constexpr boost::multi::static_array<T, D, Alloc>::static_array(std::initializer_list<typename std::conditional<(boost::multi::static_array<T, D, Alloc>::dimensionality > 1), boost::multi::array<typename boost::multi::static_array<T, D, Alloc>::element, (boost::multi::static_array<T, D, Alloc>::dimensionality - 1), typename boost::multi::static_array<T, D, Alloc>::allocator_type>, typename std::conditional<(boost::multi::static_array<T, D, Alloc>::dimensionality == 1), typename boost::multi::static_array<T, D, Alloc>::element, typename boost::multi::static_array<T, D, Alloc>::element>::type>::type>) [with T = thrust::complex<double>; long int D = 1; Alloc = std::allocator<thrust::complex<double> >]	80	static
array.hpp:25:34:boost::multi::array_allocator<std::allocator<thrust::complex<double> > >::~array_allocator()	32	static
array.hpp:278:2:boost::multi::static_array<T, D, Alloc>::~static_array() [with T = thrust::complex<double>; long int D = 1; Alloc = std::allocator<thrust::complex<double> >]	32	static
array.hpp:247:12:constexpr boost::multi::static_array<T, D, Alloc>::static_array(std::initializer_list<typename std::conditional<(boost::multi::static_array<T, D, Alloc>::dimensionality > 1), boost::multi::array<typename boost::multi::static_array<T, D, Alloc>::element, (boost::multi::static_array<T, D, Alloc>::dimensionality - 1), typename boost::multi::static_array<T, D, Alloc>::allocator_type>, typename std::conditional<(boost::multi::static_array<T, D, Alloc>::dimensionality == 1), typename boost::multi::static_array<T, D, Alloc>::element, typename boost::multi::static_array<T, D, Alloc>::element>::type>::type>) [with T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	80	static
array.hpp:278:2:boost::multi::static_array<T, D, Alloc>::~static_array() [with T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	32	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::array<thrust::complex<double>, 2>&]	16	static
numeric.hpp:139:21:constexpr boost::multi::blas::involuter<It, F, Reference>::involuter(It, F) [with It = thrust::complex<double>*; F = boost::multi::blas::conjugate; Reference = boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate>]	48	static
array_ref.hpp:858:35:constexpr boost::multi::basic_array<T2, D, P2> boost::multi::basic_array<T, D, ElementPtr, Layout>::static_array_cast() const [with T2 = thrust::complex<double>; P2 = boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >; T = thrust::complex<double>; long int D = 2; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<2>]	112	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = thrust::complex<double>&]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::basic_array<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >]	16	static
array_ref.hpp:586:37:constexpr boost::multi::basic_array<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> > boost::multi::rotated(boost::multi::basic_array<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >&&)	48	static
array_ref.hpp:93:29:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::element_ptr boost::multi::array_types<T, D, ElementPtr, Layout>::base() const [with T = thrust::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<2>]	16	static
numeric.hpp:161:35:constexpr thrust::complex<double>* boost::multi::blas::underlying(const boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >&)	16	static
core.hpp:573:16:boost::multi::blas::context* boost::multi::blas::default_context_of(const TPtr&) [with TPtr = thrust::complex<double>*; typename std::enable_if<std::is_convertible<TPtr, typename std::pointer_traits<_Ptr>::element_type*>{}, int>::type <anonymous> = 0]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array<thrust::complex<double>, 2>&]	16	static
array_ref.hpp:345:24:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::layout_type boost::multi::basic_array<T, D, ElementPtr, Layout>::layout() const [with T = thrust::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<2>]	48	static
array_ref.hpp:109:12:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::array_types(const layout_t&, const element_ptr&) [with T = thrust::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<2>]	24	static
array_ref.hpp:345:24:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::layout_type boost::multi::basic_array<T, D, ElementPtr, Layout>::layout() const [with T = thrust::complex<double>; long int D = 2; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<2>]	48	static
array_ref.hpp:109:12:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::array_types(const layout_t&, const element_ptr&) [with T = thrust::complex<double>; long int D = 2; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<2>]	24	static
array_ref.hpp:95:31:constexpr boost::multi::array_types<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >::element_ptr boost::multi::base(const boost::multi::array_types<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >&)	32	static
array.hpp:327:50:thrust::complex<double>* boost::multi::base(boost::multi::static_array<thrust::complex<double>, 2, std::allocator<thrust::complex<double> > >&)	32	static
core.hpp:547:14:) [with As = {char, char, char, char, long int, long int, thrust::complex<double>&, thrust::complex<double>*, long int, thrust::complex<double>*, long int}]	192	dynamic,bounded
trsm.hpp:80:6:decltype (boost::multi::blas::trsm(forward<Context>(ctxt), a_side, a_fill, boost::multi::blas::diagonal::general, alpha, a, forward<B2D>(b))) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::basic_array<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >; B2D = boost::multi::array<thrust::complex<double>, 2>&]	80	static
utility.hpp:156:16:num_elements())> boost::multi::num_elements(const A&) [with A = boost::multi::static_array<thrust::complex<double>, 2, std::allocator<thrust::complex<double> > >; <template-parameter-1-2> = void]	32	static
adl.hpp:292:39:) const [with As = {const thrust::complex<double>*&, long int&, thrust::complex<double>*&}]	80	static
adl.hpp:307:16:constexpr auto boost::multi::xtd::alloc_uninitialized_copy_n(std::allocator<_CharT>&, InputIt, Size, ForwardIt) [with T = thrust::complex<double>; InputIt = const thrust::complex<double>*; Size = long int; ForwardIt = thrust::complex<double>*]	48	static
adl.hpp:486:48:) const [with As = {std::allocator<thrust::complex<double> >&, const thrust::complex<double>*&, long int&, thrust::complex<double>*&}]	96	static
adl.hpp:490:39:) const [with As = {std::allocator<thrust::complex<double> >&, const thrust::complex<double>*&, long int&, thrust::complex<double>*&}]	112	static
array.hpp:39:7:auto boost::multi::array_allocator<Allocator>::uninitialized_copy_n(It, boost::multi::size_type, typename std::allocator_traits<_Alloc>::pointer) [with It = const thrust::complex<double>*; Allocator = std::allocator<thrust::complex<double> >]	48	static
array.hpp:82:29:auto boost::multi::static_array<T, D, Alloc>::uninitialized_copy_elements(It) [with It = const thrust::complex<double>*; T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	48	static
array.hpp:239:2:boost::multi::static_array<T, D, Alloc>::static_array(const boost::multi::static_array<T, D, Alloc>&) [with T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	96	static
array_ref.hpp:1077:15:constexpr boost::multi::basic_array<thrust::complex<double>, 1, thrust::complex<double>*, boost::multi::layout_t<1> >::basic_array(const layout_t&, thrust::complex<double>* const&) [inherited from boost::multi::array_types<thrust::complex<double>, 1, thrust::complex<double>*, boost::multi::layout_t<1> >]	48	static
array_ref.hpp:404:20:constexpr auto boost::multi::basic_array<T, D, ElementPtr, Layout>::at_(boost::multi::index) const [with T = thrust::complex<double>; long int D = 2; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<2>]	144	static
array_ref.hpp:410:31:constexpr typename boost::multi::basic_array<T, D, ElementPtr, Layout>::types::reference boost::multi::basic_array<T, D, ElementPtr, Layout>::operator[](boost::multi::index) & [with T = thrust::complex<double>; long int D = 2; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<2>]	64	static
array_ref.hpp:1160:47:constexpr typename boost::multi::basic_array<T, 1, ElementPtr, Layout>::reference boost::multi::basic_array<T, 1, ElementPtr, Layout>::operator[](boost::multi::index) && [with T = thrust::complex<double>; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<1>]	32	static
array.hpp:913:7:>&) const [with TT = thrust::complex<double>; Args = {thrust::complex<double>*, boost::multi::layout_t<2, long int>}; T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	32	static
array_ref.hpp:93:29:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::element_ptr boost::multi::array_types<T, D, ElementPtr, Layout>::base() const [with T = thrust::complex<double>; long int D = 2; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<2>]	16	static
array.hpp:326:53:constexpr boost::multi::static_array<T, D, Alloc>::element_const_ptr boost::multi::static_array<T, D, Alloc>::base() const [with T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	32	static
core.hpp:573:16:boost::multi::blas::context* boost::multi::blas::default_context_of(const TPtr&) [with TPtr = const thrust::complex<double>*; typename std::enable_if<std::is_convertible<TPtr, typename std::pointer_traits<_Ptr>::element_type*>{}, int>::type <anonymous> = 0]	16	static
arithmetic.h:234:12:thrust::complex<T> thrust::conj(const thrust::complex<T>&) [with T = double]	96	static
array.hpp:328:50:const thrust::complex<double>* boost::multi::base(const boost::multi::static_array<thrust::complex<double>, 2, std::allocator<thrust::complex<double> > >&)	32	static
core.hpp:547:14:) [with As = {char, char, char, char, long int, long int, thrust::complex<double>, const thrust::complex<double>*, long int, thrust::complex<double>*, long int}]	192	dynamic,bounded
trsm.hpp:80:6:decltype (boost::multi::blas::trsm(forward<Context>(ctxt), a_side, a_fill, boost::multi::blas::diagonal::general, alpha, a, forward<B2D>(b))) boost::multi::blas::trsm(Context&&, boost::multi::blas::side, boost::multi::blas::filling, typename A2D::element_type, const A2D&, B2D&&) [with Context = boost::multi::blas::context*; A2D = boost::multi::array<thrust::complex<double>, 2>; B2D = boost::multi::basic_array<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >]	80	static
array_ref.hpp:399:20:boost::multi::basic_array<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >::decay_type boost::multi::operator+(const boost::multi::basic_array<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >&)	48	static
array.hpp:913:7:>&) const [with TT = thrust::complex<double>; Args = {boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2, long int>}; T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	32	static
basic_string.h:625:9:std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(_InputIterator, _InputIterator, const _Alloc&) [with _InputIterator = char*; <template-parameter-2-2> = void; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]	64	static
basic_string.h:263:9:void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator) [with _InIterator = const char*; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]	48	static
move.h:99:5:constexpr typename std::remove_reference<_Tp>::type&& std::move(_Tp&&) [with _Tp = std::__cxx11::basic_string<char>&]	16	static
basic_cstring.hpp:178:1:static boost::unit_test::basic_cstring<CharT>::value_type* boost::unit_test::basic_cstring<CharT>::null_str() [with CharT = const char]	16	static
class_properties.hpp:54:21:boost::unit_test::class_property<PropertyType>::class_property(boost::unit_test::class_property<PropertyType>::write_param_t) [with PropertyType = bool]	16	static
shared_ptr.hpp:377:14:boost::shared_ptr<T>::shared_ptr(Y*) [with Y = boost::basic_wrap_stringstream<char>; T = boost::basic_wrap_stringstream<char>]	48	static
shared_ptr.hpp:764:10:void boost::shared_ptr<T>::swap(boost::shared_ptr<T>&) [with T = boost::basic_wrap_stringstream<char>]	32	static
function_template.hpp:868:10:void boost::function0<R>::clear() [with R = void]	32	static
function_template.hpp:677:18:boost::function0<R>::vtable_type* boost::function0<R>::get_vtable() const [with R = void]	16	static
bcs_char_traits.hpp:82:24:static std::size_t boost::unit_test::ut_detail::bcs_char_traits_impl<CharT>::length(boost::unit_test::ut_detail::bcs_char_traits_impl<CharT>::const_char*) [with CharT = const char]	48	static
basic_cstring.hpp:330:1:boost::unit_test::basic_cstring<CharT>::self_type& boost::unit_test::basic_cstring<CharT>::trim_left(boost::unit_test::basic_cstring<CharT>) [with CharT = const char]	96	static
basic_cstring.hpp:374:1:boost::unit_test::basic_cstring<CharT>::self_type& boost::unit_test::basic_cstring<CharT>::trim_right(boost::unit_test::basic_cstring<CharT>) [with CharT = const char]	96	static
tuple:343:17:constexpr std::_Tuple_impl<_Idx, _Head>::_Tuple_impl(const _Head&) [with long unsigned int _Idx = 0; _Head = boost::multi::extension_t<long int>]	32	static
tuple:1314:5:>&) [with long unsigned int __i = 0; _Head = boost::multi::extension_t<long int>; _Tail = {}]	32	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = long int&]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::extension_t<long int>&]	16	static
tuple:1326:5:>&) [with long unsigned int __i = 0; _Elements = {boost::multi::extension_t<long int, long int>, boost::multi::extension_t<long int, long int>}]	32	static
tuple:1326:5:>&) [with long unsigned int __i = 1; _Elements = {boost::multi::extension_t<long int, long int>, boost::multi::extension_t<long int, long int>}]	32	static
tuple:945:19:constexpr std::tuple<_T1, _T2>::tuple(const _T1&, const _T2&) [with _Dummy = void; typename std::enable_if<(std::_TC<std::is_same<_Dummy, void>::value, _T1, _T2>::_ConstructibleTuple<_T1, _T2>() && std::_TC<std::is_same<_Dummy, void>::value, _T1, _T2>::_ImplicitlyConvertibleTuple<_T1, _T2>()), bool>::type <anonymous> = true; _T1 = boost::multi::extension_t<long int>; _T2 = boost::multi::extension_t<long int>]	48	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = std::tuple<boost::multi::extension_t<long int, long int> >]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const std::tuple<boost::multi::extension_t<long int, long int> >&]	16	static
tuple:1572:9:_Is = {0}; _Tp = std::tuple<boost::multi::extension_t<long int, long int> >; _Tpls = {const std::tuple<boost::multi::extension_t<long int, long int> >&}]	80	static
wrap_stringstream.hpp:74:1:boost::basic_wrap_stringstream<CharT>::wrapped_stream& boost::basic_wrap_stringstream<CharT>::stream() [with CharT = char]	16	static
fixture.hpp:98:58:void boost::unit_test::impl_fixture::call_setup<has_setup>::operator()(U&) [with U = multi_blas_trsm_double_0x0; bool has_setup = false]	16	static
fixture.hpp:104:58:void boost::unit_test::impl_fixture::call_teardown<has_teardown>::operator()(U&) [with U = multi_blas_trsm_double_0x0; bool has_teardown = false]	16	static
function_template.hpp:711:5:boost::function0<R>::function0(Functor, typename boost::enable_if_<(! boost::is_integral<Functor>::value), int>::type) [with Functor = void (*)(); R = void]	48	static
fixture.hpp:131:14:boost::unit_test::class_based_fixture<F, Arg>::class_based_fixture(const Arg&) [with F = boost::test_tools::local_fpc_tolerance<double>; Arg = double]	32	static
shared_ptr.hpp:377:14:boost::shared_ptr<T>::shared_ptr(Y*) [with Y = boost::unit_test::class_based_fixture<boost::test_tools::local_fpc_tolerance<double>, double>; T = boost::unit_test::test_unit_fixture]	48	static
stl_algobase.h:465:5:_OI std::copy(_II, _II, _OI) [with _II = boost::multi::array_iterator<double, 1, const double*>; _OI = boost::multi::array_iterator<double, 1, double*>]	96	static
new_allocator.h:80:7:__gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = double]	16	static
new_allocator.h:89:7:__gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = double]	16	static
allocator.h:141:7:std::allocator< <template-parameter-1-1> >::allocator(const std::allocator< <template-parameter-1-1> >&) [with _Tp = double]	32	static
array.hpp:87:7:void boost::multi::static_array<T, D, Alloc>::destroy() [with T = double; long int D = 2; Alloc = std::allocator<double>]	48	static
array.hpp:258:7:void boost::multi::static_array<T, D, Alloc>::deallocate() [with T = double; long int D = 2; Alloc = std::allocator<double>]	48	static
array.hpp:325:53:constexpr typename boost::multi::static_array<T, D, Alloc>::element_ptr boost::multi::static_array<T, D, Alloc>::base() [with T = double; long int D = 2; Alloc = std::allocator<double>]	32	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = char]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = long int]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = double&]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const double*]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = double*]	16	static
core.hpp:501:10:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = double; AAP = const double*; AA = const double; BBP = double*; BB = double; typename std::enable_if<(((((boost::multi::blas::is_d<SX>{} && boost::multi::blas::is_d<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:147)> [with auto:147 = long int]	32	static
core.hpp:501:10:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = double; AAP = const double*; AA = const double; BBP = double*; BB = double; typename std::enable_if<(((((boost::multi::blas::is_d<SX>{} && boost::multi::blas::is_d<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:148)> [with auto:148 = long int]	32	static
core.hpp:501:10:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = double; AAP = const double*; AA = const double; BBP = double*; BB = double; typename std::enable_if<(((((boost::multi::blas::is_d<SX>{} && boost::multi::blas::is_d<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:149)> [with auto:149 = long int]	32	static
core.hpp:501:10:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = double; AAP = const double*; AA = const double; BBP = double*; BB = double; typename std::enable_if<(((((boost::multi::blas::is_d<SX>{} && boost::multi::blas::is_d<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:150)> [with auto:150 = long int]	32	static
core.hpp:501:10:boost::multi::blas::{anonymous}::v boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = double; AAP = const double*; AA = const double; BBP = double*; BB = double; typename std::enable_if<(((((boost::multi::blas::is_d<SX>{} && boost::multi::blas::is_d<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]	400	dynamic,bounded
fixture.hpp:98:58:void boost::unit_test::impl_fixture::call_setup<has_setup>::operator()(U&) [with U = multi_blas_trsm_double_1x1; bool has_setup = false]	16	static
fixture.hpp:104:58:void boost::unit_test::impl_fixture::call_teardown<has_teardown>::operator()(U&) [with U = multi_blas_trsm_double_1x1; bool has_teardown = false]	16	static
array.hpp:87:7:void boost::multi::static_array<T, D, Alloc>::destroy() [with T = double; long int D = 1; Alloc = std::allocator<double>]	48	static
array.hpp:258:7:void boost::multi::static_array<T, D, Alloc>::deallocate() [with T = double; long int D = 1; Alloc = std::allocator<double>]	48	static
initializer_list:71:7:constexpr std::initializer_list<_E>::size_type std::initializer_list<_E>::size() const [with _E = double]	16	static
array.hpp:32:2:typename std::allocator_traits<_Alloc>::pointer boost::multi::array_allocator<Allocator>::allocate(typename std::allocator_traits<_Alloc>::size_type) [with Allocator = std::allocator<double>]	32	static
layout.hpp:240:22:constexpr boost::multi::layout_t<1, SSize>::size_type boost::multi::layout_t<1, SSize>::size() const [with SSize = long int]	16	static
index_range.hpp:130:28:constexpr boost::multi::range<IndexType, IndexTypeLast>::const_reference boost::multi::range<IndexType, IndexTypeLast>::first() const [with IndexType = long int; IndexTypeLast = long int]	16	static
tuple:1309:5:>&) [with long unsigned int __i = 0; _Head = boost::multi::extension_t<long int>; _Tail = {}]	32	static
stl_iterator_base_types.h:205:5:constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = const double*]	16	static
stl_iterator_base_funcs.h:98:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = const double*]	16	static
array_ref.hpp:1426:12:constexpr boost::multi::array_ref<T, D, ElementPtr>::array_ref(typename boost::multi::array_ref<T, D, ElementPtr>::element_ptr, typename boost::multi::array_ref<T, D, ElementPtr>::extensions_type) [with T = double; long int D = 1; ElementPtr = double*]	112	static
array.hpp:29:18:boost::multi::array_allocator<Allocator>::allocator_type& boost::multi::array_allocator<Allocator>::alloc() [with Allocator = std::allocator<double>]	16	static
array_ref.hpp:1266:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::begin() & [with T = double; ElementPtr = double*; Layout = boost::multi::layout_t<1>]	64	static
adl.hpp:249:39:) const [with As = {const double*&, const double*&, boost::multi::array_iterator<double, 1, double*>&}]	80	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = std::allocator<double>&]	16	static
adl.hpp:477:48:) const [with T = std::allocator<double>&; As = {const double*&, const double*&, boost::multi::array_iterator<double, 1, double*>}]	96	static
initializer_list:79:7:constexpr const _E* std::initializer_list<_E>::end() const [with _E = boost::multi::array<double, 1, std::allocator<double> >]	48	static
adl.hpp:401:39:) const [with As = {const boost::multi::array<double, 1, std::allocator<double> >&}]	32	static
adl.hpp:249:39:) const [with As = {boost::multi::array_iterator<double, 1, const double*>, boost::multi::array_iterator<double, 1, const double*>, boost::multi::array_iterator<double, 1, double*>}]	96	dynamic,bounded
array_ref.hpp:285:28:constexpr boost::multi::array_iterator<Element, D, ElementPtr>& boost::multi::array_iterator<Element, D, ElementPtr>::operator++() [with Element = double; long int D = 2; ElementPtr = double*]	16	static
array_ref.hpp:1659:16:constexpr auto boost::multi::uninitialized_copy(In, In, boost::multi::array_iterator<T, N, TP>) [with In = const boost::multi::array<double, 1, std::allocator<double> >*; T = double; long int N = 2; TP = double*; <template-parameter-1-5> = void; <template-parameter-1-6> = boost::multi::array_iterator<double, 1, const double*>]	160	static
adl.hpp:343:16:constexpr auto boost::multi::xtd::alloc_uninitialized_copy(std::allocator<_CharT>&, InputIt, InputIt, ForwardIt) [with T = double; InputIt = const boost::multi::array<double, 1, std::allocator<double> >*; ForwardIt = boost::multi::array_iterator<double, 2, double*>]	64	static
adl.hpp:482:39:) const [with As = {std::allocator<double>&, const boost::multi::array<double, 1, std::allocator<double> >*&, const boost::multi::array<double, 1, std::allocator<double> >*&, boost::multi::array_iterator<double, 2, double*>}]	112	static
array.hpp:146:2:boost::multi::static_array<T, D, Alloc>::static_array(It, It, const allocator_type&) [with It = const boost::multi::array<double, 1, std::allocator<double> >*; <template-parameter-2-2> = long int; T = double; long int D = 2; Alloc = std::allocator<double>]	272	static
array.hpp:47:17:boost::multi::array_allocator<Allocator>::allocator_type boost::multi::array_allocator<Allocator>::get_allocator() const [with Allocator = std::allocator<double>]	32	static
utility.hpp:370:6:extensions()) boost::multi::extensions(const T&) [with T = boost::multi::static_array<double, 2, std::allocator<double> >; <template-parameter-1-2> = void]	48	static
array_ref.hpp:1426:12:constexpr boost::multi::array_ref<T, D, ElementPtr>::array_ref(typename boost::multi::array_ref<T, D, ElementPtr>::element_ptr, typename boost::multi::array_ref<T, D, ElementPtr>::extensions_type) [with T = double; long int D = 2; ElementPtr = double*]	128	static
array.hpp:317:38:boost::multi::static_array<T, D, Alloc>::element_const_ptr boost::multi::static_array<T, D, Alloc>::data_elements() const & [with T = double; long int D = 2; Alloc = std::allocator<double>]	16	static
array.hpp:310:37:typename boost::multi::static_array<T, D, Alloc>::element_ptr boost::multi::static_array<T, D, Alloc>::data() [with T = double; long int D = 2; Alloc = std::allocator<double>]	32	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = double*&]	16	static
adl.hpp:287:48:) const [with As = {const double*&, long int&, double*&}]	64	static
assertion.hpp:264:33:boost::test_tools::assertion::value_expr<T>::value_expr(T&&) [with T = double&]	32	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::test_tools::assertion::value_expr<double&>]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = double]	16	static
assertion.hpp:340:5:boost::test_tools::assertion::binary_expr<Lhs, Rhs, OP>::binary_expr(LExpr&&, Rhs&&) [with LExpr = boost::test_tools::assertion::value_expr<double&>; Rhs = double; OP = boost::test_tools::assertion::op::EQ<double, double, void>]	64	static
assertion.hpp:352:33:boost::test_tools::assertion::binary_expr<Lhs, Rhs, OP>::result_type boost::test_tools::assertion::binary_expr<Lhs, Rhs, OP>::value() const [with LExpr = boost::test_tools::assertion::value_expr<double&>; Rhs = double; OP = boost::test_tools::assertion::op::EQ<double, double, void>]	64	static
shared_ptr.hpp:422:5:boost::shared_ptr<T>::shared_ptr(const boost::shared_ptr<T>&) [with T = boost::basic_wrap_stringstream<char>]	32	static
assertion.hpp:356:33:void boost::test_tools::assertion::binary_expr<Lhs, Rhs, OP>::report(std::ostream&) const [with LExpr = boost::test_tools::assertion::value_expr<double&>; Rhs = double; OP = boost::test_tools::assertion::op::EQ<double, double, void>]	32	static
lazy_ostream.hpp:58:5:boost::unit_test::lazy_ostream_impl<PrevType, T, StorageT>::lazy_ostream_impl(const PrevType&, const T&) [with PrevType = boost::unit_test::lazy_ostream; T = boost::unit_test::basic_cstring<const char>; StorageT = const boost::unit_test::basic_cstring<const char>&]	48	static
range_access.h:58:5:begin()) std::begin(const _Container&) [with _Container = boost::multi::array<double, 2>]	48	static
range_access.h:78:5:end()) std::end(const _Container&) [with _Container = boost::multi::array<double, 2>]	48	static
gemm.hpp:295:2:boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::gemm_range(ContextPtr, Scalar, ItA, ItA, ItB) [with ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<double, 2, const double*>; ItB = boost::multi::array_iterator<double, 2, const double*>; DecayType = boost::multi::array<double, 2>]	24	static
array.hpp:163:2:boost::multi::static_array<T, D, Alloc>::static_array(Range&&) [with Range = const boost::multi::blas::gemm_range<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array<double, 2> >&; <template-parameter-2-2> = void; <template-parameter-2-3> = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >; <template-parameter-2-4> = void; T = double; long int D = 2; Alloc = std::allocator<double>]	464	dynamic,bounded
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const double&]	16	static
assertion.hpp:340:5:boost::test_tools::assertion::binary_expr<Lhs, Rhs, OP>::binary_expr(LExpr&&, Rhs&&) [with LExpr = boost::test_tools::assertion::value_expr<double&>; Rhs = const double&; OP = boost::test_tools::assertion::op::EQ<double, double, void>]	64	static
assertion.hpp:352:33:boost::test_tools::assertion::binary_expr<Lhs, Rhs, OP>::result_type boost::test_tools::assertion::binary_expr<Lhs, Rhs, OP>::value() const [with LExpr = boost::test_tools::assertion::value_expr<double&>; Rhs = const double&; OP = boost::test_tools::assertion::op::EQ<double, double, void>]	64	static
assertion.hpp:356:33:void boost::test_tools::assertion::binary_expr<Lhs, Rhs, OP>::report(std::ostream&) const [with LExpr = boost::test_tools::assertion::value_expr<double&>; Rhs = const double&; OP = boost::test_tools::assertion::op::EQ<double, double, void>]	32	static
array_ref.hpp:93:29:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::element_ptr boost::multi::array_types<T, D, ElementPtr, Layout>::base() const [with T = double; long int D = 1; ElementPtr = const double*; Layout = boost::multi::layout_t<1>]	16	static
fixture.hpp:98:58:void boost::unit_test::impl_fixture::call_setup<has_setup>::operator()(U&) [with U = multi_blas_trsm_real_square; bool has_setup = false]	16	static
fixture.hpp:104:58:void boost::unit_test::impl_fixture::call_teardown<has_teardown>::operator()(U&) [with U = multi_blas_trsm_real_square; bool has_teardown = false]	16	static
array_ref.hpp:394:23:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::decay_type boost::multi::basic_array<T, D, ElementPtr, Layout>::decay() const [with T = double; long int D = 2; ElementPtr = double*; Layout = boost::multi::layout_t<2>]	64	static
move.h:99:5:constexpr typename std::remove_reference<_Tp>::type&& std::move(_Tp&&) [with _Tp = boost::multi::static_array<double, 2, std::allocator<double> >&]	16	static
array_ref.hpp:96:28:constexpr const layout_t& boost::multi::array_types<T, D, ElementPtr, Layout>::layout() const [with T = double; long int D = 2; ElementPtr = const double*; Layout = boost::multi::layout_t<2>]	16	static
array_ref.hpp:761:34:constexpr boost::multi::basic_array<double, 2, const double*, boost::multi::layout_t<2> >::const_iterator boost::multi::begin(const boost::multi::basic_array<double, 2, const double*, boost::multi::layout_t<2> >&)	48	static
array_ref.hpp:762:34:constexpr boost::multi::basic_array<double, 2, const double*, boost::multi::layout_t<2> >::const_iterator boost::multi::end(const boost::multi::basic_array<double, 2, const double*, boost::multi::layout_t<2> >&)	48	static
array_ref.hpp:761:34:constexpr boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >::const_iterator boost::multi::begin(const boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >&)	48	static
fixture.hpp:98:58:void boost::unit_test::impl_fixture::call_setup<has_setup>::operator()(U&) [with U = multi_blas_trsm_complex; bool has_setup = false]	16	static
fixture.hpp:104:58:void boost::unit_test::impl_fixture::call_teardown<has_teardown>::operator()(U&) [with U = multi_blas_trsm_complex; bool has_teardown = false]	16	static
stl_algobase.h:465:5:_OI std::copy(_II, _II, _OI) [with _II = boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>; _OI = boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>]	96	static
complex:456:5:std::complex<_Tp> std::operator-(const std::complex<_Tp>&) [with _Tp = double]	64	static
array.hpp:87:7:void boost::multi::static_array<T, D, Alloc>::destroy() [with T = std::complex<double>; long int D = 1; Alloc = std::allocator<std::complex<double> >]	48	static
array.hpp:258:7:void boost::multi::static_array<T, D, Alloc>::deallocate() [with T = std::complex<double>; long int D = 1; Alloc = std::allocator<std::complex<double> >]	48	static
initializer_list:79:7:constexpr const _E* std::initializer_list<_E>::end() const [with _E = boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >]	48	static
adl.hpp:401:39:) const [with As = {const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >&}]	32	static
adl.hpp:249:39:) const [with As = {boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>}]	80	static
array_ref.hpp:285:28:constexpr boost::multi::array_iterator<Element, D, ElementPtr>& boost::multi::array_iterator<Element, D, ElementPtr>::operator++() [with Element = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*]	16	static
array_ref.hpp:1659:16:constexpr auto boost::multi::uninitialized_copy(In, In, boost::multi::array_iterator<T, N, TP>) [with In = const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >*; T = std::complex<double>; long int N = 2; TP = std::complex<double>*; <template-parameter-1-5> = void; <template-parameter-1-6> = boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>]	160	static
adl.hpp:343:16:constexpr auto boost::multi::xtd::alloc_uninitialized_copy(std::allocator<_CharT>&, InputIt, InputIt, ForwardIt) [with T = std::complex<double>; InputIt = const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >*; ForwardIt = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>]	64	static
adl.hpp:482:39:) const [with As = {std::allocator<std::complex<double> >&, const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >*&, const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >*&, boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>}]	112	static
array.hpp:146:2:boost::multi::static_array<T, D, Alloc>::static_array(It, It, const allocator_type&) [with It = const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >*; <template-parameter-2-2> = long int; T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	272	static
array.hpp:87:7:void boost::multi::static_array<T, D, Alloc>::destroy() [with T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	48	static
array.hpp:258:7:void boost::multi::static_array<T, D, Alloc>::deallocate() [with T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	48	static
move.h:99:5:constexpr typename std::remove_reference<_Tp>::type&& std::move(_Tp&&) [with _Tp = std::complex<double>*&]	16	static
move.h:99:5:constexpr typename std::remove_reference<_Tp>::type&& std::move(_Tp&&) [with _Tp = boost::multi::blas::conjugate&]	16	static
move.h:99:5:constexpr typename std::remove_reference<_Tp>::type&& std::move(_Tp&&) [with _Tp = boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >&]	16	static
array_ref.hpp:576:24:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout> boost::multi::basic_array<T, D, ElementPtr, Layout>::rotated() && [with T = std::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<2>]	112	static
array_ref.hpp:96:28:constexpr const layout_t& boost::multi::array_types<T, D, ElementPtr, Layout>::layout() const [with T = std::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<2>]	16	static
array_ref.hpp:96:28:constexpr const layout_t& boost::multi::array_types<T, D, ElementPtr, Layout>::layout() const [with T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<2>]	16	static
array.hpp:325:53:constexpr typename boost::multi::static_array<T, D, Alloc>::element_ptr boost::multi::static_array<T, D, Alloc>::base() [with T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	32	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = std::complex<double>*]	16	static
core.hpp:501:28:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = std::complex<double>; AAP = std::complex<double>*; AA = std::complex<double>; BBP = std::complex<double>*; BB = std::complex<double>; typename std::enable_if<(((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:155)> [with auto:155 = long int]	32	static
core.hpp:501:28:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = std::complex<double>; AAP = std::complex<double>*; AA = std::complex<double>; BBP = std::complex<double>*; BB = std::complex<double>; typename std::enable_if<(((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:156)> [with auto:156 = long int]	32	static
core.hpp:501:28:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = std::complex<double>; AAP = std::complex<double>*; AA = std::complex<double>; BBP = std::complex<double>*; BB = std::complex<double>; typename std::enable_if<(((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:157)> [with auto:157 = long int]	32	static
core.hpp:501:28:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = std::complex<double>; AAP = std::complex<double>*; AA = std::complex<double>; BBP = std::complex<double>*; BB = std::complex<double>; typename std::enable_if<(((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:158)> [with auto:158 = long int]	32	static
core.hpp:501:28:boost::multi::blas::{anonymous}::v boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = std::complex<double>; AAP = std::complex<double>*; AA = std::complex<double>; BBP = std::complex<double>*; BB = std::complex<double>; typename std::enable_if<(((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]	400	dynamic,bounded
array_ref.hpp:109:12:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::array_types(const layout_t&, const element_ptr&) [with T = std::complex<double>; long int D = 1; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<1>]	16	static
array_ref.hpp:1157:53:constexpr typename boost::multi::basic_array<T, 1, ElementPtr, Layout>::reference boost::multi::basic_array<T, 1, ElementPtr, Layout>::operator[](boost::multi::index) & [with T = std::complex<double>; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<1>]	48	static
assertion.hpp:264:33:boost::test_tools::assertion::value_expr<T>::value_expr(T&&) [with T = double]	32	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::test_tools::assertion::value_expr<double>]	16	static
assertion.hpp:340:5:boost::test_tools::assertion::binary_expr<Lhs, Rhs, OP>::binary_expr(LExpr&&, Rhs&&) [with LExpr = boost::test_tools::assertion::value_expr<double>; Rhs = double; OP = boost::test_tools::assertion::op::EQ<double, double, void>]	64	static
assertion.hpp:352:33:boost::test_tools::assertion::binary_expr<Lhs, Rhs, OP>::result_type boost::test_tools::assertion::binary_expr<Lhs, Rhs, OP>::value() const [with LExpr = boost::test_tools::assertion::value_expr<double>; Rhs = double; OP = boost::test_tools::assertion::op::EQ<double, double, void>]	64	static
assertion.hpp:356:33:void boost::test_tools::assertion::binary_expr<Lhs, Rhs, OP>::report(std::ostream&) const [with LExpr = boost::test_tools::assertion::value_expr<double>; Rhs = double; OP = boost::test_tools::assertion::op::EQ<double, double, void>]	32	static
fixture.hpp:98:58:void boost::unit_test::impl_fixture::call_setup<has_setup>::operator()(U&) [with U = multi_blas_trsm_complex_rectangular; bool has_setup = false]	16	static
fixture.hpp:104:58:void boost::unit_test::impl_fixture::call_teardown<has_teardown>::operator()(U&) [with U = multi_blas_trsm_complex_rectangular; bool has_teardown = false]	16	static
fixture.hpp:98:58:void boost::unit_test::impl_fixture::call_setup<has_setup>::operator()(U&) [with U = multi_blas_trsm_complex_column; bool has_setup = false]	16	static
fixture.hpp:104:58:void boost::unit_test::impl_fixture::call_teardown<has_teardown>::operator()(U&) [with U = multi_blas_trsm_complex_column; bool has_teardown = false]	16	static
fixture.hpp:98:58:void boost::unit_test::impl_fixture::call_setup<has_setup>::operator()(U&) [with U = multi_blas_trsm_complex_column_cpu; bool has_setup = false]	16	static
fixture.hpp:104:58:void boost::unit_test::impl_fixture::call_teardown<has_teardown>::operator()(U&) [with U = multi_blas_trsm_complex_column_cpu; bool has_teardown = false]	16	static
fixture.hpp:98:58:void boost::unit_test::impl_fixture::call_setup<has_setup>::operator()(U&) [with U = multi_blas_trsm_hydrogen_inq_case_real; bool has_setup = false]	16	static
fixture.hpp:104:58:void boost::unit_test::impl_fixture::call_teardown<has_teardown>::operator()(U&) [with U = multi_blas_trsm_hydrogen_inq_case_real; bool has_teardown = false]	16	static
array_ref.hpp:93:29:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::element_ptr boost::multi::array_types<T, D, ElementPtr, Layout>::base() const [with T = double; long int D = 1; ElementPtr = double*; Layout = boost::multi::layout_t<1>]	16	static
array_ref.hpp:109:12:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::array_types(const layout_t&, const element_ptr&) [with T = double; long int D = 1; ElementPtr = const double*; Layout = boost::multi::layout_t<1>]	16	static
fixture.hpp:98:58:void boost::unit_test::impl_fixture::call_setup<has_setup>::operator()(U&) [with U = multi_blas_trsm_hydrogen_inq_case_complex; bool has_setup = false]	16	static
fixture.hpp:104:58:void boost::unit_test::impl_fixture::call_teardown<has_teardown>::operator()(U&) [with U = multi_blas_trsm_hydrogen_inq_case_complex; bool has_teardown = false]	16	static
initializer_list:71:7:constexpr std::initializer_list<_E>::size_type std::initializer_list<_E>::size() const [with _E = std::complex<double>]	16	static
new_allocator.h:80:7:__gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = std::complex<double>]	16	static
new_allocator.h:89:7:__gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = std::complex<double>]	16	static
array.hpp:32:2:typename std::allocator_traits<_Alloc>::pointer boost::multi::array_allocator<Allocator>::allocate(typename std::allocator_traits<_Alloc>::size_type) [with Allocator = std::allocator<std::complex<double> >]	32	static
stl_iterator_base_types.h:205:5:constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = const std::complex<double>*]	16	static
stl_iterator_base_funcs.h:98:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = const std::complex<double>*]	16	static
array.hpp:30:2:boost::multi::array_allocator<Allocator>::array_allocator(const allocator_type&) [with Allocator = std::allocator<std::complex<double> >]	32	static
array_ref.hpp:1426:12:constexpr boost::multi::array_ref<T, D, ElementPtr>::array_ref(typename boost::multi::array_ref<T, D, ElementPtr>::element_ptr, typename boost::multi::array_ref<T, D, ElementPtr>::extensions_type) [with T = std::complex<double>; long int D = 1; ElementPtr = std::complex<double>*]	112	static
array.hpp:29:18:boost::multi::array_allocator<Allocator>::allocator_type& boost::multi::array_allocator<Allocator>::alloc() [with Allocator = std::allocator<std::complex<double> >]	16	static
array_ref.hpp:1266:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::begin() & [with T = std::complex<double>; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<1>]	64	static
adl.hpp:249:39:) const [with As = {const std::complex<double>*&, const std::complex<double>*&, boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>&}]	80	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = std::allocator<std::complex<double> >&]	16	static
adl.hpp:477:48:) const [with T = std::allocator<std::complex<double> >&; As = {const std::complex<double>*&, const std::complex<double>*&, boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>}]	96	static
array.hpp:47:17:boost::multi::array_allocator<Allocator>::allocator_type boost::multi::array_allocator<Allocator>::get_allocator() const [with Allocator = std::allocator<std::complex<double> >]	32	static
utility.hpp:370:6:extensions()) boost::multi::extensions(const T&) [with T = boost::multi::static_array<std::complex<double>, 2, std::allocator<std::complex<double> > >; <template-parameter-1-2> = void]	48	static
array_ref.hpp:1426:12:constexpr boost::multi::array_ref<T, D, ElementPtr>::array_ref(typename boost::multi::array_ref<T, D, ElementPtr>::element_ptr, typename boost::multi::array_ref<T, D, ElementPtr>::extensions_type) [with T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*]	128	static
array.hpp:317:38:boost::multi::static_array<T, D, Alloc>::element_const_ptr boost::multi::static_array<T, D, Alloc>::data_elements() const & [with T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	16	static
array.hpp:310:37:typename boost::multi::static_array<T, D, Alloc>::element_ptr boost::multi::static_array<T, D, Alloc>::data() [with T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	32	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = std::complex<double>*&]	16	static
adl.hpp:288:48:) const [with As = {const std::complex<double>*&, long int&, std::complex<double>*&}]	64	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const std::complex<double>*]	16	static
core.hpp:501:28:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = std::complex<double>; AAP = const std::complex<double>*; AA = const std::complex<double>; BBP = std::complex<double>*; BB = std::complex<double>; typename std::enable_if<(((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:155)> [with auto:155 = long int]	32	static
core.hpp:501:28:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = std::complex<double>; AAP = const std::complex<double>*; AA = const std::complex<double>; BBP = std::complex<double>*; BB = std::complex<double>; typename std::enable_if<(((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:156)> [with auto:156 = long int]	32	static
core.hpp:501:28:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = std::complex<double>; AAP = const std::complex<double>*; AA = const std::complex<double>; BBP = std::complex<double>*; BB = std::complex<double>; typename std::enable_if<(((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:157)> [with auto:157 = long int]	32	static
core.hpp:501:28:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = std::complex<double>; AAP = const std::complex<double>*; AA = const std::complex<double>; BBP = std::complex<double>*; BB = std::complex<double>; typename std::enable_if<(((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:158)> [with auto:158 = long int]	32	static
core.hpp:501:28:boost::multi::blas::{anonymous}::v boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = std::complex<double>; AAP = const std::complex<double>*; AA = const std::complex<double>; BBP = std::complex<double>*; BB = std::complex<double>; typename std::enable_if<(((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]	400	dynamic,bounded
array_ref.hpp:1122:12:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::basic_array(BasicArray&&) [with BasicArray = boost::multi::basic_array<std::complex<double>, 1, std::complex<double>*, boost::multi::layout_t<1> >; <template-parameter-2-2> = void; <template-parameter-2-3> = boost::multi::array_types<std::complex<double>, 1, const std::complex<double>*, boost::multi::layout_t<1> >; T = std::complex<double>; ElementPtr = const std::complex<double>*; Layout = boost::multi::layout_t<1>]	48	static
array_ref.hpp:1157:53:constexpr typename boost::multi::basic_array<T, 1, ElementPtr, Layout>::reference boost::multi::basic_array<T, 1, ElementPtr, Layout>::operator[](boost::multi::index) & [with T = std::complex<double>; ElementPtr = const std::complex<double>*; Layout = boost::multi::layout_t<1>]	48	static
complex:1354:9:std::complex<double>& std::complex<double>::operator/=(const std::complex<_Tp>&) [with _Tp = double]	64	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = std::complex<double>]	16	static
range_access.h:58:5:begin()) std::begin(const _Container&) [with _Container = boost::multi::array<std::complex<double>, 2>]	48	static
range_access.h:78:5:end()) std::end(const _Container&) [with _Container = boost::multi::array<std::complex<double>, 2>]	48	static
array_ref.hpp:761:34:constexpr boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >::const_iterator boost::multi::begin(const boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >&)	48	static
gemm.hpp:295:2:boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::gemm_range(ContextPtr, Scalar, ItA, ItA, ItB) [with ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >; DecayType = boost::multi::array<std::complex<double>, 2>]	24	static
complex.hpp:18:38:) const [with As = {const std::complex<double>&}]	32	static
array.hpp:163:2:boost::multi::static_array<T, D, Alloc>::static_array(Range&&) [with Range = const boost::multi::blas::gemm_range<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >, boost::multi::array<std::complex<double>, 2> >&; <template-parameter-2-2> = void; <template-parameter-2-3> = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >; <template-parameter-2-4> = void; T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	496	dynamic,bounded
index_range.hpp:141:17:constexpr bool boost::multi::range<IndexType, IndexTypeLast>::empty() const [with IndexType = long int; IndexTypeLast = long int]	16	static
index_range.hpp:151:24:constexpr auto boost::multi::operator==(const boost::multi::range<long int, long int>&, const boost::multi::range<long int, long int>&)	32	static
index_range.hpp:223:24:constexpr auto boost::multi::operator==(const boost::multi::extension_t<long int>&, const boost::multi::extension_t<long int>&)	32	static
layout.hpp:401:28:constexpr boost::multi::layout_t<D, SSize>::index_extension boost::multi::layout_t<D, SSize>::extension() const & [with long int D = 2; SSize = long int]	64	static
array.hpp:140:7:>&) const [with TT = std::complex<double>; Args = {std::complex<double>*, boost::multi::layout_t<2, long int>}; T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	32	static
fixture.hpp:98:58:void boost::unit_test::impl_fixture::call_setup<has_setup>::operator()(U&) [with U = multi_blas_trsm_real_nonsquare; bool has_setup = false]	16	static
fixture.hpp:104:58:void boost::unit_test::impl_fixture::call_teardown<has_teardown>::operator()(U&) [with U = multi_blas_trsm_real_nonsquare; bool has_teardown = false]	16	static
array.hpp:140:7:>&) const [with TT = double; Args = {double*, boost::multi::layout_t<2, long int>}; T = double; long int D = 2; Alloc = std::allocator<double>]	32	static
array_ref.hpp:186:12:constexpr boost::multi::basic_array_ptr<Ref, Layout>::basic_array_ptr(typename Ref::element_ptr, const Layout&) [with Ref = boost::multi::basic_array<double, 1, double*, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	48	static
array_ref.hpp:252:12:constexpr boost::multi::array_iterator<Element, D, ElementPtr>::array_iterator(typename boost::multi::basic_array<Element, (D - 1), ElementPtr>::element_ptr, boost::multi::layout_t<(D - 1), long int>, boost::multi::index) [with Element = double; long int D = 2; ElementPtr = double*]	48	static
layout.hpp:412:28:constexpr boost::multi::layout_t<D, SSize>::extensions_type boost::multi::layout_t<D, SSize>::extensions() const [with long int D = 2; SSize = long int]	144	static
types.hpp:83:16:Ns = {0}]	48	static
types.hpp:87:16:constexpr auto boost::multi::detail::tail(const Tuple&) [with Tuple = boost::multi::extensions_t<2>]	48	static
layout.hpp:252:17:constexpr auto boost::multi::layout_t<1, SSize>::stride(boost::multi::dimensionality_type) const [with SSize = long int]	32	static
tuple:1314:5:>&) [with long unsigned int __i = 0; _Head = boost::multi::extension_t<long int>; _Tail = {boost::multi::extension_t<long int, long int>}]	32	static
tuple:198:7:>&) [with long unsigned int _Idx = 0; _Head = boost::multi::extension_t<long int>; _Tail = {boost::multi::extension_t<long int, long int>}]	32	static
tuple:163:7:static constexpr const _Head& std::_Head_base<_Idx, _Head, false>::_M_head(const std::_Head_base<_Idx, _Head, false>&) [with long unsigned int _Idx = 0; _Head = boost::multi::extension_t<long int>]	16	static
layout.hpp:340:12:constexpr boost::multi::layout_t<D, SSize>::layout_t(const extensions_type&) [with long int D = 2; SSize = long int]	96	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::extensions_t<2>&]	16	static
tuple:1314:5:>&) [with long unsigned int __i = 1; _Head = boost::multi::extension_t<long int>; _Tail = {}]	32	static
tuple:337:7:static constexpr const _Head& std::_Tuple_impl<_Idx, _Head>::_M_head(const std::_Tuple_impl<_Idx, _Head>&) [with long unsigned int _Idx = 1; _Head = boost::multi::extension_t<long int>]	32	static
tuple:163:7:static constexpr const _Head& std::_Head_base<_Idx, _Head, false>::_M_head(const std::_Head_base<_Idx, _Head, false>&) [with long unsigned int _Idx = 1; _Head = boost::multi::extension_t<long int>]	16	static
tuple:125:17:constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(const _Head&) [with long unsigned int _Idx = 0; _Head = boost::multi::extension_t<long int>]	16	static
adl.hpp:446:39:) const [with As = {std::allocator<double>&, double*&, long int}]	80	static
array.hpp:78:7:auto boost::multi::static_array<T, D, Alloc>::uninitialized_default_construct() [with T = double; long int D = 2; Alloc = std::allocator<double>]	64	static
array.hpp:210:11:boost::multi::static_array<T, D, Alloc>::static_array(typename boost::multi::static_array<T, D, Alloc>::extensions_type, const allocator_type&) [with T = double; long int D = 2; Alloc = std::allocator<double>]	160	static
array_ref.hpp:760:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::end() const & [with T = double; long int D = 2; ElementPtr = double*; Layout = boost::multi::layout_t<2>]	64	dynamic,bounded
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array_iterator<double, 2, const double*>]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array_iterator<double, 2, double*>]	16	static
adl.hpp:96:48:constexpr decltype (std::copy(first, last, d_first)) boost::multi::adl_copy_fn__::_(boost::multi::priority<1>, InputIt, InputIt, OutputIt) const [with InputIt = boost::multi::array_iterator<double, 2, const double*>; OutputIt = boost::multi::array_iterator<double, 2, double*>; <template-parameter-1-3> = void]	176	dynamic,bounded
core.hpp:501:10:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = double; AAP = double*; AA = double; BBP = double*; BB = double; typename std::enable_if<(((((boost::multi::blas::is_d<SX>{} && boost::multi::blas::is_d<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:147)> [with auto:147 = long int]	32	static
core.hpp:501:10:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = double; AAP = double*; AA = double; BBP = double*; BB = double; typename std::enable_if<(((((boost::multi::blas::is_d<SX>{} && boost::multi::blas::is_d<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:148)> [with auto:148 = long int]	32	static
core.hpp:501:10:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = double; AAP = double*; AA = double; BBP = double*; BB = double; typename std::enable_if<(((((boost::multi::blas::is_d<SX>{} && boost::multi::blas::is_d<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:149)> [with auto:149 = long int]	32	static
core.hpp:501:10:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = double; AAP = double*; AA = double; BBP = double*; BB = double; typename std::enable_if<(((((boost::multi::blas::is_d<SX>{} && boost::multi::blas::is_d<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:150)> [with auto:150 = long int]	32	static
core.hpp:501:10:boost::multi::blas::{anonymous}::v boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = double; AAP = double*; AA = double; BBP = double*; BB = double; typename std::enable_if<(((((boost::multi::blas::is_d<SX>{} && boost::multi::blas::is_d<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]	400	dynamic,bounded
fixture.hpp:98:58:void boost::unit_test::impl_fixture::call_setup<has_setup>::operator()(U&) [with U = multi_blas_trsm_complex_nonsquare_default_diagonal_hermitized_gemm_check_no_const; bool has_setup = false]	16	static
fixture.hpp:104:58:void boost::unit_test::impl_fixture::call_teardown<has_teardown>::operator()(U&) [with U = multi_blas_trsm_complex_nonsquare_default_diagonal_hermitized_gemm_check_no_const; bool has_teardown = false]	16	static
fixture.hpp:98:58:void boost::unit_test::impl_fixture::call_setup<has_setup>::operator()(U&) [with U = multi_blas_trsm_complex_nonsquare_default_diagonal_hermitized_gemm_check; bool has_setup = false]	16	static
fixture.hpp:104:58:void boost::unit_test::impl_fixture::call_teardown<has_teardown>::operator()(U&) [with U = multi_blas_trsm_complex_nonsquare_default_diagonal_hermitized_gemm_check; bool has_teardown = false]	16	static
adl.hpp:105:39:) const [with As = {boost::multi::array_iterator<std::complex<double>, 1, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >, boost::multi::array_iterator<std::complex<double>, 1, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >, boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>}]	80	static
array_ref.hpp:759:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::begin() const & [with T = std::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<2>]	96	dynamic,bounded
array.hpp:743:17:>&, const allocator_type&) [with TT = std::complex<double>; Args = {boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2, long int>}; <template-parameter-1-3> = void; <template-parameter-1-4> = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>][inherited from boost::multi::static_array<std::complex<double>, 2, std::allocator<std::complex<double> > >]	48	static
array_ref.hpp:394:23:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::decay_type boost::multi::basic_array<T, D, ElementPtr, Layout>::decay() const [with T = std::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<2>]	64	static
fixture.hpp:98:58:void boost::unit_test::impl_fixture::call_setup<has_setup>::operator()(U&) [with U = multi_blas_trsm_real_1x1_check; bool has_setup = false]	16	static
fixture.hpp:104:58:void boost::unit_test::impl_fixture::call_teardown<has_teardown>::operator()(U&) [with U = multi_blas_trsm_real_1x1_check; bool has_teardown = false]	16	static
fixture.hpp:98:58:void boost::unit_test::impl_fixture::call_setup<has_setup>::operator()(U&) [with U = multi_blas_trsm_complex_1x1_check; bool has_setup = false]	16	static
fixture.hpp:104:58:void boost::unit_test::impl_fixture::call_teardown<has_teardown>::operator()(U&) [with U = multi_blas_trsm_complex_1x1_check; bool has_teardown = false]	16	static
array_ref.hpp:754:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::begin() && [with T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<2>]	48	static
array_ref.hpp:759:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::begin() const & [with T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<2>]	64	dynamic,bounded
array.hpp:743:17:>&, const allocator_type&) [with TT = std::complex<double>; Args = {std::complex<double>*, boost::multi::layout_t<2, long int>}; <template-parameter-1-3> = void; <template-parameter-1-4> = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>][inherited from boost::multi::static_array<std::complex<double>, 2, std::allocator<std::complex<double> > >]	48	static
array_ref.hpp:394:23:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::decay_type boost::multi::basic_array<T, D, ElementPtr, Layout>::decay() const [with T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<2>]	64	static
gemm.hpp:295:2:boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::gemm_range(ContextPtr, Scalar, ItA, ItA, ItB) [with ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; DecayType = boost::multi::array<std::complex<double>, 2>]	24	static
array.hpp:163:2:boost::multi::static_array<T, D, Alloc>::static_array(Range&&) [with Range = const boost::multi::blas::gemm_range<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array<std::complex<double>, 2> >&; <template-parameter-2-2> = void; <template-parameter-2-3> = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >; <template-parameter-2-4> = void; T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	464	dynamic,bounded
complex:1345:9:std::complex<double>& std::complex<double>::operator*=(const std::complex<_Tp>&) [with _Tp = double]	64	static
gemm.hpp:295:2:boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::gemm_range(ContextPtr, Scalar, ItA, ItA, ItB) [with ContextPtr = boost::multi::blas::context*; Scalar = std::complex<double>; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; DecayType = boost::multi::array<std::complex<double>, 2>]	24	static
array.hpp:163:2:boost::multi::static_array<T, D, Alloc>::static_array(Range&&) [with Range = const boost::multi::blas::gemm_range<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array<std::complex<double>, 2> >&; <template-parameter-2-2> = void; <template-parameter-2-3> = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >; <template-parameter-2-4> = void; T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	496	dynamic,bounded
fixture.hpp:98:58:void boost::unit_test::impl_fixture::call_setup<has_setup>::operator()(U&) [with U = multi_blas_trsm_complex_thrust_nonsquare_default_diagonal_hermitized_gemm_check; bool has_setup = false]	16	static
fixture.hpp:104:58:void boost::unit_test::impl_fixture::call_teardown<has_teardown>::operator()(U&) [with U = multi_blas_trsm_complex_thrust_nonsquare_default_diagonal_hermitized_gemm_check; bool has_teardown = false]	16	static
stl_algobase.h:465:5:_OI std::copy(_II, _II, _OI) [with _II = boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>; _OI = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>]	96	static
initializer_list:79:7:constexpr const _E* std::initializer_list<_E>::end() const [with _E = thrust::complex<double>]	48	static
allocator.h:138:7:std::allocator< <template-parameter-1-1> >::allocator() [with _Tp = thrust::complex<double>]	32	static
allocator.h:153:7:std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = thrust::complex<double>]	32	static
adl.hpp:392:39:) const [with As = {const thrust::complex<double>*&, const thrust::complex<double>*&}]	80	static
utility.hpp:375:64:constexpr boost::multi::layout_t<0>::extensions_type boost::multi::extensions(const T&) [with T = thrust::complex<double>; <template-parameter-1-2> = void]	16	static
adl.hpp:387:48:) const [with As = {const thrust::complex<double>*&, const thrust::complex<double>*&}]	64	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const thrust::complex<double>*&]	16	static
stl_iterator_base_funcs.h:138:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = const thrust::complex<double>*]	32	static
adl.hpp:343:16:constexpr auto boost::multi::xtd::alloc_uninitialized_copy(std::allocator<_CharT>&, InputIt, InputIt, ForwardIt) [with T = thrust::complex<double>; InputIt = const thrust::complex<double>*; ForwardIt = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>]	64	static
adl.hpp:482:39:) const [with As = {std::allocator<thrust::complex<double> >&, const thrust::complex<double>*&, const thrust::complex<double>*&, boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>}]	112	static
array.hpp:146:2:boost::multi::static_array<T, D, Alloc>::static_array(It, It, const allocator_type&) [with It = const thrust::complex<double>*; <template-parameter-2-2> = long int; T = thrust::complex<double>; long int D = 1; Alloc = std::allocator<thrust::complex<double> >]	176	static
array.hpp:87:7:void boost::multi::static_array<T, D, Alloc>::destroy() [with T = thrust::complex<double>; long int D = 1; Alloc = std::allocator<thrust::complex<double> >]	48	static
array.hpp:258:7:void boost::multi::static_array<T, D, Alloc>::deallocate() [with T = thrust::complex<double>; long int D = 1; Alloc = std::allocator<thrust::complex<double> >]	48	static
initializer_list:79:7:constexpr const _E* std::initializer_list<_E>::end() const [with _E = boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >]	48	static
adl.hpp:401:39:) const [with As = {const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >&}]	32	static
adl.hpp:249:39:) const [with As = {boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>, boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>, boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>}]	96	dynamic,bounded
array_ref.hpp:285:28:constexpr boost::multi::array_iterator<Element, D, ElementPtr>& boost::multi::array_iterator<Element, D, ElementPtr>::operator++() [with Element = thrust::complex<double>; long int D = 2; ElementPtr = thrust::complex<double>*]	16	static
array_ref.hpp:1659:16:constexpr auto boost::multi::uninitialized_copy(In, In, boost::multi::array_iterator<T, N, TP>) [with In = const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >*; T = thrust::complex<double>; long int N = 2; TP = thrust::complex<double>*; <template-parameter-1-5> = void; <template-parameter-1-6> = boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>]	160	static
adl.hpp:343:16:constexpr auto boost::multi::xtd::alloc_uninitialized_copy(std::allocator<_CharT>&, InputIt, InputIt, ForwardIt) [with T = thrust::complex<double>; InputIt = const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >*; ForwardIt = boost::multi::array_iterator<thrust::complex<double>, 2, thrust::complex<double>*>]	64	static
adl.hpp:482:39:) const [with As = {std::allocator<thrust::complex<double> >&, const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >*&, const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >*&, boost::multi::array_iterator<thrust::complex<double>, 2, thrust::complex<double>*>}]	112	static
array.hpp:146:2:boost::multi::static_array<T, D, Alloc>::static_array(It, It, const allocator_type&) [with It = const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >*; <template-parameter-2-2> = long int; T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	272	static
array.hpp:87:7:void boost::multi::static_array<T, D, Alloc>::destroy() [with T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	48	static
array.hpp:258:7:void boost::multi::static_array<T, D, Alloc>::deallocate() [with T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	48	static
move.h:99:5:constexpr typename std::remove_reference<_Tp>::type&& std::move(_Tp&&) [with _Tp = thrust::complex<double>*&]	16	static
move.h:99:5:constexpr typename std::remove_reference<_Tp>::type&& std::move(_Tp&&) [with _Tp = boost::multi::basic_array<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >&]	16	static
array_ref.hpp:576:24:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout> boost::multi::basic_array<T, D, ElementPtr, Layout>::rotated() && [with T = thrust::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<2>]	112	static
array_ref.hpp:96:28:constexpr const layout_t& boost::multi::array_types<T, D, ElementPtr, Layout>::layout() const [with T = thrust::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<2>]	16	static
array_ref.hpp:96:28:constexpr const layout_t& boost::multi::array_types<T, D, ElementPtr, Layout>::layout() const [with T = thrust::complex<double>; long int D = 2; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<2>]	16	static
array.hpp:325:53:constexpr typename boost::multi::static_array<T, D, Alloc>::element_ptr boost::multi::static_array<T, D, Alloc>::base() [with T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	32	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = thrust::complex<double>*]	16	static
core.hpp:501:28:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = thrust::complex<double>; AAP = thrust::complex<double>*; AA = thrust::complex<double>; BBP = thrust::complex<double>*; BB = thrust::complex<double>; typename std::enable_if<(((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:155)> [with auto:155 = long int]	32	static
core.hpp:501:28:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = thrust::complex<double>; AAP = thrust::complex<double>*; AA = thrust::complex<double>; BBP = thrust::complex<double>*; BB = thrust::complex<double>; typename std::enable_if<(((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:156)> [with auto:156 = long int]	32	static
core.hpp:501:28:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = thrust::complex<double>; AAP = thrust::complex<double>*; AA = thrust::complex<double>; BBP = thrust::complex<double>*; BB = thrust::complex<double>; typename std::enable_if<(((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:157)> [with auto:157 = long int]	32	static
core.hpp:501:28:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = thrust::complex<double>; AAP = thrust::complex<double>*; AA = thrust::complex<double>; BBP = thrust::complex<double>*; BB = thrust::complex<double>; typename std::enable_if<(((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:158)> [with auto:158 = long int]	32	static
core.hpp:501:28:boost::multi::blas::{anonymous}::v boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = thrust::complex<double>; AAP = thrust::complex<double>*; AA = thrust::complex<double>; BBP = thrust::complex<double>*; BB = thrust::complex<double>; typename std::enable_if<(((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]	416	dynamic,bounded
array.hpp:47:17:boost::multi::array_allocator<Allocator>::allocator_type boost::multi::array_allocator<Allocator>::get_allocator() const [with Allocator = std::allocator<thrust::complex<double> >]	32	static
array.hpp:32:2:typename std::allocator_traits<_Alloc>::pointer boost::multi::array_allocator<Allocator>::allocate(typename std::allocator_traits<_Alloc>::size_type) [with Allocator = std::allocator<thrust::complex<double> >]	32	static
utility.hpp:370:6:extensions()) boost::multi::extensions(const T&) [with T = boost::multi::static_array<thrust::complex<double>, 2, std::allocator<thrust::complex<double> > >; <template-parameter-1-2> = void]	48	static
array.hpp:30:2:boost::multi::array_allocator<Allocator>::array_allocator(const allocator_type&) [with Allocator = std::allocator<thrust::complex<double> >]	32	static
array_ref.hpp:1426:12:constexpr boost::multi::array_ref<T, D, ElementPtr>::array_ref(typename boost::multi::array_ref<T, D, ElementPtr>::element_ptr, typename boost::multi::array_ref<T, D, ElementPtr>::extensions_type) [with T = thrust::complex<double>; long int D = 2; ElementPtr = thrust::complex<double>*]	128	static
array.hpp:317:38:boost::multi::static_array<T, D, Alloc>::element_const_ptr boost::multi::static_array<T, D, Alloc>::data_elements() const & [with T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	16	static
array.hpp:310:37:typename boost::multi::static_array<T, D, Alloc>::element_ptr boost::multi::static_array<T, D, Alloc>::data() [with T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	32	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = std::allocator<thrust::complex<double> >&]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = thrust::complex<double>*&]	16	static
adl.hpp:287:48:) const [with As = {const thrust::complex<double>*&, long int&, thrust::complex<double>*&}]	64	static
array_ref.hpp:109:12:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::array_types(const layout_t&, const element_ptr&) [with T = thrust::complex<double>; long int D = 1; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<1>]	16	static
array_ref.hpp:1157:53:constexpr typename boost::multi::basic_array<T, 1, ElementPtr, Layout>::reference boost::multi::basic_array<T, 1, ElementPtr, Layout>::operator[](boost::multi::index) & [with T = thrust::complex<double>; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<1>]	48	static
array.hpp:140:7:>&) const [with TT = thrust::complex<double>; Args = {thrust::complex<double>*, boost::multi::layout_t<2, long int>}; T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	32	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = thrust::complex<double>]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const thrust::complex<double>*]	16	static
core.hpp:501:28:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = thrust::complex<double>; AAP = const thrust::complex<double>*; AA = const thrust::complex<double>; BBP = thrust::complex<double>*; BB = thrust::complex<double>; typename std::enable_if<(((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:155)> [with auto:155 = long int]	32	static
core.hpp:501:28:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = thrust::complex<double>; AAP = const thrust::complex<double>*; AA = const thrust::complex<double>; BBP = thrust::complex<double>*; BB = thrust::complex<double>; typename std::enable_if<(((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:156)> [with auto:156 = long int]	32	static
core.hpp:501:28:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = thrust::complex<double>; AAP = const thrust::complex<double>*; AA = const thrust::complex<double>; BBP = thrust::complex<double>*; BB = thrust::complex<double>; typename std::enable_if<(((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:157)> [with auto:157 = long int]	32	static
core.hpp:501:28:boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = thrust::complex<double>; AAP = const thrust::complex<double>*; AA = const thrust::complex<double>; BBP = thrust::complex<double>*; BB = thrust::complex<double>; typename std::enable_if<(((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]::<lambda(auto:158)> [with auto:158 = long int]	32	static
core.hpp:501:28:boost::multi::blas::{anonymous}::v boost::multi::blas::core::trsm(char, char, char, char, ssize_t, ssize_t, ALPHA, AAP, ssize_t, BBP, ssize_t) [with ALPHA = thrust::complex<double>; AAP = const thrust::complex<double>*; AA = const thrust::complex<double>; BBP = thrust::complex<double>*; BB = thrust::complex<double>; typename std::enable_if<(((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && std::is_assignable<BB&, decltype (((AA{} * BB{}) / ALPHA{}))>{}) && std::is_assignable<BB&, decltype (((ALPHA{} * BB{}) / AA{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>), int>::type <anonymous> = 0]	416	dynamic,bounded
numeric.hpp:187:17:decltype(auto) boost::multi::blas::conjugate::operator()(T&&) const [with T = const thrust::complex<double>&]	48	static
adl.hpp:105:39:) const [with As = {boost::multi::array_iterator<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >, boost::multi::array_iterator<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >, boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>}]	128	dynamic,bounded
array_ref.hpp:759:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::begin() const & [with T = thrust::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<2>]	96	dynamic,bounded
array.hpp:743:17:>&, const allocator_type&) [with TT = thrust::complex<double>; Args = {boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2, long int>}; <template-parameter-1-3> = void; <template-parameter-1-4> = boost::multi::array_iterator<thrust::complex<double>, 2, thrust::complex<double>*>][inherited from boost::multi::static_array<thrust::complex<double>, 2, std::allocator<thrust::complex<double> > >]	48	static
array_ref.hpp:394:23:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::decay_type boost::multi::basic_array<T, D, ElementPtr, Layout>::decay() const [with T = thrust::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<2>]	64	static
array.hpp:140:7:>&) const [with TT = thrust::complex<double>; Args = {boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2, long int>}; T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	32	static
basic_string.h:263:9:void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator) [with _InIterator = char*; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]	48	static
basic_string.h:243:9:void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct_aux(_InIterator, _InIterator, std::__false_type) [with _InIterator = const char*; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]	64	static
shared_ptr.hpp:283:42:void boost::detail::sp_pointer_construct(boost::shared_ptr<X>*, Y*, boost::detail::shared_count&) [with T = boost::basic_wrap_stringstream<char>; Y = boost::basic_wrap_stringstream<char>]	64	static
move.h:99:5:constexpr typename std::remove_reference<_Tp>::type&& std::move(_Tp&&) [with _Tp = boost::basic_wrap_stringstream<char>*&]	16	static
move.h:182:5:typename std::enable_if<std::__and_<std::__not_<std::__is_tuple_like<_Tp> >, std::is_move_constructible<_Tp>, std::is_move_assignable<_Tp> >::value>::type std::swap(_Tp&, _Tp&) [with _Tp = boost::basic_wrap_stringstream<char>*]	48	static
function_template.hpp:502:14:void boost::detail::function::basic_vtable0<R>::clear(boost::detail::function::function_buffer&) const [with R = void]	32	static
bcs_char_traits.hpp:60:17:static bool boost::unit_test::ut_detail::bcs_char_traits_impl<CharT>::eq(CharT, CharT) [with CharT = const char]	16	static
basic_cstring.hpp:267:1:bool boost::unit_test::basic_cstring<CharT>::is_empty() const [with CharT = const char]	16	static
basic_cstring.hpp:572:1:static boost::unit_test::basic_cstring<CharT>::self_type boost::unit_test::basic_cstring<CharT>::default_trim_ex() [with CharT = const char]	32	static
basic_cstring.hpp:405:1:boost::unit_test::basic_cstring<CharT>& boost::unit_test::basic_cstring<CharT>::operator=(const boost::unit_test::basic_cstring<CharT>&) [with CharT = const char]	16	static
basic_cstring.hpp:497:1:boost::unit_test::basic_cstring<CharT>::value_type* boost::unit_test::basic_cstring<CharT>::end() [with CharT = const char]	16	static
bcs_char_traits.hpp:93:24:static boost::unit_test::ut_detail::bcs_char_traits_impl<CharT>::const_char* boost::unit_test::ut_detail::bcs_char_traits_impl<CharT>::find(boost::unit_test::ut_detail::bcs_char_traits_impl<CharT>::const_char*, std::size_t, CharT) [with CharT = const char]	48	static
basic_cstring.hpp:317:1:boost::unit_test::basic_cstring<CharT>::self_type& boost::unit_test::basic_cstring<CharT>::trim_left(boost::unit_test::basic_cstring<CharT>::iterator) [with CharT = const char]	32	static
basic_cstring.hpp:361:1:boost::unit_test::basic_cstring<CharT>::self_type& boost::unit_test::basic_cstring<CharT>::trim_right(boost::unit_test::basic_cstring<CharT>::iterator) [with CharT = const char]	32	static
tuple:337:7:static constexpr const _Head& std::_Tuple_impl<_Idx, _Head>::_M_head(const std::_Tuple_impl<_Idx, _Head>&) [with long unsigned int _Idx = 0; _Head = boost::multi::extension_t<long int>]	32	static
tuple:210:17:) [with long unsigned int _Idx = 0; _Head = boost::multi::extension_t<long int>; _Tail = {boost::multi::extension_t<long int, long int>}]	48	static
tuple:1332:5:>&&) [with long unsigned int __i = 0; _Elements = {boost::multi::extension_t<long int, long int>}]	32	static
tuple:1572:9:_Is = {0}; _Tp = const std::tuple<boost::multi::extension_t<long int, long int> >&; _Tpls = {}]	80	static
function_template.hpp:912:10:void boost::function0<R>::assign_to(Functor) [with Functor = void (*)(); R = void]	48	static
scoped_ptr.hpp:65:14:boost::scoped_ptr<T>::scoped_ptr(T*) [with T = boost::test_tools::local_fpc_tolerance<double>]	16	static
scoped_ptr.hpp:83:5:boost::scoped_ptr<T>::~scoped_ptr() [with T = boost::test_tools::local_fpc_tolerance<double>]	32	static
shared_ptr.hpp:283:42:void boost::detail::sp_pointer_construct(boost::shared_ptr<X>*, Y*, boost::detail::shared_count&) [with T = boost::unit_test::test_unit_fixture; Y = boost::unit_test::class_based_fixture<boost::test_tools::local_fpc_tolerance<double>, double>]	64	static
cpp_type_traits.h:428:5:_Iterator std::__miter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<double, 1, const double*>]	16	static
stl_algobase.h:438:5:_OI std::__copy_move_a2(_II, _II, _OI) [with bool _IsMove = false; _II = boost::multi::array_iterator<double, 1, const double*>; _OI = boost::multi::array_iterator<double, 1, double*>]	112	static
new_allocator.h:83:7:__gnu_cxx::new_allocator<_Tp>::new_allocator(const __gnu_cxx::new_allocator<_Tp>&) [with _Tp = double]	16	static
array.hpp:86:7:void boost::multi::static_array<T, D, Alloc>::destroy_aux(std::true_type) [with T = double; long int D = 2; Alloc = std::allocator<double>]	16	static
alloc_traits.h:469:7:static void std::allocator_traits<std::allocator<_CharT> >::deallocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::pointer, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = double]	48	static
stl_algobase.h:222:5:constexpr const _Tp& std::max(const _Tp&, const _Tp&) [with _Tp = long int]	16	static
array.hpp:86:7:void boost::multi::static_array<T, D, Alloc>::destroy_aux(std::true_type) [with T = double; long int D = 1; Alloc = std::allocator<double>]	16	static
alloc_traits.h:443:7:static _Tp* std::allocator_traits<std::allocator<_CharT> >::allocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = double]	32	static
tuple:334:7:static constexpr _Head& std::_Tuple_impl<_Idx, _Head>::_M_head(std::_Tuple_impl<_Idx, _Head>&) [with long unsigned int _Idx = 0; _Head = boost::multi::extension_t<long int>]	32	static
array_ref.hpp:990:12:constexpr boost::multi::array_iterator<Element, 1, Ptr>::array_iterator(Ptr, typename boost::multi::basic_array<Element, 1, Ptr>::index) [with Element = double; Ptr = double*]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array_iterator<double, 1, double*>&]	16	static
adl.hpp:244:48:constexpr decltype (std::uninitialized_copy(f, l, d)) boost::multi::adl_uninitialized_copy_fn__::_(boost::multi::priority<1>, InIt, InIt, FwdIt) const [with InIt = const double*; FwdIt = boost::multi::array_iterator<double, 1, double*>; <template-parameter-1-3> = double*]	64	static
initializer_list:71:7:constexpr std::initializer_list<_E>::size_type std::initializer_list<_E>::size() const [with _E = boost::multi::array<double, 1, std::allocator<double> >]	16	static
adl.hpp:392:39:) const [with As = {const boost::multi::array<double, 1, std::allocator<double> >*&, const boost::multi::array<double, 1, std::allocator<double> >*&}]	80	static
utility.hpp:370:6:extensions()) boost::multi::extensions(const T&) [with T = boost::multi::array<double, 1, std::allocator<double> >; <template-parameter-1-2> = void]	48	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::array<double, 1, std::allocator<double> >&]	16	static
adl.hpp:399:48:) const [with T = const boost::multi::array<double, 1, std::allocator<double> >&; As = {}]	32	static
adl.hpp:410:39:) const [with As = {const boost::multi::array<double, 1, std::allocator<double> >&}]	32	static
array_ref.hpp:246:54:constexpr boost::multi::basic_array<Element, (D - 1), ElementPtr> boost::multi::array_iterator<Element, D, ElementPtr>::operator*() const [with Element = double; long int D = 2; ElementPtr = double*]	48	static
adl.hpp:401:39:) const [with As = {boost::multi::basic_array<double, 1, double*, boost::multi::layout_t<1, long int> >}]	32	static
adl.hpp:244:48:constexpr decltype (std::uninitialized_copy(f, l, d)) boost::multi::adl_uninitialized_copy_fn__::_(boost::multi::priority<1>, InIt, InIt, FwdIt) const [with InIt = boost::multi::array_iterator<double, 1, const double*>; FwdIt = boost::multi::array_iterator<double, 1, double*>; <template-parameter-1-3> = double*]	80	static
adl.hpp:249:39:) const [with As = {const boost::multi::array<double, 1, std::allocator<double> >*&, const boost::multi::array<double, 1, std::allocator<double> >*&, boost::multi::array_iterator<double, 2, double*>&}]	96	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::array<double, 1, std::allocator<double> >*&]	16	static
adl.hpp:477:48:) const [with T = std::allocator<double>&; As = {const boost::multi::array<double, 1, std::allocator<double> >*&, const boost::multi::array<double, 1, std::allocator<double> >*&, boost::multi::array_iterator<double, 2, double*>}]	160	dynamic,bounded
array_ref.hpp:1494:51:constexpr typename boost::multi::array_ref<T, D, ElementPtr>::element_ptr boost::multi::array_ref<T, D, ElementPtr>::data() const & [with T = double; long int D = 2; ElementPtr = double*]	16	static
stl_uninitialized.h:830:5:_ForwardIterator std::uninitialized_copy_n(_InputIterator, _Size, _ForwardIterator) [with _InputIterator = const double*; _Size = long int; _ForwardIterator = double*]	48	static
assertion.hpp:261:5:boost::test_tools::assertion::value_expr<T>::value_expr(boost::test_tools::assertion::value_expr<T>&&) [with T = double&]	32	static
fpc_op.hpp:207:1:static boost::test_tools::assertion_result boost::test_tools::assertion::op::EQ<Lhs, Rhs, typename boost::enable_if_c<(((boost::math::fpc::tolerance_based<T>::value && boost::math::fpc::tolerance_based<Rhs>::value) || (boost::math::fpc::tolerance_based<T>::value && boost::is_arithmetic<To>::value)) || (boost::is_arithmetic<T>::value && boost::math::fpc::tolerance_based<Rhs>::value))>::type>::eval(const Lhs&, const Rhs&) [with Lhs = double; Rhs = double]	64	static
assertion.hpp:274:33:const T& boost::test_tools::assertion::value_expr<T>::value() const [with T = double&]	16	static
fpc_op.hpp:207:1:static void boost::test_tools::assertion::op::EQ<Lhs, Rhs, typename boost::enable_if_c<(((boost::math::fpc::tolerance_based<T>::value && boost::math::fpc::tolerance_based<Rhs>::value) || (boost::math::fpc::tolerance_based<T>::value && boost::is_arithmetic<To>::value)) || (boost::is_arithmetic<T>::value && boost::math::fpc::tolerance_based<Rhs>::value))>::type>::report(std::ostream&, const PrevExprType&, const Rhs&) [with PrevExprType = boost::test_tools::assertion::value_expr<double&>; Lhs = double; Rhs = double]	80	static
array.hpp:441:27:constexpr boost::multi::static_array<T, D, Alloc>::const_iterator boost::multi::static_array<T, D, Alloc>::begin() const [with T = double; long int D = 2; Alloc = std::allocator<double>]	80	static
array.hpp:442:27:constexpr boost::multi::static_array<T, D, Alloc>::const_iterator boost::multi::static_array<T, D, Alloc>::end() const [with T = double; long int D = 2; Alloc = std::allocator<double>]	80	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::blas::gemm_range<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array<double, 2> >&]	16	static
gemm.hpp:299:11:boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::iterator boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::begin() const [with ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<double, 2, const double*>; ItB = boost::multi::array_iterator<double, 2, const double*>; DecayType = boost::multi::array<double, 2>]	112	dynamic,bounded
gemm.hpp:300:11:boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::iterator boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::end() const [with ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<double, 2, const double*>; ItB = boost::multi::array_iterator<double, 2, const double*>; DecayType = boost::multi::array<double, 2>]	112	dynamic,bounded
array_ref.hpp:247:27:constexpr decltype(auto) boost::multi::array_iterator<Element, D, ElementPtr>::operator->() const [with Element = double; long int D = 2; ElementPtr = double*]	16	static
array_ref.hpp:182:17:constexpr Ref* boost::multi::basic_array_ptr<Ref, Layout>::operator->() [with Ref = boost::multi::basic_array<double, 1, const double*, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	16	static
array_ref.hpp:182:17:constexpr Ref* boost::multi::basic_array_ptr<Ref, Layout>::operator->() [with Ref = boost::multi::basic_array<double, 1, double*, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	16	static
array_ref.hpp:283:31:constexpr boost::multi::array_iterator<Element, D, ElementPtr>::stride_type boost::multi::array_iterator<Element, D, ElementPtr>::stride() const & [with Element = double; long int D = 2; ElementPtr = const double*]	16	static
array_ref.hpp:283:31:constexpr boost::multi::array_iterator<Element, D, ElementPtr>::stride_type boost::multi::array_iterator<Element, D, ElementPtr>::stride() const & [with Element = double; long int D = 2; ElementPtr = double*]	16	static
gemm.hpp:47:6:auto boost::multi::blas::gemm_n(Context&&, typename It2DA::element, It2DA, Size, It2DB, typename It2DA::element, It2DC) [with Context = boost::multi::blas::context&; It2DA = boost::multi::array_iterator<double, 2, const double*>; Size = long int; It2DB = boost::multi::array_iterator<double, 2, const double*>; It2DC = boost::multi::array_iterator<double, 2, double*>]	1536	dynamic,bounded
gemm.hpp:275:14:auto boost::multi::blas::uninitialized_copy_n(const boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>&, boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>::difference_type, ItOut) [with ItOut = boost::multi::array_iterator<double, 2, double*>; ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<double, 2, const double*>; ItB = boost::multi::array_iterator<double, 2, const double*>]	112	dynamic,bounded
gemm.hpp:280:14:auto boost::multi::blas::uninitialized_copy(const boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>&, const boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>&, ItOut) [with ItOut = boost::multi::array_iterator<double, 2, double*>; ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<double, 2, const double*>; ItB = boost::multi::array_iterator<double, 2, const double*>]	112	dynamic,bounded
adl.hpp:343:16:constexpr auto boost::multi::xtd::alloc_uninitialized_copy(std::allocator<_CharT>&, InputIt, InputIt, ForwardIt) [with T = double; InputIt = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >; ForwardIt = boost::multi::array_iterator<double, 2, double*>]	48	static
adl.hpp:482:39:) const [with As = {std::allocator<double>&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >&, boost::multi::array_iterator<double, 2, double*>}]	112	static
array.hpp:146:2:boost::multi::static_array<T, D, Alloc>::static_array(It, It, const allocator_type&) [with It = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >; <template-parameter-2-2> = long int; T = double; long int D = 2; Alloc = std::allocator<double>]	272	static
array_ref.hpp:53:22:T& boost::multi::modify(const T&) [with T = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >]	16	static
move.h:99:5:constexpr typename std::remove_reference<_Tp>::type&& std::move(_Tp&&) [with _Tp = boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >&]	16	static
array_ref.hpp:759:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::begin() const & [with T = double; long int D = 2; ElementPtr = const double*; Layout = boost::multi::layout_t<2>]	64	dynamic,bounded
array_ref.hpp:760:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::end() const & [with T = double; long int D = 2; ElementPtr = const double*; Layout = boost::multi::layout_t<2>]	64	dynamic,bounded
cpp_type_traits.h:428:5:_Iterator std::__miter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>]	16	static
stl_algobase.h:438:5:_OI std::__copy_move_a2(_II, _II, _OI) [with bool _IsMove = false; _II = boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>; _OI = boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>]	112	static
array.hpp:86:7:void boost::multi::static_array<T, D, Alloc>::destroy_aux(std::true_type) [with T = std::complex<double>; long int D = 1; Alloc = std::allocator<std::complex<double> >]	16	static
alloc_traits.h:469:7:static void std::allocator_traits<std::allocator<_CharT> >::deallocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::pointer, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = std::complex<double>]	48	static
initializer_list:71:7:constexpr std::initializer_list<_E>::size_type std::initializer_list<_E>::size() const [with _E = boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >]	16	static
adl.hpp:392:39:) const [with As = {const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >*&, const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >*&}]	80	static
utility.hpp:370:6:extensions()) boost::multi::extensions(const T&) [with T = boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >; <template-parameter-1-2> = void]	48	static
array_ref.hpp:749:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::begin() & [with T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<2>]	64	dynamic,bounded
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >&]	16	static
adl.hpp:399:48:) const [with T = const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >&; As = {}]	32	static
adl.hpp:410:39:) const [with As = {const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >&}]	32	static
array_ref.hpp:246:54:constexpr boost::multi::basic_array<Element, (D - 1), ElementPtr> boost::multi::array_iterator<Element, D, ElementPtr>::operator*() const [with Element = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*]	48	static
adl.hpp:401:39:) const [with As = {boost::multi::basic_array<std::complex<double>, 1, std::complex<double>*, boost::multi::layout_t<1, long int> >}]	32	static
adl.hpp:245:48:) const [with As = {boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>}]	64	static
adl.hpp:249:39:) const [with As = {const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >*&, const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >*&, boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>&}]	96	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >*&]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>]	16	static
adl.hpp:477:48:) const [with T = std::allocator<std::complex<double> >&; As = {const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >*&, const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >*&, boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>}]	160	dynamic,bounded
array.hpp:86:7:void boost::multi::static_array<T, D, Alloc>::destroy_aux(std::true_type) [with T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	16	static
array_ref.hpp:93:29:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::element_ptr boost::multi::array_types<T, D, ElementPtr, Layout>::base() const [with T = std::complex<double>; long int D = 1; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<1>]	16	static
assertion.hpp:261:5:boost::test_tools::assertion::value_expr<T>::value_expr(boost::test_tools::assertion::value_expr<T>&&) [with T = double]	32	static
assertion.hpp:274:33:const T& boost::test_tools::assertion::value_expr<T>::value() const [with T = double]	16	static
fpc_op.hpp:207:1:static void boost::test_tools::assertion::op::EQ<Lhs, Rhs, typename boost::enable_if_c<(((boost::math::fpc::tolerance_based<T>::value && boost::math::fpc::tolerance_based<Rhs>::value) || (boost::math::fpc::tolerance_based<T>::value && boost::is_arithmetic<To>::value)) || (boost::is_arithmetic<T>::value && boost::math::fpc::tolerance_based<Rhs>::value))>::type>::report(std::ostream&, const PrevExprType&, const Rhs&) [with PrevExprType = boost::test_tools::assertion::value_expr<double>; Lhs = double; Rhs = double]	80	static
alloc_traits.h:443:7:static _Tp* std::allocator_traits<std::allocator<_CharT> >::allocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = std::complex<double>]	32	static
allocator.h:141:7:std::allocator< <template-parameter-1-1> >::allocator(const std::allocator< <template-parameter-1-1> >&) [with _Tp = std::complex<double>]	32	static
array_ref.hpp:990:12:constexpr boost::multi::array_iterator<Element, 1, Ptr>::array_iterator(Ptr, typename boost::multi::basic_array<Element, 1, Ptr>::index) [with Element = std::complex<double>; Ptr = std::complex<double>*]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>&]	16	static
adl.hpp:245:48:) const [with As = {const std::complex<double>*&, const std::complex<double>*&, boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>&}]	64	static
array_ref.hpp:1494:51:constexpr typename boost::multi::array_ref<T, D, ElementPtr>::element_ptr boost::multi::array_ref<T, D, ElementPtr>::data() const & [with T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*]	16	static
stl_uninitialized.h:830:5:_ForwardIterator std::uninitialized_copy_n(_InputIterator, _Size, _ForwardIterator) [with _InputIterator = const std::complex<double>*; _Size = long int; _ForwardIterator = std::complex<double>*]	48	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::basic_array<std::complex<double>, 1, std::complex<double>*, boost::multi::layout_t<1> >]	16	static
array_ref.hpp:116:12:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::array_types(const ArrayTypes&) [with ArrayTypes = boost::multi::basic_array<std::complex<double>, 1, std::complex<double>*, boost::multi::layout_t<1> >; <template-parameter-2-2> = void; <template-parameter-2-3> = const std::complex<double>*; T = std::complex<double>; long int D = 1; ElementPtr = const std::complex<double>*; Layout = boost::multi::layout_t<1>]	16	static
array_ref.hpp:93:29:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::element_ptr boost::multi::array_types<T, D, ElementPtr, Layout>::base() const [with T = std::complex<double>; long int D = 1; ElementPtr = const std::complex<double>*; Layout = boost::multi::layout_t<1>]	16	static
array.hpp:441:27:constexpr boost::multi::static_array<T, D, Alloc>::const_iterator boost::multi::static_array<T, D, Alloc>::begin() const [with T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	80	static
array.hpp:442:27:constexpr boost::multi::static_array<T, D, Alloc>::const_iterator boost::multi::static_array<T, D, Alloc>::end() const [with T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	80	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::blas::gemm_range<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >, boost::multi::array<std::complex<double>, 2> >&]	16	static
gemm.hpp:299:11:boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::iterator boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::begin() const [with ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >; DecayType = boost::multi::array<std::complex<double>, 2>]	128	dynamic,bounded
gemm.hpp:300:11:boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::iterator boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::end() const [with ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >; DecayType = boost::multi::array<std::complex<double>, 2>]	128	dynamic,bounded
array_ref.hpp:247:27:constexpr decltype(auto) boost::multi::array_iterator<Element, D, ElementPtr>::operator->() const [with Element = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*]	16	static
array_ref.hpp:182:17:constexpr Ref* boost::multi::basic_array_ptr<Ref, Layout>::operator->() [with Ref = boost::multi::basic_array<std::complex<double>, 1, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	16	static
array_ref.hpp:182:17:constexpr Ref* boost::multi::basic_array_ptr<Ref, Layout>::operator->() [with Ref = boost::multi::basic_array<std::complex<double>, 1, std::complex<double>*, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	16	static
array_ref.hpp:283:31:constexpr boost::multi::array_iterator<Element, D, ElementPtr>::stride_type boost::multi::array_iterator<Element, D, ElementPtr>::stride() const & [with Element = std::complex<double>; long int D = 2; ElementPtr = const std::complex<double>*]	16	static
array_ref.hpp:182:17:constexpr Ref* boost::multi::basic_array_ptr<Ref, Layout>::operator->() [with Ref = boost::multi::basic_array<std::complex<double>, 1, const std::complex<double>*, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	16	static
array_ref.hpp:283:31:constexpr boost::multi::array_iterator<Element, D, ElementPtr>::stride_type boost::multi::array_iterator<Element, D, ElementPtr>::stride() const & [with Element = std::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >]	16	static
array_ref.hpp:283:31:constexpr boost::multi::array_iterator<Element, D, ElementPtr>::stride_type boost::multi::array_iterator<Element, D, ElementPtr>::stride() const & [with Element = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*]	16	static
gemm.hpp:47:6:auto boost::multi::blas::gemm_n(Context&&, typename It2DA::element, It2DA, Size, It2DB, typename It2DA::element, It2DC) [with Context = boost::multi::blas::context&; It2DA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; Size = long int; It2DB = boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >; It2DC = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>]	1584	dynamic,bounded
gemm.hpp:275:14:auto boost::multi::blas::uninitialized_copy_n(const boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>&, boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>::difference_type, ItOut) [with ItOut = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>; ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >]	112	dynamic,bounded
gemm.hpp:280:14:auto boost::multi::blas::uninitialized_copy(const boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>&, const boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>&, ItOut) [with ItOut = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>; ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >]	112	dynamic,bounded
adl.hpp:343:16:constexpr auto boost::multi::xtd::alloc_uninitialized_copy(std::allocator<_CharT>&, InputIt, InputIt, ForwardIt) [with T = std::complex<double>; InputIt = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >; ForwardIt = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>]	48	static
adl.hpp:482:39:) const [with As = {std::allocator<std::complex<double> >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >&, boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>}]	112	static
array.hpp:146:2:boost::multi::static_array<T, D, Alloc>::static_array(It, It, const allocator_type&) [with It = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >; <template-parameter-2-2> = long int; T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	272	static
index_range.hpp:91:2:constexpr boost::multi::range<IndexType, IndexTypeLast>::range() [with IndexType = long int; IndexTypeLast = long int]	16	static
index_range.hpp:214:12:constexpr boost::multi::extension_t<IndexType, IndexTypeLast>::extension_t() [with IndexType = long int; IndexTypeLast = long int]	32	static
index_range.hpp:212:12:constexpr boost::multi::extension_t<IndexType, IndexTypeLast>::extension_t(IndexType, IndexTypeLast) [with IndexType = long int; IndexTypeLast = long int]	48	static
array_ref.hpp:833:17:>&) const & [with TT = std::complex<double>; As = {std::complex<double>*, boost::multi::layout_t<2, long int>}; T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<2>]	336	dynamic,bounded
array_ref.hpp:833:17:>&) const & [with TT = double; As = {double*, boost::multi::layout_t<2, long int>}; T = double; long int D = 2; ElementPtr = double*; Layout = boost::multi::layout_t<2>]	336	dynamic,bounded
tuple:1470:5:) [with _Elements = {boost::multi::extension_t<long int, long int>}]	32	static
layout.hpp:114:37:>()) && (1 >= 1)), bool>::type <anonymous> = true][inherited from std::tuple<boost::multi::extension_t<long int, long int> >]	32	static
layout.hpp:274:28:constexpr boost::multi::layout_t<1, SSize>::extensions_type boost::multi::layout_t<1, SSize>::extensions() const [with SSize = long int]	64	static
adl.hpp:441:48:) const [with As = {std::allocator<double>&, double*&, long int}]	64	static
stl_algobase.h:465:5:_OI std::copy(_II, _II, _OI) [with _II = boost::multi::array_iterator<double, 2, const double*>; _OI = boost::multi::array_iterator<double, 2, double*>]	256	dynamic,bounded
array_ref.hpp:53:22:T& boost::multi::modify(const T&) [with T = boost::multi::basic_array<std::complex<double>, 2, boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array_iterator<std::complex<double>, 1, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >]	16	static
adl.hpp:101:48:) const [with As = {boost::multi::array_iterator<std::complex<double>, 1, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >, boost::multi::array_iterator<std::complex<double>, 1, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >, boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>}]	112	dynamic,bounded
numeric.hpp:144:21:constexpr boost::multi::blas::involuter<It, F, Reference>::involuter(const Other&) [with Other = boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >; <template-parameter-2-2> = const std::complex<double>*; It = const std::complex<double>*; F = boost::multi::blas::conjugate; Reference = boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate>]	16	static
array_ref.hpp:1077:15:constexpr boost::multi::basic_array<std::complex<double>, 1, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<1> >::basic_array(const layout_t&, const element_ptr&) [inherited from boost::multi::array_types<std::complex<double>, 1, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<1> >]	48	static
array_ref.hpp:186:12:constexpr boost::multi::basic_array_ptr<Ref, Layout>::basic_array_ptr(typename Ref::element_ptr, const Layout&) [with Ref = boost::multi::basic_array<std::complex<double>, 1, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	64	static
array_ref.hpp:252:12:constexpr boost::multi::array_iterator<Element, D, ElementPtr>::array_iterator(typename boost::multi::basic_array<Element, (D - 1), ElementPtr>::element_ptr, boost::multi::layout_t<(D - 1), long int>, boost::multi::index) [with Element = std::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >]	64	static
adl.hpp:105:39:) const [with As = {boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >, boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>}]	96	static
array.hpp:220:2:>&, const allocator_type&) [with TT = std::complex<double>; Args = {boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2, long int>}; <template-parameter-2-3> = void; <template-parameter-2-4> = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>; T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	272	static
array.hpp:435:44:constexpr boost::multi::static_array<T, D, Alloc>::iterator boost::multi::static_array<T, D, Alloc>::begin() [with T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	48	static
array_ref.hpp:53:22:T& boost::multi::modify(const T&) [with T = boost::multi::basic_array<std::complex<double>, 2, std::complex<double>*, boost::multi::layout_t<2> >]	16	static
move.h:99:5:constexpr typename std::remove_reference<_Tp>::type&& std::move(_Tp&&) [with _Tp = boost::multi::basic_array<std::complex<double>, 2, std::complex<double>*, boost::multi::layout_t<2> >&]	16	static
array_ref.hpp:1077:15:constexpr boost::multi::basic_array<std::complex<double>, 1, const std::complex<double>*, boost::multi::layout_t<1> >::basic_array(const layout_t&, const std::complex<double>* const&) [inherited from boost::multi::array_types<std::complex<double>, 1, const std::complex<double>*, boost::multi::layout_t<1> >]	48	static
array_ref.hpp:186:12:constexpr boost::multi::basic_array_ptr<Ref, Layout>::basic_array_ptr(typename Ref::element_ptr, const Layout&) [with Ref = boost::multi::basic_array<std::complex<double>, 1, const std::complex<double>*, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	48	static
array_ref.hpp:252:12:constexpr boost::multi::array_iterator<Element, D, ElementPtr>::array_iterator(typename boost::multi::basic_array<Element, (D - 1), ElementPtr>::element_ptr, boost::multi::layout_t<(D - 1), long int>, boost::multi::index) [with Element = std::complex<double>; long int D = 2; ElementPtr = const std::complex<double>*]	48	static
adl.hpp:105:39:) const [with As = {boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>}]	96	static
array.hpp:220:2:>&, const allocator_type&) [with TT = std::complex<double>; Args = {std::complex<double>*, boost::multi::layout_t<2, long int>}; <template-parameter-2-3> = void; <template-parameter-2-4> = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>; T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	256	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::blas::gemm_range<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array<std::complex<double>, 2> >&]	16	static
gemm.hpp:299:11:boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::iterator boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::begin() const [with ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; DecayType = boost::multi::array<std::complex<double>, 2>]	112	dynamic,bounded
gemm.hpp:300:11:boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::iterator boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::end() const [with ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; DecayType = boost::multi::array<std::complex<double>, 2>]	112	dynamic,bounded
gemm.hpp:47:6:auto boost::multi::blas::gemm_n(Context&&, typename It2DA::element, It2DA, Size, It2DB, typename It2DA::element, It2DC) [with Context = boost::multi::blas::context&; It2DA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; Size = long int; It2DB = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; It2DC = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>]	1552	dynamic,bounded
gemm.hpp:275:14:auto boost::multi::blas::uninitialized_copy_n(const boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>&, boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>::difference_type, ItOut) [with ItOut = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>; ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>]	112	dynamic,bounded
gemm.hpp:280:14:auto boost::multi::blas::uninitialized_copy(const boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>&, const boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>&, ItOut) [with ItOut = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>; ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>]	112	dynamic,bounded
adl.hpp:343:16:constexpr auto boost::multi::xtd::alloc_uninitialized_copy(std::allocator<_CharT>&, InputIt, InputIt, ForwardIt) [with T = std::complex<double>; InputIt = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >; ForwardIt = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>]	48	static
adl.hpp:482:39:) const [with As = {std::allocator<std::complex<double> >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>}]	112	static
array.hpp:146:2:boost::multi::static_array<T, D, Alloc>::static_array(It, It, const allocator_type&) [with It = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >; <template-parameter-2-2> = long int; T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	272	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::blas::gemm_range<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array<std::complex<double>, 2> >&]	16	static
gemm.hpp:299:11:boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::iterator boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::begin() const [with ContextPtr = boost::multi::blas::context*; Scalar = std::complex<double>; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; DecayType = boost::multi::array<std::complex<double>, 2>]	112	dynamic,bounded
gemm.hpp:300:11:boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::iterator boost::multi::blas::gemm_range<ContextPtr, Scalar, ItA, ItB, DecayType>::end() const [with ContextPtr = boost::multi::blas::context*; Scalar = std::complex<double>; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; DecayType = boost::multi::array<std::complex<double>, 2>]	112	dynamic,bounded
gemm.hpp:275:14:auto boost::multi::blas::uninitialized_copy_n(const boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>&, boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>::difference_type, ItOut) [with ItOut = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>; ContextPtr = boost::multi::blas::context*; Scalar = std::complex<double>; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>]	112	dynamic,bounded
gemm.hpp:280:14:auto boost::multi::blas::uninitialized_copy(const boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>&, const boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>&, ItOut) [with ItOut = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>; ContextPtr = boost::multi::blas::context*; Scalar = std::complex<double>; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>]	112	dynamic,bounded
adl.hpp:343:16:constexpr auto boost::multi::xtd::alloc_uninitialized_copy(std::allocator<_CharT>&, InputIt, InputIt, ForwardIt) [with T = std::complex<double>; InputIt = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >; ForwardIt = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>]	48	static
adl.hpp:482:39:) const [with As = {std::allocator<std::complex<double> >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>}]	112	static
array.hpp:146:2:boost::multi::static_array<T, D, Alloc>::static_array(It, It, const allocator_type&) [with It = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >; <template-parameter-2-2> = long int; T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	272	static
cpp_type_traits.h:428:5:_Iterator std::__miter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>]	16	static
stl_algobase.h:438:5:_OI std::__copy_move_a2(_II, _II, _OI) [with bool _IsMove = false; _II = boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>; _OI = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>]	112	static
initializer_list:71:7:constexpr std::initializer_list<_E>::size_type std::initializer_list<_E>::size() const [with _E = thrust::complex<double>]	16	static
new_allocator.h:80:7:__gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = thrust::complex<double>]	16	static
new_allocator.h:89:7:__gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = thrust::complex<double>]	16	static
stl_iterator_base_types.h:205:5:constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = const thrust::complex<double>*]	16	static
stl_iterator_base_funcs.h:98:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = const thrust::complex<double>*]	16	static
array_ref.hpp:1426:12:constexpr boost::multi::array_ref<T, D, ElementPtr>::array_ref(typename boost::multi::array_ref<T, D, ElementPtr>::element_ptr, typename boost::multi::array_ref<T, D, ElementPtr>::extensions_type) [with T = thrust::complex<double>; long int D = 1; ElementPtr = thrust::complex<double>*]	112	static
array.hpp:29:18:boost::multi::array_allocator<Allocator>::allocator_type& boost::multi::array_allocator<Allocator>::alloc() [with Allocator = std::allocator<thrust::complex<double> >]	16	static
array_ref.hpp:1266:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::begin() & [with T = thrust::complex<double>; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<1>]	64	static
adl.hpp:249:39:) const [with As = {const thrust::complex<double>*&, const thrust::complex<double>*&, boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>&}]	80	static
adl.hpp:477:48:) const [with T = std::allocator<thrust::complex<double> >&; As = {const thrust::complex<double>*&, const thrust::complex<double>*&, boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>}]	96	static
array.hpp:86:7:void boost::multi::static_array<T, D, Alloc>::destroy_aux(std::true_type) [with T = thrust::complex<double>; long int D = 1; Alloc = std::allocator<thrust::complex<double> >]	16	static
alloc_traits.h:469:7:static void std::allocator_traits<std::allocator<_CharT> >::deallocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::pointer, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = thrust::complex<double>]	48	static
initializer_list:71:7:constexpr std::initializer_list<_E>::size_type std::initializer_list<_E>::size() const [with _E = boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >]	16	static
adl.hpp:392:39:) const [with As = {const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >*&, const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >*&}]	80	static
utility.hpp:370:6:extensions()) boost::multi::extensions(const T&) [with T = boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >; <template-parameter-1-2> = void]	48	static
array_ref.hpp:749:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::begin() & [with T = thrust::complex<double>; long int D = 2; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<2>]	64	dynamic,bounded
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >&]	16	static
adl.hpp:399:48:) const [with T = const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >&; As = {}]	32	static
adl.hpp:410:39:) const [with As = {const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >&}]	32	static
array_ref.hpp:246:54:constexpr boost::multi::basic_array<Element, (D - 1), ElementPtr> boost::multi::array_iterator<Element, D, ElementPtr>::operator*() const [with Element = thrust::complex<double>; long int D = 2; ElementPtr = thrust::complex<double>*]	48	static
adl.hpp:401:39:) const [with As = {boost::multi::basic_array<thrust::complex<double>, 1, thrust::complex<double>*, boost::multi::layout_t<1, long int> >}]	32	static
adl.hpp:244:48:constexpr decltype (std::uninitialized_copy(f, l, d)) boost::multi::adl_uninitialized_copy_fn__::_(boost::multi::priority<1>, InIt, InIt, FwdIt) const [with InIt = boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>; FwdIt = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>; <template-parameter-1-3> = thrust::complex<double>*]	80	static
adl.hpp:249:39:) const [with As = {const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >*&, const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >*&, boost::multi::array_iterator<thrust::complex<double>, 2, thrust::complex<double>*>&}]	96	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >*&]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array_iterator<thrust::complex<double>, 2, thrust::complex<double>*>]	16	static
adl.hpp:477:48:) const [with T = std::allocator<thrust::complex<double> >&; As = {const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >*&, const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >*&, boost::multi::array_iterator<thrust::complex<double>, 2, thrust::complex<double>*>}]	160	dynamic,bounded
array.hpp:86:7:void boost::multi::static_array<T, D, Alloc>::destroy_aux(std::true_type) [with T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	16	static
complex.h:451:3:thrust::complex<T>::operator std::complex<_Tp>() const [with T = double]	64	static
allocator.h:141:7:std::allocator< <template-parameter-1-1> >::allocator(const std::allocator< <template-parameter-1-1> >&) [with _Tp = thrust::complex<double>]	32	static
alloc_traits.h:443:7:static _Tp* std::allocator_traits<std::allocator<_CharT> >::allocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = thrust::complex<double>]	32	static
array_ref.hpp:1494:51:constexpr typename boost::multi::array_ref<T, D, ElementPtr>::element_ptr boost::multi::array_ref<T, D, ElementPtr>::data() const & [with T = thrust::complex<double>; long int D = 2; ElementPtr = thrust::complex<double>*]	16	static
stl_uninitialized.h:830:5:_ForwardIterator std::uninitialized_copy_n(_InputIterator, _Size, _ForwardIterator) [with _InputIterator = const thrust::complex<double>*; _Size = long int; _ForwardIterator = thrust::complex<double>*]	48	static
array_ref.hpp:93:29:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::element_ptr boost::multi::array_types<T, D, ElementPtr, Layout>::base() const [with T = thrust::complex<double>; long int D = 1; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<1>]	16	static
array_ref.hpp:833:17:>&) const & [with TT = thrust::complex<double>; As = {thrust::complex<double>*, boost::multi::layout_t<2, long int>}; T = thrust::complex<double>; long int D = 2; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<2>]	336	dynamic,bounded
array_ref.hpp:53:22:T& boost::multi::modify(const T&) [with T = boost::multi::basic_array<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const thrust::complex<double>&]	16	static
complex.hpp:21:29:) const [with As = {const thrust::complex<double>&}]	64	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array_iterator<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >]	16	static
adl.hpp:96:48:constexpr decltype (std::copy(first, last, d_first)) boost::multi::adl_copy_fn__::_(boost::multi::priority<1>, InputIt, InputIt, OutputIt) const [with InputIt = boost::multi::array_iterator<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >; OutputIt = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>; <template-parameter-1-3> = void]	96	dynamic,bounded
numeric.hpp:144:21:constexpr boost::multi::blas::involuter<It, F, Reference>::involuter(const Other&) [with Other = boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >; <template-parameter-2-2> = const thrust::complex<double>*; It = const thrust::complex<double>*; F = boost::multi::blas::conjugate; Reference = boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate>]	16	static
array_ref.hpp:1077:15:constexpr boost::multi::basic_array<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<1> >::basic_array(const layout_t&, const element_ptr&) [inherited from boost::multi::array_types<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<1> >]	48	static
array_ref.hpp:186:12:constexpr boost::multi::basic_array_ptr<Ref, Layout>::basic_array_ptr(typename Ref::element_ptr, const Layout&) [with Ref = boost::multi::basic_array<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	64	static
array_ref.hpp:252:12:constexpr boost::multi::array_iterator<Element, D, ElementPtr>::array_iterator(typename boost::multi::basic_array<Element, (D - 1), ElementPtr>::element_ptr, boost::multi::layout_t<(D - 1), long int>, boost::multi::index) [with Element = thrust::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> >]	64	static
adl.hpp:105:39:) const [with As = {boost::multi::array_iterator<thrust::complex<double>, 2, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >, boost::multi::array_iterator<thrust::complex<double>, 2, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >, boost::multi::array_iterator<thrust::complex<double>, 2, thrust::complex<double>*>}]	240	dynamic,bounded
array.hpp:220:2:>&, const allocator_type&) [with TT = thrust::complex<double>; Args = {boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2, long int>}; <template-parameter-2-3> = void; <template-parameter-2-4> = boost::multi::array_iterator<thrust::complex<double>, 2, thrust::complex<double>*>; T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	272	static
array.hpp:435:44:constexpr boost::multi::static_array<T, D, Alloc>::iterator boost::multi::static_array<T, D, Alloc>::begin() [with T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	48	static
array_ref.hpp:833:17:>&) const & [with TT = thrust::complex<double>; As = {boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2, long int>}; T = thrust::complex<double>; long int D = 2; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<2>]	352	dynamic,bounded
basic_string.h:243:9:void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct_aux(_InIterator, _InIterator, std::__false_type) [with _InIterator = char*; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]	64	static
stl_iterator_base_funcs.h:138:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = const char*]	32	static
basic_string.tcc:206:7:void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator, std::forward_iterator_tag) [with _FwdIterator = const char*; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]	80	static
shared_count.hpp:136:32:boost::detail::shared_count::shared_count(Y*) [with Y = boost::basic_wrap_stringstream<char>]	48	static
decorator.hpp:230:23:boost::unit_test::decorator::fixture_t::~fixture_t()	32	static
decorator.hpp:230:23:virtual boost::unit_test::decorator::fixture_t::~fixture_t()	32	static
basic_cstring.hpp:79:5:boost::unit_test::basic_cstring<CharT>::basic_cstring(boost::unit_test::basic_cstring<CharT>::pointer, LenType) [with LenType = int; CharT = const char]	16	static
basic_cstring.hpp:285:1:void boost::unit_test::basic_cstring<CharT>::clear() [with CharT = const char]	16	static
tuple:343:17:constexpr std::_Tuple_impl<_Idx, _Head>::_Tuple_impl(const _Head&) [with long unsigned int _Idx = 1; _Head = boost::multi::extension_t<long int>]	32	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::extension_t<long int>&&]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::extension_t<long int>]	16	static
tuple:1587:2:) [with _Us = {boost::multi::extension_t<long int, long int>, const boost::multi::extension_t<long int, long int>&}; _Ret = std::tuple<boost::multi::extension_t<long int, long int>, boost::multi::extension_t<long int, long int> >]	64	static
function_base.hpp:395:9:static void boost::detail::function::functor_manager<Functor>::manage(const boost::detail::function::function_buffer&, boost::detail::function::function_buffer&, boost::detail::function::functor_manager_operation_type) [with Functor = void (*)()]	64	static
function_template.hpp:112:9:static void boost::detail::function::void_function_invoker0<FunctionPtr, R>::invoke(boost::detail::function::function_buffer&) [with FunctionPtr = void (*)(); R = void]	48	static
function_template.hpp:490:14:bool boost::detail::function::basic_vtable0<R>::assign_to(F, boost::detail::function::function_buffer&) const [with F = void (*)(); R = void]	48	static
checked_delete.hpp:31:31:void boost::checked_delete(T*) [with T = boost::test_tools::local_fpc_tolerance<double>]	48	static
shared_count.hpp:136:32:boost::detail::shared_count::shared_count(Y*) [with Y = boost::unit_test::class_based_fixture<boost::test_tools::local_fpc_tolerance<double>, double>]	48	static
stl_algobase.h:280:5:_Iterator std::__niter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<double, 1, const double*>]	16	static
stl_algobase.h:280:5:_Iterator std::__niter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<double, 1, double*>]	16	static
stl_algobase.h:393:5:_OI std::__copy_move_a(_II, _II, _OI) [with bool _IsMove = false; _II = boost::multi::array_iterator<double, 1, const double*>; _OI = boost::multi::array_iterator<double, 1, double*>]	96	static
stl_algobase.h:295:5:_Iterator std::__niter_wrap(const _Iterator&, _Iterator) [with _Iterator = boost::multi::array_iterator<double, 1, double*>]	16	static
new_allocator.h:119:7:void __gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer, __gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = double]	48	static
new_allocator.h:102:7:_Tp* __gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type, const void*) [with _Tp = double]	48	static
tuple:160:7:static constexpr _Head& std::_Head_base<_Idx, _Head, false>::_M_head(std::_Head_base<_Idx, _Head, false>&) [with long unsigned int _Idx = 0; _Head = boost::multi::extension_t<long int>]	16	static
stl_uninitialized.h:115:5:_ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = const double*; _ForwardIterator = boost::multi::array_iterator<double, 1, double*>]	64	static
adl.hpp:388:48:) const [with As = {const boost::multi::array<double, 1, std::allocator<double> >*&, const boost::multi::array<double, 1, std::allocator<double> >*&}]	64	static
array.hpp:441:27:constexpr boost::multi::static_array<T, D, Alloc>::const_iterator boost::multi::static_array<T, D, Alloc>::begin() const [with T = double; long int D = 1; Alloc = std::allocator<double>]	80	static
adl.hpp:408:48:) const [with T = const boost::multi::array<double, 1, std::allocator<double> >&; As = {}]	32	static
array_ref.hpp:180:20:constexpr Ref boost::multi::basic_array_ptr<Ref, Layout>::operator*() const [with Ref = boost::multi::basic_array<double, 1, double*, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	16	static
adl.hpp:399:48:) const [with T = boost::multi::basic_array<double, 1, double*, boost::multi::layout_t<1> >; As = {}]	32	static
stl_uninitialized.h:115:5:_ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = boost::multi::array_iterator<double, 1, const double*>; _ForwardIterator = boost::multi::array_iterator<double, 1, double*>]	96	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array_iterator<double, 2, double*>&]	16	static
adl.hpp:245:48:) const [with As = {const boost::multi::array<double, 1, std::allocator<double> >*&, const boost::multi::array<double, 1, std::allocator<double> >*&, boost::multi::array_iterator<double, 2, double*>&}]	144	dynamic,bounded
stl_uninitialized.h:782:5:_ForwardIterator std::__uninitialized_copy_n(_RandomAccessIterator, _Size, _ForwardIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = const double*; _Size = long int; _ForwardIterator = double*]	48	static
fpc_tolerance.hpp:37:1:FPT& boost::test_tools::fpc_tolerance() [with FPT = double]	16	static
fpc_op.hpp:207:1:static bool boost::test_tools::assertion::op::EQ<Lhs, Rhs, typename boost::enable_if_c<(((boost::math::fpc::tolerance_based<T>::value && boost::math::fpc::tolerance_based<Rhs>::value) || (boost::math::fpc::tolerance_based<T>::value && boost::is_arithmetic<To>::value)) || (boost::is_arithmetic<T>::value && boost::math::fpc::tolerance_based<Rhs>::value))>::type>::eval_direct(const Lhs&, const Rhs&) [with Lhs = double; Rhs = double]	16	static
assertion_result.hpp:39:23:boost::test_tools::assertion_result::assertion_result(boost::test_tools::assertion_result&&)	32	static
fpc_op.hpp:109:1:boost::test_tools::assertion_result boost::test_tools::assertion::op::compare_fpv(const Lhs&, const Rhs&, boost::test_tools::assertion::op::EQ<Lhs, Rhs>*) [with FPT = double; Lhs = double; Rhs = double]	160	static
assertion.hpp:278:33:void boost::test_tools::assertion::value_expr<T>::report(std::ostream&) const [with T = double&]	48	static
fpc_op.hpp:207:1:static const char* boost::test_tools::assertion::op::EQ<Lhs, Rhs, typename boost::enable_if_c<(((boost::math::fpc::tolerance_based<T>::value && boost::math::fpc::tolerance_based<Rhs>::value) || (boost::math::fpc::tolerance_based<T>::value && boost::is_arithmetic<To>::value)) || (boost::is_arithmetic<T>::value && boost::math::fpc::tolerance_based<Rhs>::value))>::type>::revert() [with Lhs = double; Rhs = double]	16	static
print_helper.hpp:209:1:boost::test_tools::tt_detail::print_helper_t<T> boost::test_tools::tt_detail::print_helper(const T&) [with T = double]	48	static
print_helper.hpp:218:1:std::ostream& boost::test_tools::tt_detail::operator<<(std::ostream&, const boost::test_tools::tt_detail::print_helper_t<T>&) [with T = double]	48	static
array_ref.hpp:96:28:constexpr const layout_t& boost::multi::array_types<T, D, ElementPtr, Layout>::layout() const [with T = double; long int D = 1; ElementPtr = double*; Layout = boost::multi::layout_t<1>]	16	static
array_ref.hpp:242:12:constexpr boost::multi::array_iterator<Element, D, ElementPtr>::array_iterator(const Other&) [with Other = boost::multi::array_iterator<double, 2, double*>; <template-parameter-2-2> = const double*; Element = double; long int D = 2; ElementPtr = const double*]	48	static
array_ref.hpp:755:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::end() && [with T = double; long int D = 2; ElementPtr = double*; Layout = boost::multi::layout_t<2>]	48	static
gemm.hpp:230:2:boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>::gemm_iterator(ContextPtr, Scalar, ItA, ItB) [with ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<double, 2, const double*>; ItB = boost::multi::array_iterator<double, 2, const double*>]	24	static
adl.hpp:392:39:) const [with As = {boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >&}]	80	static
gemm.hpp:283:12:boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>::reference boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>::operator*() const [with ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<double, 2, const double*>; ItB = boost::multi::array_iterator<double, 2, const double*>]	80	static
utility.hpp:370:6:extensions()) boost::multi::extensions(const T&) [with T = boost::multi::blas::gemm_reference<boost::multi::extensions_t<1> >; <template-parameter-1-2> = void]	32	static
array_ref.hpp:287:17:constexpr bool boost::multi::array_iterator<Element, D, ElementPtr>::operator==(const boost::multi::array_iterator<Element, D, ElementPtr>&) const [with Element = double; long int D = 2; ElementPtr = const double*]	32	static
array_ref.hpp:193:17:constexpr bool boost::multi::basic_array_ptr<Ref, Layout>::operator==(const boost::multi::basic_array_ptr<Ref, Layout>&) const [with Ref = boost::multi::basic_array<double, 1, const double*, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	48	static
array_ref.hpp:270:17:constexpr bool boost::multi::array_iterator<Element, D, ElementPtr>::equal(const boost::multi::array_iterator<Element, D, ElementPtr>&) const [with Element = double; long int D = 2; ElementPtr = const double*]	32	static
gemm.hpp:251:25:boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >::difference_type boost::multi::blas::operator-(const boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >&, const boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >&)	32	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::blas::context&]	16	static
array_ref.hpp:282:31:constexpr const double* boost::multi::base(const boost::multi::array_iterator<double, 2, const double*>&)	32	static
array_ref.hpp:282:31:constexpr double* boost::multi::base(const boost::multi::array_iterator<double, 2, double*>&)	32	static
core.hpp:527:14:) [with As = {char, char, long int, long int&, long int, double*, const double*, long int, const double*, long int, double*, double*, long int}]	240	dynamic,bounded
core.hpp:527:14:) [with As = {char, char, long int&, long int, long int, double*, const double*, long int, const double*, long int, double*, double*, long int}]	240	dynamic,bounded
array_ref.hpp:292:28:constexpr boost::multi::array_iterator<Element, D, ElementPtr>& boost::multi::array_iterator<Element, D, ElementPtr>::operator+=(boost::multi::array_iterator<Element, D, ElementPtr>::difference_type) [with Element = double; long int D = 2; ElementPtr = double*]	32	static
array_ref.hpp:248:30:constexpr boost::multi::array_iterator<Element, D, ElementPtr> boost::multi::array_iterator<Element, D, ElementPtr>::operator+(boost::multi::array_iterator<Element, D, ElementPtr>::difference_type) const [with Element = double; long int D = 2; ElementPtr = double*]	80	static
gemm.hpp:258:14:0, d_first)) boost::multi::blas::copy_n(const boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>&, boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>::difference_type, ItOut) [with ItOut = boost::multi::array_iterator<double, 2, double*>; ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<double, 2, const double*>; ItB = boost::multi::array_iterator<double, 2, const double*>]	1056	dynamic,bounded
adl.hpp:249:39:) const [with As = {boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >&, boost::multi::array_iterator<double, 2, double*>&}]	96	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >&]	16	static
adl.hpp:477:48:) const [with T = std::allocator<double>&; As = {boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >&, boost::multi::array_iterator<double, 2, double*>}]	352	dynamic,bounded
stl_algobase.h:280:5:_Iterator std::__niter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>]	16	static
stl_algobase.h:280:5:_Iterator std::__niter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>]	16	static
stl_algobase.h:393:5:_OI std::__copy_move_a(_II, _II, _OI) [with bool _IsMove = false; _II = boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>; _OI = boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>]	96	static
stl_algobase.h:295:5:_Iterator std::__niter_wrap(const _Iterator&, _Iterator) [with _Iterator = boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>]	16	static
new_allocator.h:119:7:void __gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer, __gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = std::complex<double>]	48	static
adl.hpp:388:48:) const [with As = {const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >*&, const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >*&}]	64	static
array_ref.hpp:186:12:constexpr boost::multi::basic_array_ptr<Ref, Layout>::basic_array_ptr(typename Ref::element_ptr, const Layout&) [with Ref = boost::multi::basic_array<std::complex<double>, 1, std::complex<double>*, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	48	static
array_ref.hpp:252:12:constexpr boost::multi::array_iterator<Element, D, ElementPtr>::array_iterator(typename boost::multi::basic_array<Element, (D - 1), ElementPtr>::element_ptr, boost::multi::layout_t<(D - 1), long int>, boost::multi::index) [with Element = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*]	48	static
array.hpp:441:27:constexpr boost::multi::static_array<T, D, Alloc>::const_iterator boost::multi::static_array<T, D, Alloc>::begin() const [with T = std::complex<double>; long int D = 1; Alloc = std::allocator<std::complex<double> >]	80	static
adl.hpp:408:48:) const [with T = const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >&; As = {}]	32	static
array_ref.hpp:180:20:constexpr Ref boost::multi::basic_array_ptr<Ref, Layout>::operator*() const [with Ref = boost::multi::basic_array<std::complex<double>, 1, std::complex<double>*, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	16	static
adl.hpp:399:48:) const [with T = boost::multi::basic_array<std::complex<double>, 1, std::complex<double>*, boost::multi::layout_t<1> >; As = {}]	32	static
stl_uninitialized.h:115:5:_ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>; _ForwardIterator = boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>]	96	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>&]	16	static
adl.hpp:245:48:) const [with As = {const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >*&, const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >*&, boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>&}]	144	dynamic,bounded
assertion.hpp:278:33:void boost::test_tools::assertion::value_expr<T>::report(std::ostream&) const [with T = double]	48	static
new_allocator.h:102:7:_Tp* __gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type, const void*) [with _Tp = std::complex<double>]	48	static
new_allocator.h:83:7:__gnu_cxx::new_allocator<_Tp>::new_allocator(const __gnu_cxx::new_allocator<_Tp>&) [with _Tp = std::complex<double>]	16	static
stl_uninitialized.h:115:5:_ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = const std::complex<double>*; _ForwardIterator = boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>]	64	static
stl_uninitialized.h:782:5:_ForwardIterator std::__uninitialized_copy_n(_RandomAccessIterator, _Size, _ForwardIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = const std::complex<double>*; _Size = long int; _ForwardIterator = std::complex<double>*]	48	static
array_ref.hpp:96:28:constexpr const layout_t& boost::multi::array_types<T, D, ElementPtr, Layout>::layout() const [with T = std::complex<double>; long int D = 1; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<1>]	16	static
array_ref.hpp:242:12:constexpr boost::multi::array_iterator<Element, D, ElementPtr>::array_iterator(const Other&) [with Other = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>; <template-parameter-2-2> = const std::complex<double>*; Element = std::complex<double>; long int D = 2; ElementPtr = const std::complex<double>*]	48	static
array_ref.hpp:755:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::end() && [with T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<2>]	48	static
gemm.hpp:230:2:boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>::gemm_iterator(ContextPtr, Scalar, ItA, ItB) [with ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >]	24	static
adl.hpp:392:39:) const [with As = {boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >&}]	80	static
gemm.hpp:283:12:boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>::reference boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>::operator*() const [with ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >]	80	static
array_ref.hpp:287:17:constexpr bool boost::multi::array_iterator<Element, D, ElementPtr>::operator==(const boost::multi::array_iterator<Element, D, ElementPtr>&) const [with Element = std::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >]	32	static
array_ref.hpp:193:17:constexpr bool boost::multi::basic_array_ptr<Ref, Layout>::operator==(const boost::multi::basic_array_ptr<Ref, Layout>&) const [with Ref = boost::multi::basic_array<std::complex<double>, 1, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	48	static
array_ref.hpp:270:17:constexpr bool boost::multi::array_iterator<Element, D, ElementPtr>::equal(const boost::multi::array_iterator<Element, D, ElementPtr>&) const [with Element = std::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >]	32	static
gemm.hpp:251:25:boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >::difference_type boost::multi::blas::operator-(const boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >&, const boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >&)	32	static
array_ref.hpp:282:31:constexpr boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >::element_ptr boost::multi::base(const boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >&)	32	static
numeric.hpp:161:35:constexpr const std::complex<double>* boost::multi::blas::underlying(const boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >&)	16	static
array_ref.hpp:282:31:constexpr const std::complex<double>* boost::multi::base(const boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>&)	32	static
array_ref.hpp:282:31:constexpr std::complex<double>* boost::multi::base(const boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>&)	32	static
core.hpp:527:14:) [with As = {char, char, long int, long int&, long int, std::complex<double>*, const std::complex<double>*, long int, const std::complex<double>*, long int&, std::complex<double>*, std::complex<double>*, long int}]	240	dynamic,bounded
core.hpp:527:14:) [with As = {char, char, long int, long int&, long int, std::complex<double>*, const std::complex<double>*, long int, const std::complex<double>*, long int, std::complex<double>*, std::complex<double>*, long int}]	240	dynamic,bounded
core.hpp:527:14:) [with As = {char, char, long int&, long int, long int, std::complex<double>*, const std::complex<double>*, long int, const std::complex<double>*, long int, std::complex<double>*, std::complex<double>*, long int}]	240	dynamic,bounded
array_ref.hpp:292:28:constexpr boost::multi::array_iterator<Element, D, ElementPtr>& boost::multi::array_iterator<Element, D, ElementPtr>::operator+=(boost::multi::array_iterator<Element, D, ElementPtr>::difference_type) [with Element = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*]	32	static
array_ref.hpp:248:30:constexpr boost::multi::array_iterator<Element, D, ElementPtr> boost::multi::array_iterator<Element, D, ElementPtr>::operator+(boost::multi::array_iterator<Element, D, ElementPtr>::difference_type) const [with Element = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*]	80	static
gemm.hpp:258:14:0, d_first)) boost::multi::blas::copy_n(const boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>&, boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>::difference_type, ItOut) [with ItOut = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>; ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >]	1088	dynamic,bounded
adl.hpp:249:39:) const [with As = {boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >&, boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>&}]	96	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >&]	16	static
adl.hpp:477:48:) const [with T = std::allocator<std::complex<double> >&; As = {boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >&, boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>}]	368	dynamic,bounded
array_ref.hpp:760:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::end() const & [with T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<2>]	64	dynamic,bounded
adl.hpp:401:39:) const [with As = {const boost::multi::basic_array<std::complex<double>, 2, std::complex<double>*, boost::multi::layout_t<2, long int> >&}]	64	static
adl.hpp:85:38:) const [with As = {boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>}]	176	dynamic,bounded
adl.hpp:401:39:) const [with As = {const boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2, long int> >&}]	64	static
adl.hpp:85:38:) const [with As = {boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*>}]	176	dynamic,bounded
tuple:626:19: (_Elements) >= 1)), bool>::type <anonymous> = true; _Elements = {boost::multi::extension_t<long int, long int>}]	48	static
layout.hpp:269:35:constexpr boost::multi::layout_t<1, SSize>::index_extension boost::multi::layout_t<1, SSize>::extension() const & [with SSize = long int]	64	static
adl.hpp:177:6:std::decay_t<decltype ((std::allocator_traits<_Alloc>::construct(alloc, std::addressof((* first))), first))> boost::multi::xtd::alloc_uninitialized_default_construct_n(Alloc&, ForwardIt, Size) [with Alloc = std::allocator<double>; ForwardIt = double*; Size = long int; T = double]	80	static
cpp_type_traits.h:428:5:_Iterator std::__miter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<double, 2, const double*>]	24	static
stl_algobase.h:438:5:_OI std::__copy_move_a2(_II, _II, _OI) [with bool _IsMove = false; _II = boost::multi::array_iterator<double, 2, const double*>; _OI = boost::multi::array_iterator<double, 2, double*>]	352	dynamic,bounded
stl_algobase.h:465:5:_OI std::copy(_II, _II, _OI) [with _II = boost::multi::array_iterator<std::complex<double>, 1, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >; _OI = boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>]	144	dynamic,bounded
array_ref.hpp:109:12:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::array_types(const layout_t&, const element_ptr&) [with T = std::complex<double>; long int D = 1; ElementPtr = boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<1>]	16	static
adl.hpp:446:39:) const [with As = {std::allocator<std::complex<double> >&, std::complex<double>*&, long int}]	80	static
array.hpp:78:7:auto boost::multi::static_array<T, D, Alloc>::uninitialized_default_construct() [with T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	64	static
array.hpp:210:11:boost::multi::static_array<T, D, Alloc>::static_array(typename boost::multi::static_array<T, D, Alloc>::extensions_type, const allocator_type&) [with T = std::complex<double>; long int D = 2; Alloc = std::allocator<std::complex<double> >]	160	static
numeric.hpp:152:17:constexpr auto boost::multi::blas::involuter<It, F, Reference>::operator+(boost::multi::blas::involuter<It, F, Reference>::difference_type) const [with It = std::complex<double>*; F = boost::multi::blas::conjugate; Reference = boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate>]	64	static
array_ref.hpp:760:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::end() const & [with T = std::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<std::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<2>]	112	dynamic,bounded
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >]	16	static
adl.hpp:101:48:) const [with As = {boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >, boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>}]	240	dynamic,bounded
move.h:99:5:constexpr typename std::remove_reference<_Tp>::type&& std::move(_Tp&&) [with _Tp = boost::multi::static_array<std::complex<double>, 2, std::allocator<std::complex<double> > >&]	16	static
array_ref.hpp:109:12:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::array_types(const layout_t&, const element_ptr&) [with T = std::complex<double>; long int D = 1; ElementPtr = const std::complex<double>*; Layout = boost::multi::layout_t<1>]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>]	16	static
adl.hpp:101:48:) const [with As = {boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>}]	224	dynamic,bounded
gemm.hpp:230:2:boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>::gemm_iterator(ContextPtr, Scalar, ItA, ItB) [with ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>]	24	static
adl.hpp:392:39:) const [with As = {boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&}]	80	static
gemm.hpp:283:12:boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>::reference boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>::operator*() const [with ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>]	80	static
array_ref.hpp:287:17:constexpr bool boost::multi::array_iterator<Element, D, ElementPtr>::operator==(const boost::multi::array_iterator<Element, D, ElementPtr>&) const [with Element = std::complex<double>; long int D = 2; ElementPtr = const std::complex<double>*]	32	static
array_ref.hpp:193:17:constexpr bool boost::multi::basic_array_ptr<Ref, Layout>::operator==(const boost::multi::basic_array_ptr<Ref, Layout>&) const [with Ref = boost::multi::basic_array<std::complex<double>, 1, const std::complex<double>*, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	48	static
array_ref.hpp:270:17:constexpr bool boost::multi::array_iterator<Element, D, ElementPtr>::equal(const boost::multi::array_iterator<Element, D, ElementPtr>&) const [with Element = std::complex<double>; long int D = 2; ElementPtr = const std::complex<double>*]	32	static
gemm.hpp:251:25:boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >::difference_type boost::multi::blas::operator-(const boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, const boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&)	32	static
gemm.hpp:258:14:0, d_first)) boost::multi::blas::copy_n(const boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>&, boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>::difference_type, ItOut) [with ItOut = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>; ContextPtr = boost::multi::blas::context*; Scalar = double; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>]	1056	dynamic,bounded
adl.hpp:249:39:) const [with As = {boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>&}]	96	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&]	16	static
adl.hpp:477:48:) const [with T = std::allocator<std::complex<double> >&; As = {boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>}]	352	dynamic,bounded
gemm.hpp:230:2:boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>::gemm_iterator(ContextPtr, Scalar, ItA, ItB) [with ContextPtr = boost::multi::blas::context*; Scalar = std::complex<double>; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>]	24	static
adl.hpp:392:39:) const [with As = {boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&}]	80	static
gemm.hpp:283:12:boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>::reference boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>::operator*() const [with ContextPtr = boost::multi::blas::context*; Scalar = std::complex<double>; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>]	80	static
gemm.hpp:251:25:boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >::difference_type boost::multi::blas::operator-(const boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, const boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&)	32	static
gemm.hpp:258:14:0, d_first)) boost::multi::blas::copy_n(const boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>&, boost::multi::blas::gemm_iterator<ContextPtr, Scalar, ItA, ItB>::difference_type, ItOut) [with ItOut = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>; ContextPtr = boost::multi::blas::context*; Scalar = std::complex<double>; ItA = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ItB = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>]	1056	dynamic,bounded
adl.hpp:249:39:) const [with As = {boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>&}]	96	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&]	16	static
adl.hpp:477:48:) const [with T = std::allocator<std::complex<double> >&; As = {boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>}]	368	dynamic,bounded
stl_algobase.h:280:5:_Iterator std::__niter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>]	16	static
stl_algobase.h:280:5:_Iterator std::__niter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>]	16	static
stl_algobase.h:393:5:_OI std::__copy_move_a(_II, _II, _OI) [with bool _IsMove = false; _II = boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>; _OI = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>]	96	static
stl_algobase.h:295:5:_Iterator std::__niter_wrap(const _Iterator&, _Iterator) [with _Iterator = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>]	16	static
array_ref.hpp:990:12:constexpr boost::multi::array_iterator<Element, 1, Ptr>::array_iterator(Ptr, typename boost::multi::basic_array<Element, 1, Ptr>::index) [with Element = thrust::complex<double>; Ptr = thrust::complex<double>*]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>&]	16	static
adl.hpp:244:48:constexpr decltype (std::uninitialized_copy(f, l, d)) boost::multi::adl_uninitialized_copy_fn__::_(boost::multi::priority<1>, InIt, InIt, FwdIt) const [with InIt = const thrust::complex<double>*; FwdIt = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>; <template-parameter-1-3> = thrust::complex<double>*]	64	static
new_allocator.h:119:7:void __gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer, __gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = thrust::complex<double>]	48	static
adl.hpp:388:48:) const [with As = {const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >*&, const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >*&}]	64	static
array_ref.hpp:186:12:constexpr boost::multi::basic_array_ptr<Ref, Layout>::basic_array_ptr(typename Ref::element_ptr, const Layout&) [with Ref = boost::multi::basic_array<thrust::complex<double>, 1, thrust::complex<double>*, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	48	static
array_ref.hpp:252:12:constexpr boost::multi::array_iterator<Element, D, ElementPtr>::array_iterator(typename boost::multi::basic_array<Element, (D - 1), ElementPtr>::element_ptr, boost::multi::layout_t<(D - 1), long int>, boost::multi::index) [with Element = thrust::complex<double>; long int D = 2; ElementPtr = thrust::complex<double>*]	48	static
array.hpp:441:27:constexpr boost::multi::static_array<T, D, Alloc>::const_iterator boost::multi::static_array<T, D, Alloc>::begin() const [with T = thrust::complex<double>; long int D = 1; Alloc = std::allocator<thrust::complex<double> >]	80	static
adl.hpp:408:48:) const [with T = const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >&; As = {}]	32	static
array_ref.hpp:180:20:constexpr Ref boost::multi::basic_array_ptr<Ref, Layout>::operator*() const [with Ref = boost::multi::basic_array<thrust::complex<double>, 1, thrust::complex<double>*, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::basic_array<thrust::complex<double>, 1, thrust::complex<double>*, boost::multi::layout_t<1> >]	16	static
adl.hpp:399:48:) const [with T = boost::multi::basic_array<thrust::complex<double>, 1, thrust::complex<double>*, boost::multi::layout_t<1> >; As = {}]	32	static
stl_uninitialized.h:115:5:_ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>; _ForwardIterator = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>]	96	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array_iterator<thrust::complex<double>, 2, thrust::complex<double>*>&]	16	static
adl.hpp:245:48:) const [with As = {const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >*&, const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >*&, boost::multi::array_iterator<thrust::complex<double>, 2, thrust::complex<double>*>&}]	144	dynamic,bounded
new_allocator.h:83:7:__gnu_cxx::new_allocator<_Tp>::new_allocator(const __gnu_cxx::new_allocator<_Tp>&) [with _Tp = thrust::complex<double>]	16	static
new_allocator.h:102:7:_Tp* __gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type, const void*) [with _Tp = thrust::complex<double>]	48	static
stl_uninitialized.h:782:5:_ForwardIterator std::__uninitialized_copy_n(_RandomAccessIterator, _Size, _ForwardIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = const thrust::complex<double>*; _Size = long int; _ForwardIterator = thrust::complex<double>*]	48	static
array_ref.hpp:759:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::begin() const & [with T = thrust::complex<double>; long int D = 2; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<2>]	64	dynamic,bounded
array_ref.hpp:760:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::end() const & [with T = thrust::complex<double>; long int D = 2; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<2>]	64	dynamic,bounded
adl.hpp:401:39:) const [with As = {const boost::multi::basic_array<thrust::complex<double>, 2, thrust::complex<double>*, boost::multi::layout_t<2, long int> >&}]	64	static
adl.hpp:85:38:) const [with As = {boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>, boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>, boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>}]	176	dynamic,bounded
complex.hpp:18:38:) const [with As = {const thrust::complex<double>&}]	48	static
stl_algobase.h:465:5:_OI std::copy(_II, _II, _OI) [with _II = boost::multi::array_iterator<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >; _OI = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>]	144	dynamic,bounded
array_ref.hpp:109:12:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::array_types(const layout_t&, const element_ptr&) [with T = thrust::complex<double>; long int D = 1; ElementPtr = boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<1>]	16	static
adl.hpp:446:39:) const [with As = {std::allocator<thrust::complex<double> >&, thrust::complex<double>*&, long int}]	80	static
array.hpp:78:7:auto boost::multi::static_array<T, D, Alloc>::uninitialized_default_construct() [with T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	64	static
array.hpp:210:11:boost::multi::static_array<T, D, Alloc>::static_array(typename boost::multi::static_array<T, D, Alloc>::extensions_type, const allocator_type&) [with T = thrust::complex<double>; long int D = 2; Alloc = std::allocator<thrust::complex<double> >]	160	static
numeric.hpp:152:17:constexpr auto boost::multi::blas::involuter<It, F, Reference>::operator+(boost::multi::blas::involuter<It, F, Reference>::difference_type) const [with It = thrust::complex<double>*; F = boost::multi::blas::conjugate; Reference = boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate>]	64	static
array_ref.hpp:760:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::end() const & [with T = thrust::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<2>]	112	dynamic,bounded
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = boost::multi::array_iterator<thrust::complex<double>, 2, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >]	16	static
adl.hpp:96:48:constexpr decltype (std::copy(first, last, d_first)) boost::multi::adl_copy_fn__::_(boost::multi::priority<1>, InputIt, InputIt, OutputIt) const [with InputIt = boost::multi::array_iterator<thrust::complex<double>, 2, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >; OutputIt = boost::multi::array_iterator<thrust::complex<double>, 2, thrust::complex<double>*>; <template-parameter-1-3> = void]	192	dynamic,bounded
move.h:99:5:constexpr typename std::remove_reference<_Tp>::type&& std::move(_Tp&&) [with _Tp = boost::multi::static_array<thrust::complex<double>, 2, std::allocator<thrust::complex<double> > >&]	16	static
array_ref.hpp:754:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::begin() && [with T = thrust::complex<double>; long int D = 2; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<2>]	48	static
adl.hpp:401:39:) const [with As = {const boost::multi::basic_array<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2, long int> >&}]	64	static
adl.hpp:85:38:) const [with As = {boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>, boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>, boost::multi::array_iterator<thrust::complex<double>, 2, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >}]	176	dynamic,bounded
stl_iterator_base_funcs.h:138:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = char*]	32	static
basic_string.tcc:206:7:void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator, std::forward_iterator_tag) [with _FwdIterator = char*; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]	80	static
type_traits.h:152:5:bool __gnu_cxx::__is_null_pointer(_Type*) [with _Type = const char]	16	static
stl_iterator_base_types.h:205:5:constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = const char*]	16	static
stl_iterator_base_funcs.h:98:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = const char*]	16	static
sp_counted_impl.hpp:81:14:boost::detail::sp_counted_impl_p<X>::sp_counted_impl_p(X*) [with X = boost::basic_wrap_stringstream<char>]	32	static
checked_delete.hpp:31:31:void boost::checked_delete(T*) [with T = boost::basic_wrap_stringstream<char>]	48	static
tuple:125:17:constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(const _Head&) [with long unsigned int _Idx = 1; _Head = boost::multi::extension_t<long int>]	16	static
tuple:968:19:constexpr std::tuple<_T1, _T2>::tuple(_U1&&, _U2&&) [with _U1 = boost::multi::extension_t<long int>; _U2 = const boost::multi::extension_t<long int>&; typename std::enable_if<((std::_TC<true, _T1, _T2>::_MoveConstructibleTuple<_U1, _U2>() && std::_TC<true, _T1, _T2>::_ImplicitlyMoveConvertibleTuple<_U1, _U2>()) && (! std::is_same<typename std::remove_cv<typename std::remove_reference<_SrcTuple>::type>::type, std::allocator_arg_t>::value)), bool>::type <anonymous> = true; _T1 = boost::multi::extension_t<long int>; _T2 = boost::multi::extension_t<long int>]	64	static
type_index.hpp:211:19:boost::typeindex::type_index boost::typeindex::type_id() [with T = void (*)()]	16	static
function_base.hpp:322:9:static void boost::detail::function::functor_manager<Functor>::manager(const boost::detail::function::function_buffer&, boost::detail::function::function_buffer&, boost::detail::function::functor_manager_operation_type, boost::detail::function::function_ptr_tag) [with Functor = void (*)()]	48	static
function_template.hpp:512:9:bool boost::detail::function::basic_vtable0<R>::assign_to(FunctionPtr, boost::detail::function::function_buffer&, boost::detail::function::function_ptr_tag) const [with FunctionPtr = void (*)(); R = void]	48	static
fpc_tolerance.hpp:52:5:boost::test_tools::local_fpc_tolerance<FPT>::~local_fpc_tolerance() [with FPT = double]	32	static
sp_counted_impl.hpp:81:14:boost::detail::sp_counted_impl_p<X>::sp_counted_impl_p(X*) [with X = boost::unit_test::class_based_fixture<boost::test_tools::local_fpc_tolerance<double>, double>]	32	static
fixture.hpp:128:7:boost::unit_test::class_based_fixture<boost::test_tools::local_fpc_tolerance<double>, double>::~class_based_fixture()	32	static
fixture.hpp:128:7:virtual boost::unit_test::class_based_fixture<boost::test_tools::local_fpc_tolerance<double>, double>::~class_based_fixture()	32	static
checked_delete.hpp:31:31:void boost::checked_delete(T*) [with T = boost::unit_test::class_based_fixture<boost::test_tools::local_fpc_tolerance<double>, double>]	32	static
array_ref.hpp:1012:28:constexpr boost::multi::array_iterator<Element, 1, Ptr>::difference_type boost::multi::array_iterator<Element, 1, Ptr>::operator-(const boost::multi::array_iterator<Element, 1, Ptr>&) const [with Element = double; Ptr = const double*]	32	static
array_ref.hpp:995:28:constexpr boost::multi::array_iterator<Element, 1, Ptr>::difference_type boost::multi::array_iterator<Element, 1, Ptr>::distance_to(const boost::multi::array_iterator<Element, 1, Ptr>&) const [with Element = double; Ptr = const double*]	32	static
array_ref.hpp:1007:28:constexpr boost::multi::array_iterator<Element, 1, Ptr>& boost::multi::array_iterator<Element, 1, Ptr>::operator++() [with Element = double; Ptr = const double*]	16	static
array_ref.hpp:1007:28:constexpr boost::multi::array_iterator<Element, 1, Ptr>& boost::multi::array_iterator<Element, 1, Ptr>::operator++() [with Element = double; Ptr = double*]	16	static
stl_algobase.h:337:2:static _OI std::__copy_move<false, false, std::random_access_iterator_tag>::__copy_m(_II, _II, _OI) [with _II = boost::multi::array_iterator<double, 1, const double*>; _OI = boost::multi::array_iterator<double, 1, double*>]	96	static
new_allocator.h:132:7:__gnu_cxx::new_allocator<_Tp>::size_type __gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = double]	16	static
stl_uninitialized.h:99:9:static _ForwardIterator std::__uninitialized_copy<true>::__uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = const double*; _ForwardIterator = boost::multi::array_iterator<double, 1, double*>]	48	static
stl_iterator_base_funcs.h:138:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = const boost::multi::array<double, 1, std::allocator<double> >*]	32	static
array_ref.hpp:1267:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::begin() && [with T = double; ElementPtr = double*; Layout = boost::multi::layout_t<1>]	32	static
array_ref.hpp:980:12:constexpr boost::multi::array_iterator<Element, 1, Ptr>::array_iterator(const boost::multi::array_iterator<EElement, 1, PPtr>&) [with EElement = double; PPtr = double*; <template-parameter-2-3> = const double*; Element = double; Ptr = const double*]	16	static
array.hpp:442:27:constexpr boost::multi::static_array<T, D, Alloc>::const_iterator boost::multi::static_array<T, D, Alloc>::end() const [with T = double; long int D = 1; Alloc = std::allocator<double>]	80	static
stl_uninitialized.h:99:9:static _ForwardIterator std::__uninitialized_copy<true>::__uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = boost::multi::array_iterator<double, 1, const double*>; _ForwardIterator = boost::multi::array_iterator<double, 1, double*>]	80	static
stl_uninitialized.h:115:5:_ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = const double*; _ForwardIterator = double*]	64	static
fpc_op.hpp:80:1:boost::test_tools::assertion_result boost::test_tools::assertion::op::compare_fpv_near_zero(const FPT&, boost::test_tools::assertion::op::EQ<Lhs, Rhs>*) [with FPT = double; Lhs = double; Rhs = double]	96	static
floating_point_comparison.hpp:233:17:boost::math::fpc::close_at_tolerance<FPT>::close_at_tolerance(ToleranceType, boost::math::fpc::strength) [with ToleranceType = double; FPT = double]	48	static
stl_algobase.h:222:5:constexpr const _Tp& std::max(const _Tp&, const _Tp&) [with _Tp = double]	16	static
stl_algobase.h:198:5:constexpr const _Tp& std::min(const _Tp&, const _Tp&) [with _Tp = double]	16	static
floating_point_comparison.hpp:262:25:bool boost::math::fpc::close_at_tolerance<FPT>::operator()(FPT, FPT) const [with FPT = double]	96	static
wrap_stringstream.hpp:64:1:boost::basic_wrap_stringstream<CharT>& boost::operator<<(boost::basic_wrap_stringstream<CharT>&, const T&) [with CharT = char; T = char [40]]	32	static
floating_point_comparison.hpp:249:25:FPT boost::math::fpc::close_at_tolerance<FPT>::tested_rel_diff() const [with FPT = double]	16	static
wrap_stringstream.hpp:64:1:boost::basic_wrap_stringstream<CharT>& boost::operator<<(boost::basic_wrap_stringstream<CharT>&, const T&) [with CharT = char; T = double]	32	static
wrap_stringstream.hpp:64:1:boost::basic_wrap_stringstream<CharT>& boost::operator<<(boost::basic_wrap_stringstream<CharT>&, const T&) [with CharT = char; T = char [4]]	32	static
floating_point_comparison.hpp:243:25:FPT boost::math::fpc::close_at_tolerance<FPT>::fraction_tolerance() const [with FPT = double]	16	static
shared_ptr.hpp:634:5:boost::shared_ptr<T>::shared_ptr(boost::shared_ptr<T>&&) [with T = boost::basic_wrap_stringstream<char>]	32	static
print_helper.hpp:188:17:boost::test_tools::tt_detail::print_helper_t<T>::print_helper_t(const T&) [with T = double]	16	static
print_helper.hpp:83:13:void boost::test_tools::tt_detail::print_log_value<T>::operator()(std::ostream&, const T&) [with T = double]	80	static
array_ref.hpp:750:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::end() & [with T = double; long int D = 2; ElementPtr = double*; Layout = boost::multi::layout_t<2>]	64	dynamic,bounded
adl.hpp:387:48:) const [with As = {boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >&}]	256	dynamic,bounded
gemm.hpp:220:13:const Ext& boost::multi::blas::gemm_reference<Ext>::extensions() const [with Ext = boost::multi::extensions_t<1>]	16	static
array_ref.hpp:96:28:constexpr const layout_t& boost::multi::array_types<T, D, ElementPtr, Layout>::layout() const [with T = double; long int D = 1; ElementPtr = const double*; Layout = boost::multi::layout_t<1>]	16	static
layout.hpp:287:17:constexpr bool boost::multi::layout_t<1, SSize>::operator==(const boost::multi::layout_t<1, SSize>&) const [with SSize = long int]	16	static
array_ref.hpp:288:35:constexpr boost::multi::array_iterator<double, 2, const double*>::difference_type boost::multi::operator-(const boost::multi::array_iterator<double, 2, const double*>&, const boost::multi::array_iterator<double, 2, const double*>&)	32	static
array_ref.hpp:281:31:constexpr boost::multi::array_iterator<Element, D, ElementPtr>::element_ptr boost::multi::array_iterator<Element, D, ElementPtr>::base() const & [with Element = double; long int D = 2; ElementPtr = const double*]	16	static
array_ref.hpp:281:31:constexpr boost::multi::array_iterator<Element, D, ElementPtr>::element_ptr boost::multi::array_iterator<Element, D, ElementPtr>::base() const & [with Element = double; long int D = 2; ElementPtr = double*]	16	static
core.hpp:480:10:boost::multi::blas::core::gemm(char, char, ssize_t, ssize_t, ssize_t, const ALPHA*, AAP, ssize_t, BBP, ssize_t, const BETA*, CCP, ssize_t) [with ALPHA = double; AAP = const double*; AA = const double; BBP = const double*; BB = const double; BETA = double; CCP = double*; CC = double; typename std::enable_if<((((((boost::multi::blas::is_d<SX>{} && boost::multi::blas::is_d<SY>{}) && boost::multi::blas::is_d<CC>{}) && std::is_assignable<CC&, decltype (((ALPHA{} * AA{}) * BB{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>) && is_convertible_v<CCP, CC*>), int>::type <anonymous> = 0]::<lambda(auto:125)> [with auto:125 = long int]	32	static
core.hpp:480:10:boost::multi::blas::core::gemm(char, char, ssize_t, ssize_t, ssize_t, const ALPHA*, AAP, ssize_t, BBP, ssize_t, const BETA*, CCP, ssize_t) [with ALPHA = double; AAP = const double*; AA = const double; BBP = const double*; BB = const double; BETA = double; CCP = double*; CC = double; typename std::enable_if<((((((boost::multi::blas::is_d<SX>{} && boost::multi::blas::is_d<SY>{}) && boost::multi::blas::is_d<CC>{}) && std::is_assignable<CC&, decltype (((ALPHA{} * AA{}) * BB{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>) && is_convertible_v<CCP, CC*>), int>::type <anonymous> = 0]::<lambda(auto:126)> [with auto:126 = long int]	32	static
core.hpp:480:10:boost::multi::blas::core::gemm(char, char, ssize_t, ssize_t, ssize_t, const ALPHA*, AAP, ssize_t, BBP, ssize_t, const BETA*, CCP, ssize_t) [with ALPHA = double; AAP = const double*; AA = const double; BBP = const double*; BB = const double; BETA = double; CCP = double*; CC = double; typename std::enable_if<((((((boost::multi::blas::is_d<SX>{} && boost::multi::blas::is_d<SY>{}) && boost::multi::blas::is_d<CC>{}) && std::is_assignable<CC&, decltype (((ALPHA{} * AA{}) * BB{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>) && is_convertible_v<CCP, CC*>), int>::type <anonymous> = 0]::<lambda(auto:127)> [with auto:127 = long int]	32	static
core.hpp:480:10:boost::multi::blas::core::gemm(char, char, ssize_t, ssize_t, ssize_t, const ALPHA*, AAP, ssize_t, BBP, ssize_t, const BETA*, CCP, ssize_t) [with ALPHA = double; AAP = const double*; AA = const double; BBP = const double*; BB = const double; BETA = double; CCP = double*; CC = double; typename std::enable_if<((((((boost::multi::blas::is_d<SX>{} && boost::multi::blas::is_d<SY>{}) && boost::multi::blas::is_d<CC>{}) && std::is_assignable<CC&, decltype (((ALPHA{} * AA{}) * BB{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>) && is_convertible_v<CCP, CC*>), int>::type <anonymous> = 0]::<lambda(auto:128)> [with auto:128 = long int]	32	static
core.hpp:480:10:boost::multi::blas::core::gemm(char, char, ssize_t, ssize_t, ssize_t, const ALPHA*, AAP, ssize_t, BBP, ssize_t, const BETA*, CCP, ssize_t) [with ALPHA = double; AAP = const double*; AA = const double; BBP = const double*; BB = const double; BETA = double; CCP = double*; CC = double; typename std::enable_if<((((((boost::multi::blas::is_d<SX>{} && boost::multi::blas::is_d<SY>{}) && boost::multi::blas::is_d<CC>{}) && std::is_assignable<CC&, decltype (((ALPHA{} * AA{}) * BB{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>) && is_convertible_v<CCP, CC*>), int>::type <anonymous> = 0]::<lambda(auto:129)> [with auto:129 = long int]	32	static
core.hpp:480:10:boost::multi::blas::core::gemm(char, char, ssize_t, ssize_t, ssize_t, const ALPHA*, AAP, ssize_t, BBP, ssize_t, const BETA*, CCP, ssize_t) [with ALPHA = double; AAP = const double*; AA = const double; BBP = const double*; BB = const double; BETA = double; CCP = double*; CC = double; typename std::enable_if<((((((boost::multi::blas::is_d<SX>{} && boost::multi::blas::is_d<SY>{}) && boost::multi::blas::is_d<CC>{}) && std::is_assignable<CC&, decltype (((ALPHA{} * AA{}) * BB{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>) && is_convertible_v<CCP, CC*>), int>::type <anonymous> = 0]::<lambda(auto:130)> [with auto:130 = long int]	32	static
core.hpp:480:10:boost::multi::blas::{anonymous}::v boost::multi::blas::core::gemm(char, char, ssize_t, ssize_t, ssize_t, const ALPHA*, AAP, ssize_t, BBP, ssize_t, const BETA*, CCP, ssize_t) [with ALPHA = double; AAP = const double*; AA = const double; BBP = const double*; BB = const double; BETA = double; CCP = double*; CC = double; typename std::enable_if<((((((boost::multi::blas::is_d<SX>{} && boost::multi::blas::is_d<SY>{}) && boost::multi::blas::is_d<CC>{}) && std::is_assignable<CC&, decltype (((ALPHA{} * AA{}) * BB{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>) && is_convertible_v<CCP, CC*>), int>::type <anonymous> = 0]	448	dynamic,bounded
array_ref.hpp:272:17:constexpr void boost::multi::array_iterator<Element, D, ElementPtr>::advance(boost::multi::array_iterator<Element, D, ElementPtr>::difference_type) [with Element = double; long int D = 2; ElementPtr = double*]	16	static
adl.hpp:245:48:) const [with As = {boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >&, boost::multi::array_iterator<double, 2, double*>&}]	144	dynamic,bounded
array_ref.hpp:1012:28:constexpr boost::multi::array_iterator<Element, 1, Ptr>::difference_type boost::multi::array_iterator<Element, 1, Ptr>::operator-(const boost::multi::array_iterator<Element, 1, Ptr>&) const [with Element = std::complex<double>; Ptr = const std::complex<double>*]	32	static
array_ref.hpp:995:28:constexpr boost::multi::array_iterator<Element, 1, Ptr>::difference_type boost::multi::array_iterator<Element, 1, Ptr>::distance_to(const boost::multi::array_iterator<Element, 1, Ptr>&) const [with Element = std::complex<double>; Ptr = const std::complex<double>*]	32	static
array_ref.hpp:1007:28:constexpr boost::multi::array_iterator<Element, 1, Ptr>& boost::multi::array_iterator<Element, 1, Ptr>::operator++() [with Element = std::complex<double>; Ptr = const std::complex<double>*]	16	static
array_ref.hpp:1007:28:constexpr boost::multi::array_iterator<Element, 1, Ptr>& boost::multi::array_iterator<Element, 1, Ptr>::operator++() [with Element = std::complex<double>; Ptr = std::complex<double>*]	16	static
stl_algobase.h:337:2:static _OI std::__copy_move<false, false, std::random_access_iterator_tag>::__copy_m(_II, _II, _OI) [with _II = boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>; _OI = boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>]	96	static
stl_iterator_base_funcs.h:138:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >*]	32	static
array_ref.hpp:1267:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::begin() && [with T = std::complex<double>; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<1>]	32	static
array_ref.hpp:980:12:constexpr boost::multi::array_iterator<Element, 1, Ptr>::array_iterator(const boost::multi::array_iterator<EElement, 1, PPtr>&) [with EElement = std::complex<double>; PPtr = std::complex<double>*; <template-parameter-2-3> = const std::complex<double>*; Element = std::complex<double>; Ptr = const std::complex<double>*]	16	static
array.hpp:442:27:constexpr boost::multi::static_array<T, D, Alloc>::const_iterator boost::multi::static_array<T, D, Alloc>::end() const [with T = std::complex<double>; long int D = 1; Alloc = std::allocator<std::complex<double> >]	80	static
stl_uninitialized.h:76:9:static _ForwardIterator std::__uninitialized_copy<_TrivialValueTypes>::__uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>; _ForwardIterator = boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>; bool _TrivialValueTypes = false]	112	static
new_allocator.h:132:7:__gnu_cxx::new_allocator<_Tp>::size_type __gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = std::complex<double>]	16	static
stl_uninitialized.h:76:9:static _ForwardIterator std::__uninitialized_copy<_TrivialValueTypes>::__uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = const std::complex<double>*; _ForwardIterator = boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>; bool _TrivialValueTypes = false]	80	static
stl_uninitialized.h:115:5:_ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = const std::complex<double>*; _ForwardIterator = std::complex<double>*]	64	static
array_ref.hpp:750:28:constexpr boost::multi::basic_array<T, D, ElementPtr, Layout>::iterator boost::multi::basic_array<T, D, ElementPtr, Layout>::end() & [with T = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<2>]	64	dynamic,bounded
adl.hpp:388:48:) const [with As = {boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >&}]	272	dynamic,bounded
numeric.hpp:149:7:bool boost::multi::blas::involuter<It, F, Reference>::operator==(const boost::multi::blas::involuter<It, F, Reference>&) const [with It = const std::complex<double>*; F = boost::multi::blas::conjugate; Reference = boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate>]	16	static
array_ref.hpp:96:28:constexpr const layout_t& boost::multi::array_types<T, D, ElementPtr, Layout>::layout() const [with T = std::complex<double>; long int D = 1; ElementPtr = boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<1>]	16	static
array_ref.hpp:288:35:constexpr boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>::difference_type boost::multi::operator-(const boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>&, const boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>&)	32	static
array_ref.hpp:281:31:constexpr boost::multi::array_iterator<Element, D, ElementPtr>::element_ptr boost::multi::array_iterator<Element, D, ElementPtr>::base() const & [with Element = std::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >]	16	static
array_ref.hpp:281:31:constexpr boost::multi::array_iterator<Element, D, ElementPtr>::element_ptr boost::multi::array_iterator<Element, D, ElementPtr>::base() const & [with Element = std::complex<double>; long int D = 2; ElementPtr = const std::complex<double>*]	16	static
array_ref.hpp:281:31:constexpr boost::multi::array_iterator<Element, D, ElementPtr>::element_ptr boost::multi::array_iterator<Element, D, ElementPtr>::base() const & [with Element = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*]	16	static
complex:486:5:constexpr bool std::operator!=(const std::complex<_Tp>&, const _Tp&) [with _Tp = double]	32	static
core.hpp:480:28:boost::multi::blas::core::gemm(char, char, ssize_t, ssize_t, ssize_t, const ALPHA*, AAP, ssize_t, BBP, ssize_t, const BETA*, CCP, ssize_t) [with ALPHA = std::complex<double>; AAP = const std::complex<double>*; AA = const std::complex<double>; BBP = const std::complex<double>*; BB = const std::complex<double>; BETA = std::complex<double>; CCP = std::complex<double>*; CC = std::complex<double>; typename std::enable_if<((((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && boost::multi::blas::is_z<CC>{}) && std::is_assignable<CC&, decltype (((ALPHA{} * AA{}) * BB{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>) && is_convertible_v<CCP, CC*>), int>::type <anonymous> = 0]::<lambda(auto:137)> [with auto:137 = long int]	32	static
core.hpp:480:28:boost::multi::blas::core::gemm(char, char, ssize_t, ssize_t, ssize_t, const ALPHA*, AAP, ssize_t, BBP, ssize_t, const BETA*, CCP, ssize_t) [with ALPHA = std::complex<double>; AAP = const std::complex<double>*; AA = const std::complex<double>; BBP = const std::complex<double>*; BB = const std::complex<double>; BETA = std::complex<double>; CCP = std::complex<double>*; CC = std::complex<double>; typename std::enable_if<((((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && boost::multi::blas::is_z<CC>{}) && std::is_assignable<CC&, decltype (((ALPHA{} * AA{}) * BB{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>) && is_convertible_v<CCP, CC*>), int>::type <anonymous> = 0]::<lambda(auto:138)> [with auto:138 = long int]	32	static
core.hpp:480:28:boost::multi::blas::core::gemm(char, char, ssize_t, ssize_t, ssize_t, const ALPHA*, AAP, ssize_t, BBP, ssize_t, const BETA*, CCP, ssize_t) [with ALPHA = std::complex<double>; AAP = const std::complex<double>*; AA = const std::complex<double>; BBP = const std::complex<double>*; BB = const std::complex<double>; BETA = std::complex<double>; CCP = std::complex<double>*; CC = std::complex<double>; typename std::enable_if<((((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && boost::multi::blas::is_z<CC>{}) && std::is_assignable<CC&, decltype (((ALPHA{} * AA{}) * BB{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>) && is_convertible_v<CCP, CC*>), int>::type <anonymous> = 0]::<lambda(auto:139)> [with auto:139 = long int]	32	static
core.hpp:480:28:boost::multi::blas::core::gemm(char, char, ssize_t, ssize_t, ssize_t, const ALPHA*, AAP, ssize_t, BBP, ssize_t, const BETA*, CCP, ssize_t) [with ALPHA = std::complex<double>; AAP = const std::complex<double>*; AA = const std::complex<double>; BBP = const std::complex<double>*; BB = const std::complex<double>; BETA = std::complex<double>; CCP = std::complex<double>*; CC = std::complex<double>; typename std::enable_if<((((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && boost::multi::blas::is_z<CC>{}) && std::is_assignable<CC&, decltype (((ALPHA{} * AA{}) * BB{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>) && is_convertible_v<CCP, CC*>), int>::type <anonymous> = 0]::<lambda(auto:140)> [with auto:140 = long int]	32	static
core.hpp:480:28:boost::multi::blas::core::gemm(char, char, ssize_t, ssize_t, ssize_t, const ALPHA*, AAP, ssize_t, BBP, ssize_t, const BETA*, CCP, ssize_t) [with ALPHA = std::complex<double>; AAP = const std::complex<double>*; AA = const std::complex<double>; BBP = const std::complex<double>*; BB = const std::complex<double>; BETA = std::complex<double>; CCP = std::complex<double>*; CC = std::complex<double>; typename std::enable_if<((((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && boost::multi::blas::is_z<CC>{}) && std::is_assignable<CC&, decltype (((ALPHA{} * AA{}) * BB{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>) && is_convertible_v<CCP, CC*>), int>::type <anonymous> = 0]::<lambda(auto:141)> [with auto:141 = long int]	32	static
core.hpp:480:28:boost::multi::blas::core::gemm(char, char, ssize_t, ssize_t, ssize_t, const ALPHA*, AAP, ssize_t, BBP, ssize_t, const BETA*, CCP, ssize_t) [with ALPHA = std::complex<double>; AAP = const std::complex<double>*; AA = const std::complex<double>; BBP = const std::complex<double>*; BB = const std::complex<double>; BETA = std::complex<double>; CCP = std::complex<double>*; CC = std::complex<double>; typename std::enable_if<((((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && boost::multi::blas::is_z<CC>{}) && std::is_assignable<CC&, decltype (((ALPHA{} * AA{}) * BB{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>) && is_convertible_v<CCP, CC*>), int>::type <anonymous> = 0]::<lambda(auto:142)> [with auto:142 = long int]	32	static
core.hpp:480:28:boost::multi::blas::{anonymous}::v boost::multi::blas::core::gemm(char, char, ssize_t, ssize_t, ssize_t, const ALPHA*, AAP, ssize_t, BBP, ssize_t, const BETA*, CCP, ssize_t) [with ALPHA = std::complex<double>; AAP = const std::complex<double>*; AA = const std::complex<double>; BBP = const std::complex<double>*; BB = const std::complex<double>; BETA = std::complex<double>; CCP = std::complex<double>*; CC = std::complex<double>; typename std::enable_if<((((((boost::multi::blas::is_z<SX>{} && boost::multi::blas::is_z<SY>{}) && boost::multi::blas::is_z<CC>{}) && std::is_assignable<CC&, decltype (((ALPHA{} * AA{}) * BB{}))>{}) && is_convertible_v<AAP, AA*>) && is_convertible_v<BBP, BB*>) && is_convertible_v<CCP, CC*>), int>::type <anonymous> = 0]	448	dynamic,bounded
array_ref.hpp:272:17:constexpr void boost::multi::array_iterator<Element, D, ElementPtr>::advance(boost::multi::array_iterator<Element, D, ElementPtr>::difference_type) [with Element = std::complex<double>; long int D = 2; ElementPtr = std::complex<double>*]	16	static
adl.hpp:245:48:) const [with As = {boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >&, boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>&}]	144	dynamic,bounded
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::basic_array<std::complex<double>, 2, std::complex<double>*, boost::multi::layout_t<2> >&]	16	static
adl.hpp:399:48:) const [with T = const boost::multi::basic_array<std::complex<double>, 2, std::complex<double>*, boost::multi::layout_t<2> >&; As = {}]	64	static
adl.hpp:81:47:) const [with As = {boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>}]	160	dynamic,bounded
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >&]	16	static
adl.hpp:399:48:) const [with T = const boost::multi::basic_array<double, 2, double*, boost::multi::layout_t<2> >&; As = {}]	64	static
adl.hpp:76:47:) const [with As = {boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*>}]	160	dynamic,bounded
tuple:348:19:constexpr std::_Tuple_impl<_Idx, _Head>::_Tuple_impl(_UHead&&) [with _UHead = boost::multi::extension_t<long int>; long unsigned int _Idx = 0; _Head = boost::multi::extension_t<long int>]	48	static
stl_iterator_base_funcs.h:202:5:constexpr void std::advance(_InputIterator&, _Distance) [with _InputIterator = double*; _Distance = long int]	48	static
move.h:138:5:constexpr _Tp* std::addressof(_Tp&) [with _Tp = double]	32	static
alloc_traits.h:482:2:) [with _Up = double; _Args = {}; _Tp = double]	32	static
stl_algobase.h:280:5:_Iterator std::__niter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<double, 2, const double*>]	24	static
stl_algobase.h:280:5:_Iterator std::__niter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<double, 2, double*>]	24	static
stl_algobase.h:393:5:_OI std::__copy_move_a(_II, _II, _OI) [with bool _IsMove = false; _II = boost::multi::array_iterator<double, 2, const double*>; _OI = boost::multi::array_iterator<double, 2, double*>]	176	dynamic,bounded
stl_algobase.h:295:5:_Iterator std::__niter_wrap(const _Iterator&, _Iterator) [with _Iterator = boost::multi::array_iterator<double, 2, double*>]	24	static
cpp_type_traits.h:428:5:_Iterator std::__miter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<std::complex<double>, 1, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >]	16	static
stl_algobase.h:438:5:_OI std::__copy_move_a2(_II, _II, _OI) [with bool _IsMove = false; _II = boost::multi::array_iterator<std::complex<double>, 1, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >; _OI = boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>]	176	dynamic,bounded
adl.hpp:441:48:) const [with As = {std::allocator<std::complex<double> >&, std::complex<double>*&, long int}]	64	static
stl_algobase.h:465:5:_OI std::copy(_II, _II, _OI) [with _II = boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >; _OI = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>]	288	dynamic,bounded
stl_algobase.h:465:5:_OI std::copy(_II, _II, _OI) [with _II = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; _OI = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>]	256	dynamic,bounded
adl.hpp:388:48:) const [with As = {boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&}]	256	dynamic,bounded
array_ref.hpp:96:28:constexpr const layout_t& boost::multi::array_types<T, D, ElementPtr, Layout>::layout() const [with T = std::complex<double>; long int D = 1; ElementPtr = const std::complex<double>*; Layout = boost::multi::layout_t<1>]	16	static
adl.hpp:245:48:) const [with As = {boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>&}]	144	dynamic,bounded
adl.hpp:388:48:) const [with As = {boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&}]	272	dynamic,bounded
adl.hpp:245:48:) const [with As = {boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >&, boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>&}]	144	dynamic,bounded
array_ref.hpp:1012:28:constexpr boost::multi::array_iterator<Element, 1, Ptr>::difference_type boost::multi::array_iterator<Element, 1, Ptr>::operator-(const boost::multi::array_iterator<Element, 1, Ptr>&) const [with Element = thrust::complex<double>; Ptr = const thrust::complex<double>*]	32	static
array_ref.hpp:995:28:constexpr boost::multi::array_iterator<Element, 1, Ptr>::difference_type boost::multi::array_iterator<Element, 1, Ptr>::distance_to(const boost::multi::array_iterator<Element, 1, Ptr>&) const [with Element = thrust::complex<double>; Ptr = const thrust::complex<double>*]	32	static
array_ref.hpp:1007:28:constexpr boost::multi::array_iterator<Element, 1, Ptr>& boost::multi::array_iterator<Element, 1, Ptr>::operator++() [with Element = thrust::complex<double>; Ptr = const thrust::complex<double>*]	16	static
array_ref.hpp:1007:28:constexpr boost::multi::array_iterator<Element, 1, Ptr>& boost::multi::array_iterator<Element, 1, Ptr>::operator++() [with Element = thrust::complex<double>; Ptr = thrust::complex<double>*]	16	static
stl_algobase.h:337:2:static _OI std::__copy_move<false, false, std::random_access_iterator_tag>::__copy_m(_II, _II, _OI) [with _II = boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>; _OI = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>]	96	static
stl_uninitialized.h:115:5:_ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = const thrust::complex<double>*; _ForwardIterator = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>]	64	static
stl_iterator_base_funcs.h:138:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >*]	32	static
array_ref.hpp:1267:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::begin() && [with T = thrust::complex<double>; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<1>]	32	static
array_ref.hpp:980:12:constexpr boost::multi::array_iterator<Element, 1, Ptr>::array_iterator(const boost::multi::array_iterator<EElement, 1, PPtr>&) [with EElement = thrust::complex<double>; PPtr = thrust::complex<double>*; <template-parameter-2-3> = const thrust::complex<double>*; Element = thrust::complex<double>; Ptr = const thrust::complex<double>*]	16	static
array.hpp:442:27:constexpr boost::multi::static_array<T, D, Alloc>::const_iterator boost::multi::static_array<T, D, Alloc>::end() const [with T = thrust::complex<double>; long int D = 1; Alloc = std::allocator<thrust::complex<double> >]	80	static
stl_uninitialized.h:99:9:static _ForwardIterator std::__uninitialized_copy<true>::__uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>; _ForwardIterator = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>]	80	static
new_allocator.h:132:7:__gnu_cxx::new_allocator<_Tp>::size_type __gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = thrust::complex<double>]	16	static
stl_uninitialized.h:115:5:_ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = const thrust::complex<double>*; _ForwardIterator = thrust::complex<double>*]	64	static
array_ref.hpp:1077:15:constexpr boost::multi::basic_array<thrust::complex<double>, 1, const thrust::complex<double>*, boost::multi::layout_t<1> >::basic_array(const layout_t&, const thrust::complex<double>* const&) [inherited from boost::multi::array_types<thrust::complex<double>, 1, const thrust::complex<double>*, boost::multi::layout_t<1> >]	48	static
array_ref.hpp:186:12:constexpr boost::multi::basic_array_ptr<Ref, Layout>::basic_array_ptr(typename Ref::element_ptr, const Layout&) [with Ref = boost::multi::basic_array<thrust::complex<double>, 1, const thrust::complex<double>*, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	48	static
array_ref.hpp:252:12:constexpr boost::multi::array_iterator<Element, D, ElementPtr>::array_iterator(typename boost::multi::basic_array<Element, (D - 1), ElementPtr>::element_ptr, boost::multi::layout_t<(D - 1), long int>, boost::multi::index) [with Element = thrust::complex<double>; long int D = 2; ElementPtr = const thrust::complex<double>*]	48	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::basic_array<thrust::complex<double>, 2, thrust::complex<double>*, boost::multi::layout_t<2> >&]	16	static
adl.hpp:399:48:) const [with T = const boost::multi::basic_array<thrust::complex<double>, 2, thrust::complex<double>*, boost::multi::layout_t<2> >&; As = {}]	64	static
adl.hpp:76:47:) const [with As = {boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>, boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>, boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>}]	160	dynamic,bounded
cpp_type_traits.h:428:5:_Iterator std::__miter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >]	16	static
stl_algobase.h:438:5:_OI std::__copy_move_a2(_II, _II, _OI) [with bool _IsMove = false; _II = boost::multi::array_iterator<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >; _OI = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>]	176	dynamic,bounded
adl.hpp:441:48:) const [with As = {std::allocator<thrust::complex<double> >&, thrust::complex<double>*&, long int}]	64	static
stl_algobase.h:465:5:_OI std::copy(_II, _II, _OI) [with _II = boost::multi::array_iterator<thrust::complex<double>, 2, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >; _OI = boost::multi::array_iterator<thrust::complex<double>, 2, thrust::complex<double>*>]	288	dynamic,bounded
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::basic_array<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >&]	16	static
adl.hpp:399:48:) const [with T = const boost::multi::basic_array<thrust::complex<double>, 2, boost::multi::blas::involuter<thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<2> >&; As = {}]	64	static
adl.hpp:76:47:) const [with As = {boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>, boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>, boost::multi::array_iterator<thrust::complex<double>, 2, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >}]	160	dynamic,bounded
type_traits.h:152:5:bool __gnu_cxx::__is_null_pointer(_Type*) [with _Type = char]	16	static
stl_iterator_base_types.h:205:5:constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = char*]	16	static
stl_iterator_base_funcs.h:98:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = char*]	16	static
tuple:216:19:) [with _UHead = boost::multi::extension_t<long int>; _UTail = {const boost::multi::extension_t<long int, long int>&}; <template-parameter-2-3> = void; long unsigned int _Idx = 0; _Head = boost::multi::extension_t<long int>; _Tail = {boost::multi::extension_t<long int, long int>}]	64	static
stl_type_index.hpp:226:23:static boost::typeindex::stl_type_index boost::typeindex::stl_type_index::type_id() [with T = void (*)()]	32	static
function_base.hpp:259:9:static void boost::detail::function::functor_manager_common<Functor>::manage_ptr(const boost::detail::function::function_buffer&, boost::detail::function::function_buffer&, boost::detail::function::functor_manager_operation_type) [with Functor = void (*)()]	64	static
array_ref.hpp:1011:69:constexpr typename std::iterator_traits<_II>::reference boost::multi::array_iterator<Element, 1, Ptr>::operator*() const [with Element = double; Ptr = double*]	16	static
array_ref.hpp:1011:69:constexpr typename std::iterator_traits<_II>::reference boost::multi::array_iterator<Element, 1, Ptr>::operator*() const [with Element = double; Ptr = const double*]	16	static
stl_algobase.h:465:5:_OI std::copy(_II, _II, _OI) [with _II = const double*; _OI = boost::multi::array_iterator<double, 1, double*>]	64	static
stl_iterator_base_types.h:205:5:constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = const boost::multi::array<double, 1, std::allocator<double> >*]	16	static
stl_iterator_base_funcs.h:98:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = const boost::multi::array<double, 1, std::allocator<double> >*]	16	static
array_ref.hpp:1271:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::end() && [with T = double; ElementPtr = double*; Layout = boost::multi::layout_t<1>]	32	static
stl_uninitialized.h:99:9:static _ForwardIterator std::__uninitialized_copy<true>::__uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = const double*; _ForwardIterator = double*]	48	static
floating_point_comparison.hpp:300:17:boost::math::fpc::small_with_tolerance<FPT>::small_with_tolerance(FPT) [with FPT = double]	32	static
floating_point_comparison.hpp:307:17:bool boost::math::fpc::small_with_tolerance<FPT>::operator()(FPT) const [with FPT = double]	32	static
wrap_stringstream.hpp:64:1:boost::basic_wrap_stringstream<CharT>& boost::operator<<(boost::basic_wrap_stringstream<CharT>&, const T&) [with CharT = char; T = char [5]]	32	static
floating_point_comparison.hpp:193:1:FPT boost::math::fpc::fpc_detail::fraction_tolerance(ToleranceType) [with FPT = double; ToleranceType = double]	16	static
floating_point_comparison.hpp:142:1:FPT boost::math::fpc::fpc_detail::fpt_abs(FPT) [with FPT = double]	16	static
floating_point_comparison.hpp:175:1:FPT boost::math::fpc::fpc_detail::safe_fpt_division(FPT, FPT) [with FPT = double]	32	static
print_helper.hpp:97:21:std::streamsize boost::test_tools::tt_detail::print_log_value<T>::set_precision(std::ostream&, mpl_::false_) [with T = double]	32	static
print_helper.hpp:61:27:std::ostream& boost::test_tools::tt_detail::impl::boost_test_print_type_impl::operator()(std::ostream&, const R&) const [with R = double]	48	static
stl_iterator_base_funcs.h:138:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >]	208	dynamic,bounded
array_ref.hpp:1011:69:constexpr typename std::iterator_traits<_II>::reference boost::multi::array_iterator<Element, 1, Ptr>::operator*() const [with Element = std::complex<double>; Ptr = std::complex<double>*]	16	static
array_ref.hpp:1011:69:constexpr typename std::iterator_traits<_II>::reference boost::multi::array_iterator<Element, 1, Ptr>::operator*() const [with Element = std::complex<double>; Ptr = const std::complex<double>*]	16	static
stl_iterator_base_types.h:205:5:constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >*]	16	static
stl_iterator_base_funcs.h:98:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = const boost::multi::array<std::complex<double>, 1, std::allocator<std::complex<double> > >*]	16	static
array_ref.hpp:1271:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::end() && [with T = std::complex<double>; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<1>]	32	static
array_ref.hpp:1010:17:constexpr bool boost::multi::array_iterator<Element, 1, Ptr>::operator!=(const boost::multi::array_iterator<Element, 1, Ptr>&) const [with Element = std::complex<double>; Ptr = const std::complex<double>*]	16	static
move.h:47:5:constexpr _Tp* std::__addressof(_Tp&) [with _Tp = std::complex<double>]	16	static
stl_construct.h:74:5:) [with _T1 = std::complex<double>; _Args = {const std::complex<double>&}]	48	static
stl_uninitialized.h:76:9:static _ForwardIterator std::__uninitialized_copy<_TrivialValueTypes>::__uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = const std::complex<double>*; _ForwardIterator = std::complex<double>*; bool _TrivialValueTypes = false]	64	static
stl_iterator_base_funcs.h:138:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >]	224	dynamic,bounded
stl_algobase.h:1059:5:bool std::equal(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; _II2 = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>]	288	dynamic,bounded
stl_algobase.h:1059:5:bool std::equal(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<double, 2, const double*>; _II2 = boost::multi::array_iterator<double, 2, const double*>]	288	dynamic,bounded
tuple:132:19:constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(_UHead&&) [with _UHead = boost::multi::extension_t<long int>; long unsigned int _Idx = 0; _Head = boost::multi::extension_t<long int>]	32	static
stl_iterator_base_types.h:205:5:constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = double*]	16	static
stl_iterator_base_funcs.h:174:5:constexpr void std::__advance(_RandomAccessIterator&, _Distance, std::random_access_iterator_tag) [with _RandomAccessIterator = double*; _Distance = long int]	16	static
move.h:47:5:constexpr _Tp* std::__addressof(_Tp&) [with _Tp = double]	16	static
new_allocator.h:144:2:) [with _Up = double; _Args = {}; _Tp = double]	32	static
array_ref.hpp:285:28:constexpr boost::multi::array_iterator<Element, D, ElementPtr>& boost::multi::array_iterator<Element, D, ElementPtr>::operator++() [with Element = double; long int D = 2; ElementPtr = const double*]	16	static
stl_algobase.h:337:2:static _OI std::__copy_move<false, false, std::random_access_iterator_tag>::__copy_m(_II, _II, _OI) [with _II = boost::multi::array_iterator<double, 2, const double*>; _OI = boost::multi::array_iterator<double, 2, double*>]	144	static
stl_algobase.h:280:5:_Iterator std::__niter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<std::complex<double>, 1, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >]	16	static
stl_algobase.h:393:5:_OI std::__copy_move_a(_II, _II, _OI) [with bool _IsMove = false; _II = boost::multi::array_iterator<std::complex<double>, 1, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >; _OI = boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>]	96	dynamic,bounded
adl.hpp:177:6:std::decay_t<decltype ((std::allocator_traits<_Alloc>::construct(alloc, std::addressof((* first))), first))> boost::multi::xtd::alloc_uninitialized_default_construct_n(Alloc&, ForwardIt, Size) [with Alloc = std::allocator<std::complex<double> >; ForwardIt = std::complex<double>*; Size = long int; T = std::complex<double>]	96	static
cpp_type_traits.h:428:5:_Iterator std::__miter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >]	24	static
stl_algobase.h:438:5:_OI std::__copy_move_a2(_II, _II, _OI) [with bool _IsMove = false; _II = boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >; _OI = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>]	384	dynamic,bounded
cpp_type_traits.h:428:5:_Iterator std::__miter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>]	24	static
stl_algobase.h:438:5:_OI std::__copy_move_a2(_II, _II, _OI) [with bool _IsMove = false; _II = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; _OI = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>]	352	dynamic,bounded
stl_iterator_base_funcs.h:138:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >]	208	dynamic,bounded
stl_iterator_base_funcs.h:138:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >]	224	dynamic,bounded
array_ref.hpp:1011:69:constexpr typename std::iterator_traits<_II>::reference boost::multi::array_iterator<Element, 1, Ptr>::operator*() const [with Element = thrust::complex<double>; Ptr = thrust::complex<double>*]	16	static
array_ref.hpp:1011:69:constexpr typename std::iterator_traits<_II>::reference boost::multi::array_iterator<Element, 1, Ptr>::operator*() const [with Element = thrust::complex<double>; Ptr = const thrust::complex<double>*]	16	static
stl_uninitialized.h:99:9:static _ForwardIterator std::__uninitialized_copy<true>::__uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = const thrust::complex<double>*; _ForwardIterator = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>]	48	static
stl_iterator_base_types.h:205:5:constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >*]	16	static
stl_iterator_base_funcs.h:98:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = const boost::multi::array<thrust::complex<double>, 1, std::allocator<thrust::complex<double> > >*]	16	static
array_ref.hpp:1271:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::end() && [with T = thrust::complex<double>; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<1>]	32	static
stl_uninitialized.h:99:9:static _ForwardIterator std::__uninitialized_copy<true>::__uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = const thrust::complex<double>*; _ForwardIterator = thrust::complex<double>*]	48	static
array_ref.hpp:109:12:constexpr boost::multi::array_types<T, D, ElementPtr, Layout>::array_types(const layout_t&, const element_ptr&) [with T = thrust::complex<double>; long int D = 1; ElementPtr = const thrust::complex<double>*; Layout = boost::multi::layout_t<1>]	16	static
stl_algobase.h:1059:5:bool std::equal(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>; _II2 = boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>]	288	dynamic,bounded
stl_algobase.h:280:5:_Iterator std::__niter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >]	16	static
stl_algobase.h:393:5:_OI std::__copy_move_a(_II, _II, _OI) [with bool _IsMove = false; _II = boost::multi::array_iterator<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >; _OI = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>]	96	dynamic,bounded
adl.hpp:177:6:std::decay_t<decltype ((std::allocator_traits<_Alloc>::construct(alloc, std::addressof((* first))), first))> boost::multi::xtd::alloc_uninitialized_default_construct_n(Alloc&, ForwardIt, Size) [with Alloc = std::allocator<thrust::complex<double> >; ForwardIt = thrust::complex<double>*; Size = long int; T = thrust::complex<double>]	80	static
cpp_type_traits.h:428:5:_Iterator std::__miter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<thrust::complex<double>, 2, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >]	24	static
stl_algobase.h:438:5:_OI std::__copy_move_a2(_II, _II, _OI) [with bool _IsMove = false; _II = boost::multi::array_iterator<thrust::complex<double>, 2, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >; _OI = boost::multi::array_iterator<thrust::complex<double>, 2, thrust::complex<double>*>]	384	dynamic,bounded
stl_algobase.h:1059:5:bool std::equal(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>; _II2 = boost::multi::array_iterator<thrust::complex<double>, 2, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >]	304	dynamic,bounded
type_index_facade.hpp:187:13:bool boost::typeindex::operator==(const TypeInfo&, const boost::typeindex::type_index_facade<Derived, TypeInfo>&) [with Derived = boost::typeindex::stl_type_index; TypeInfo = std::type_info]	48	static
cpp_type_traits.h:428:5:_Iterator std::__miter_base(_Iterator) [with _Iterator = const double*]	16	static
stl_algobase.h:438:5:_OI std::__copy_move_a2(_II, _II, _OI) [with bool _IsMove = false; _II = const double*; _OI = boost::multi::array_iterator<double, 1, double*>]	80	static
array_ref.hpp:1270:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::end() & [with T = double; ElementPtr = double*; Layout = boost::multi::layout_t<1>]	64	static
stl_algobase.h:465:5:_OI std::copy(_II, _II, _OI) [with _II = const double*; _OI = double*]	64	static
floating_point_comparison.hpp:153:17:static FPT boost::math::fpc::fpc_detail::fpt_specialized_limits<FPT>::max_value() [with FPT = double]	16	static
floating_point_comparison.hpp:152:17:static FPT boost::math::fpc::fpc_detail::fpt_specialized_limits<FPT>::min_value() [with FPT = double]	16	static
print_helper.hpp:52:23:std::ostream& boost::test_tools::tt_detail::impl::boost_test_print_type(std::ostream&, const T&) [with T = double]	32	static
stl_iterator_base_types.h:205:5:constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >]	16	static
stl_iterator_base_funcs.h:98:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<double, 2, const double*>, boost::multi::array_iterator<double, 2, const double*> >]	16	static
array_ref.hpp:1270:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::end() & [with T = std::complex<double>; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<1>]	64	static
stl_iterator_base_types.h:205:5:constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >]	16	static
stl_iterator_base_funcs.h:98:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > > >]	16	static
stl_algobase.h:280:5:_Iterator std::__niter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>]	24	static
stl_algobase.h:841:5:bool std::__equal_aux(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; _II2 = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>]	160	dynamic,bounded
stl_algobase.h:841:5:bool std::__equal_aux(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<double, 2, const double*>; _II2 = boost::multi::array_iterator<double, 2, const double*>]	160	dynamic,bounded
array_ref.hpp:246:54:constexpr boost::multi::basic_array<Element, (D - 1), ElementPtr> boost::multi::array_iterator<Element, D, ElementPtr>::operator*() const [with Element = double; long int D = 2; ElementPtr = const double*]	48	static
array_ref.hpp:1283:7:>&) && [with TT = double; As = {const double*, boost::multi::layout_t<1, long int>}; T = double; ElementPtr = double*; Layout = boost::multi::layout_t<1>]	96	static
array_ref.hpp:1012:28:constexpr boost::multi::array_iterator<Element, 1, Ptr>::difference_type boost::multi::array_iterator<Element, 1, Ptr>::operator-(const boost::multi::array_iterator<Element, 1, Ptr>&) const [with Element = std::complex<double>; Ptr = boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >]	32	static
numeric.hpp:158:7:auto boost::multi::blas::involuter<It, F, Reference>::operator-(const boost::multi::blas::involuter<It, F, Reference>&) const [with It = const std::complex<double>*; F = boost::multi::blas::conjugate; Reference = boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate>]	16	static
array_ref.hpp:995:28:constexpr boost::multi::array_iterator<Element, 1, Ptr>::difference_type boost::multi::array_iterator<Element, 1, Ptr>::distance_to(const boost::multi::array_iterator<Element, 1, Ptr>&) const [with Element = std::complex<double>; Ptr = boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >]	32	static
numeric.hpp:151:23:constexpr boost::multi::blas::involuter<It, F, Reference>& boost::multi::blas::involuter<It, F, Reference>::operator+=(boost::multi::blas::involuter<It, F, Reference>::difference_type) [with It = const std::complex<double>*; F = boost::multi::blas::conjugate; Reference = boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate>]	16	static
array_ref.hpp:1007:28:constexpr boost::multi::array_iterator<Element, 1, Ptr>& boost::multi::array_iterator<Element, 1, Ptr>::operator++() [with Element = std::complex<double>; Ptr = boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >]	32	static
stl_algobase.h:337:2:static _OI std::__copy_move<false, false, std::random_access_iterator_tag>::__copy_m(_II, _II, _OI) [with _II = boost::multi::array_iterator<std::complex<double>, 1, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >; _OI = boost::multi::array_iterator<std::complex<double>, 1, std::complex<double>*>]	96	static
stl_iterator_base_funcs.h:202:5:constexpr void std::advance(_InputIterator&, _Distance) [with _InputIterator = std::complex<double>*; _Distance = long int]	48	static
move.h:138:5:constexpr _Tp* std::addressof(_Tp&) [with _Tp = std::complex<double>]	32	static
alloc_traits.h:482:2:) [with _Up = std::complex<double>; _Args = {}; _Tp = std::complex<double>]	32	static
alloc_traits.h:495:2:static void std::allocator_traits<std::allocator<_CharT> >::destroy(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, _Up*) [with _Up = std::complex<double>; _Tp = std::complex<double>]	32	static
stl_algobase.h:280:5:_Iterator std::__niter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >]	24	static
stl_algobase.h:280:5:_Iterator std::__niter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>]	24	static
stl_algobase.h:393:5:_OI std::__copy_move_a(_II, _II, _OI) [with bool _IsMove = false; _II = boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >; _OI = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>]	192	dynamic,bounded
stl_algobase.h:295:5:_Iterator std::__niter_wrap(const _Iterator&, _Iterator) [with _Iterator = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>]	24	static
stl_algobase.h:393:5:_OI std::__copy_move_a(_II, _II, _OI) [with bool _IsMove = false; _II = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; _OI = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>]	176	dynamic,bounded
stl_iterator_base_types.h:205:5:constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >]	16	static
stl_iterator_base_funcs.h:98:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, double, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >]	16	static
stl_iterator_base_types.h:205:5:constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >]	16	static
stl_iterator_base_funcs.h:98:5:constexpr typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = boost::multi::blas::gemm_iterator<boost::multi::blas::context*, std::complex<double>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*> >]	16	static
stl_algobase.h:465:5:_OI std::copy(_II, _II, _OI) [with _II = const thrust::complex<double>*; _OI = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>]	64	static
array_ref.hpp:1270:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::end() & [with T = thrust::complex<double>; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<1>]	64	static
stl_algobase.h:465:5:_OI std::copy(_II, _II, _OI) [with _II = const thrust::complex<double>*; _OI = thrust::complex<double>*]	64	static
stl_algobase.h:280:5:_Iterator std::__niter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>]	24	static
stl_algobase.h:841:5:bool std::__equal_aux(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>; _II2 = boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>]	160	dynamic,bounded
array_ref.hpp:1012:28:constexpr boost::multi::array_iterator<Element, 1, Ptr>::difference_type boost::multi::array_iterator<Element, 1, Ptr>::operator-(const boost::multi::array_iterator<Element, 1, Ptr>&) const [with Element = thrust::complex<double>; Ptr = boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> >]	32	static
numeric.hpp:158:7:auto boost::multi::blas::involuter<It, F, Reference>::operator-(const boost::multi::blas::involuter<It, F, Reference>&) const [with It = const thrust::complex<double>*; F = boost::multi::blas::conjugate; Reference = boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate>]	16	static
array_ref.hpp:995:28:constexpr boost::multi::array_iterator<Element, 1, Ptr>::difference_type boost::multi::array_iterator<Element, 1, Ptr>::distance_to(const boost::multi::array_iterator<Element, 1, Ptr>&) const [with Element = thrust::complex<double>; Ptr = boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> >]	32	static
numeric.hpp:151:23:constexpr boost::multi::blas::involuter<It, F, Reference>& boost::multi::blas::involuter<It, F, Reference>::operator+=(boost::multi::blas::involuter<It, F, Reference>::difference_type) [with It = const thrust::complex<double>*; F = boost::multi::blas::conjugate; Reference = boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate>]	16	static
array_ref.hpp:1007:28:constexpr boost::multi::array_iterator<Element, 1, Ptr>& boost::multi::array_iterator<Element, 1, Ptr>::operator++() [with Element = thrust::complex<double>; Ptr = boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> >]	32	static
stl_algobase.h:337:2:static _OI std::__copy_move<false, false, std::random_access_iterator_tag>::__copy_m(_II, _II, _OI) [with _II = boost::multi::array_iterator<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >; _OI = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>]	96	static
stl_iterator_base_funcs.h:202:5:constexpr void std::advance(_InputIterator&, _Distance) [with _InputIterator = thrust::complex<double>*; _Distance = long int]	48	static
move.h:138:5:constexpr _Tp* std::addressof(_Tp&) [with _Tp = thrust::complex<double>]	32	static
alloc_traits.h:482:2:) [with _Up = thrust::complex<double>; _Args = {}; _Tp = thrust::complex<double>]	32	static
stl_algobase.h:280:5:_Iterator std::__niter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<thrust::complex<double>, 2, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >]	24	static
stl_algobase.h:280:5:_Iterator std::__niter_base(_Iterator) [with _Iterator = boost::multi::array_iterator<thrust::complex<double>, 2, thrust::complex<double>*>]	24	static
stl_algobase.h:393:5:_OI std::__copy_move_a(_II, _II, _OI) [with bool _IsMove = false; _II = boost::multi::array_iterator<thrust::complex<double>, 2, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >; _OI = boost::multi::array_iterator<thrust::complex<double>, 2, thrust::complex<double>*>]	192	dynamic,bounded
stl_algobase.h:295:5:_Iterator std::__niter_wrap(const _Iterator&, _Iterator) [with _Iterator = boost::multi::array_iterator<thrust::complex<double>, 2, thrust::complex<double>*>]	24	static
stl_algobase.h:841:5:bool std::__equal_aux(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>; _II2 = boost::multi::array_iterator<thrust::complex<double>, 2, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >]	160	dynamic,bounded
type_index_facade.hpp:154:35:constexpr bool boost::typeindex::operator==(const boost::typeindex::type_index_facade<Derived, TypeInfo>&, const boost::typeindex::type_index_facade<Derived, TypeInfo>&) [with Derived = boost::typeindex::stl_type_index; TypeInfo = std::type_info]	32	static
stl_algobase.h:280:5:_Iterator std::__niter_base(_Iterator) [with _Iterator = const double*]	16	static
stl_algobase.h:393:5:_OI std::__copy_move_a(_II, _II, _OI) [with bool _IsMove = false; _II = const double*; _OI = boost::multi::array_iterator<double, 1, double*>]	64	static
stl_algobase.h:438:5:_OI std::__copy_move_a2(_II, _II, _OI) [with bool _IsMove = false; _II = const double*; _OI = double*]	64	static
index_range.hpp:57:17:constexpr auto boost::multi::iterator_facade<Self, ValueType, AccessCategory, Reference, DifferenceType, Pointer>::operator!=(const self_type&) const [with Self = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ValueType = void; AccessCategory = std::random_access_iterator_tag; Reference = const boost::multi::basic_array<std::complex<double>, 1, const std::complex<double>*, boost::multi::layout_t<1> >&; DifferenceType = long int; Pointer = void*]	32	static
array_ref.hpp:285:28:constexpr boost::multi::array_iterator<Element, D, ElementPtr>& boost::multi::array_iterator<Element, D, ElementPtr>::operator++() [with Element = std::complex<double>; long int D = 2; ElementPtr = const std::complex<double>*]	16	static
layout.hpp:270:35:constexpr boost::multi::layout_t<1>::index_extension boost::multi::extension(const boost::multi::layout_t<1>&)	32	static
array_ref.hpp:1298:17:constexpr bool boost::multi::basic_array<T, 1, ElementPtr, Layout>::operator==(const Array&) const & [with Array = boost::multi::basic_array<std::complex<double>, 1, const std::complex<double>*, boost::multi::layout_t<1> >; T = std::complex<double>; ElementPtr = const std::complex<double>*; Layout = boost::multi::layout_t<1>]	144	dynamic,bounded
array_ref.hpp:246:54:constexpr boost::multi::basic_array<Element, (D - 1), ElementPtr> boost::multi::array_iterator<Element, D, ElementPtr>::operator*() const [with Element = std::complex<double>; long int D = 2; ElementPtr = const std::complex<double>*]	48	static
array_ref.hpp:180:20:constexpr Ref boost::multi::basic_array_ptr<Ref, Layout>::operator*() const [with Ref = boost::multi::basic_array<std::complex<double>, 1, const std::complex<double>*, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	16	static
stl_algobase.h:817:2:static bool std::__equal<_BoolType>::equal(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; _II2 = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; bool _BoolType = false]	96	static
index_range.hpp:57:17:constexpr auto boost::multi::iterator_facade<Self, ValueType, AccessCategory, Reference, DifferenceType, Pointer>::operator!=(const self_type&) const [with Self = boost::multi::array_iterator<double, 2, const double*>; ValueType = void; AccessCategory = std::random_access_iterator_tag; Reference = const boost::multi::basic_array<double, 1, const double*, boost::multi::layout_t<1> >&; DifferenceType = long int; Pointer = void*]	32	static
array_ref.hpp:1298:17:constexpr bool boost::multi::basic_array<T, 1, ElementPtr, Layout>::operator==(const Array&) const & [with Array = boost::multi::basic_array<double, 1, const double*, boost::multi::layout_t<1> >; T = double; ElementPtr = const double*; Layout = boost::multi::layout_t<1>]	144	dynamic,bounded
array_ref.hpp:180:20:constexpr Ref boost::multi::basic_array_ptr<Ref, Layout>::operator*() const [with Ref = boost::multi::basic_array<double, 1, const double*, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	16	static
stl_algobase.h:817:2:static bool std::__equal<_BoolType>::equal(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<double, 2, const double*>; _II2 = boost::multi::array_iterator<double, 2, const double*>; bool _BoolType = false]	96	static
tuple:1419:5:>&) [with _TElements = {boost::multi::extension_t<long int, long int>}; _UElements = {boost::multi::extension_t<long int, long int>}]	32	static
array_ref.hpp:1265:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::begin() const & [with T = double; ElementPtr = const double*; Layout = boost::multi::layout_t<1>]	64	static
array_ref.hpp:1269:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::end() const & [with T = double; ElementPtr = const double*; Layout = boost::multi::layout_t<1>]	64	static
move.h:99:5:constexpr typename std::remove_reference<_Tp>::type&& std::move(_Tp&&) [with _Tp = boost::multi::basic_array<double, 1, double*, boost::multi::layout_t<1> >&]	16	static
numeric.hpp:148:17:constexpr auto boost::multi::blas::involuter<It, F, Reference>::operator*() const [with It = const std::complex<double>*; F = boost::multi::blas::conjugate; Reference = boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate>]	64	static
array_ref.hpp:1011:69:constexpr typename std::iterator_traits<_II>::reference boost::multi::array_iterator<Element, 1, Ptr>::operator*() const [with Element = std::complex<double>; Ptr = boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >]	32	static
numeric.hpp:59:12:constexpr boost::multi::blas::involuted<Ref, Involution>::operator boost::multi::blas::involuted<Ref, Involution>::decay_type() && [with Ref = const std::complex<double>&; Involution = boost::multi::blas::conjugate]	32	static
stl_iterator_base_types.h:205:5:constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = std::complex<double>*]	16	static
stl_iterator_base_funcs.h:174:5:constexpr void std::__advance(_RandomAccessIterator&, _Distance, std::random_access_iterator_tag) [with _RandomAccessIterator = std::complex<double>*; _Distance = long int]	16	static
new_allocator.h:144:2:) [with _Up = std::complex<double>; _Args = {}; _Tp = std::complex<double>]	32	static
new_allocator.h:151:2:void __gnu_cxx::new_allocator<_Tp>::destroy(_Up*) [with _Up = std::complex<double>; _Tp = std::complex<double>]	16	static
array_ref.hpp:288:35:constexpr boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >::difference_type boost::multi::operator-(const boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >&, const boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >&)	32	static
array_ref.hpp:285:28:constexpr boost::multi::array_iterator<Element, D, ElementPtr>& boost::multi::array_iterator<Element, D, ElementPtr>::operator++() [with Element = std::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >]	32	static
stl_algobase.h:337:2:static _OI std::__copy_move<false, false, std::random_access_iterator_tag>::__copy_m(_II, _II, _OI) [with _II = boost::multi::array_iterator<std::complex<double>, 2, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> > >; _OI = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>]	144	static
stl_algobase.h:337:2:static _OI std::__copy_move<false, false, std::random_access_iterator_tag>::__copy_m(_II, _II, _OI) [with _II = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; _OI = boost::multi::array_iterator<std::complex<double>, 2, std::complex<double>*>]	144	static
cpp_type_traits.h:428:5:_Iterator std::__miter_base(_Iterator) [with _Iterator = const thrust::complex<double>*]	16	static
stl_algobase.h:438:5:_OI std::__copy_move_a2(_II, _II, _OI) [with bool _IsMove = false; _II = const thrust::complex<double>*; _OI = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>]	80	static
stl_algobase.h:438:5:_OI std::__copy_move_a2(_II, _II, _OI) [with bool _IsMove = false; _II = const thrust::complex<double>*; _OI = thrust::complex<double>*]	64	static
index_range.hpp:57:17:constexpr auto boost::multi::iterator_facade<Self, ValueType, AccessCategory, Reference, DifferenceType, Pointer>::operator!=(const self_type&) const [with Self = boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>; ValueType = void; AccessCategory = std::random_access_iterator_tag; Reference = const boost::multi::basic_array<thrust::complex<double>, 1, const thrust::complex<double>*, boost::multi::layout_t<1> >&; DifferenceType = long int; Pointer = void*]	32	static
array_ref.hpp:285:28:constexpr boost::multi::array_iterator<Element, D, ElementPtr>& boost::multi::array_iterator<Element, D, ElementPtr>::operator++() [with Element = thrust::complex<double>; long int D = 2; ElementPtr = const thrust::complex<double>*]	16	static
array_ref.hpp:1298:17:constexpr bool boost::multi::basic_array<T, 1, ElementPtr, Layout>::operator==(const Array&) const & [with Array = boost::multi::basic_array<thrust::complex<double>, 1, const thrust::complex<double>*, boost::multi::layout_t<1> >; T = thrust::complex<double>; ElementPtr = const thrust::complex<double>*; Layout = boost::multi::layout_t<1>]	144	dynamic,bounded
array_ref.hpp:246:54:constexpr boost::multi::basic_array<Element, (D - 1), ElementPtr> boost::multi::array_iterator<Element, D, ElementPtr>::operator*() const [with Element = thrust::complex<double>; long int D = 2; ElementPtr = const thrust::complex<double>*]	48	static
array_ref.hpp:180:20:constexpr Ref boost::multi::basic_array_ptr<Ref, Layout>::operator*() const [with Ref = boost::multi::basic_array<thrust::complex<double>, 1, const thrust::complex<double>*, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	16	static
stl_algobase.h:817:2:static bool std::__equal<_BoolType>::equal(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>; _II2 = boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>; bool _BoolType = false]	96	static
numeric.hpp:148:17:constexpr auto boost::multi::blas::involuter<It, F, Reference>::operator*() const [with It = const thrust::complex<double>*; F = boost::multi::blas::conjugate; Reference = boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate>]	64	static
array_ref.hpp:1011:69:constexpr typename std::iterator_traits<_II>::reference boost::multi::array_iterator<Element, 1, Ptr>::operator*() const [with Element = thrust::complex<double>; Ptr = boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> >]	32	static
numeric.hpp:59:12:constexpr boost::multi::blas::involuted<Ref, Involution>::operator boost::multi::blas::involuted<Ref, Involution>::decay_type() && [with Ref = const thrust::complex<double>&; Involution = boost::multi::blas::conjugate]	48	static
stl_iterator_base_types.h:205:5:constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = thrust::complex<double>*]	16	static
stl_iterator_base_funcs.h:174:5:constexpr void std::__advance(_RandomAccessIterator&, _Distance, std::random_access_iterator_tag) [with _RandomAccessIterator = thrust::complex<double>*; _Distance = long int]	16	static
move.h:47:5:constexpr _Tp* std::__addressof(_Tp&) [with _Tp = thrust::complex<double>]	16	static
new_allocator.h:144:2:) [with _Up = thrust::complex<double>; _Args = {}; _Tp = thrust::complex<double>]	32	static
array_ref.hpp:288:35:constexpr boost::multi::array_iterator<thrust::complex<double>, 2, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >::difference_type boost::multi::operator-(const boost::multi::array_iterator<thrust::complex<double>, 2, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >&, const boost::multi::array_iterator<thrust::complex<double>, 2, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >&)	32	static
array_ref.hpp:285:28:constexpr boost::multi::array_iterator<Element, D, ElementPtr>& boost::multi::array_iterator<Element, D, ElementPtr>::operator++() [with Element = thrust::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> >]	32	static
stl_algobase.h:337:2:static _OI std::__copy_move<false, false, std::random_access_iterator_tag>::__copy_m(_II, _II, _OI) [with _II = boost::multi::array_iterator<thrust::complex<double>, 2, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >; _OI = boost::multi::array_iterator<thrust::complex<double>, 2, thrust::complex<double>*>]	144	static
array_ref.hpp:1298:17:constexpr bool boost::multi::basic_array<T, 1, ElementPtr, Layout>::operator==(const Array&) const & [with Array = boost::multi::basic_array<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<1> >; T = thrust::complex<double>; ElementPtr = const thrust::complex<double>*; Layout = boost::multi::layout_t<1>]	160	dynamic,bounded
array_ref.hpp:246:54:constexpr boost::multi::basic_array<Element, (D - 1), ElementPtr> boost::multi::array_iterator<Element, D, ElementPtr>::operator*() const [with Element = thrust::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> >]	48	static
stl_algobase.h:817:2:static bool std::__equal<_BoolType>::equal(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>; _II2 = boost::multi::array_iterator<thrust::complex<double>, 2, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >; bool _BoolType = false]	96	static
stl_algobase.h:337:2:static _OI std::__copy_move<false, false, std::random_access_iterator_tag>::__copy_m(_II, _II, _OI) [with _II = const double*; _OI = boost::multi::array_iterator<double, 1, double*>]	80	static
stl_algobase.h:280:5:_Iterator std::__niter_base(_Iterator) [with _Iterator = double*]	16	static
stl_algobase.h:393:5:_OI std::__copy_move_a(_II, _II, _OI) [with bool _IsMove = false; _II = const double*; _OI = double*]	64	static
stl_algobase.h:295:5:_Iterator std::__niter_wrap(const _Iterator&, _Iterator) [with _Iterator = double*]	16	static
index_range.hpp:49:29:constexpr const self_type& boost::multi::iterator_facade<Self, ValueType, AccessCategory, Reference, DifferenceType, Pointer>::self() const [with Self = boost::multi::array_iterator<std::complex<double>, 2, const std::complex<double>*>; ValueType = void; AccessCategory = std::random_access_iterator_tag; Reference = const boost::multi::basic_array<std::complex<double>, 1, const std::complex<double>*, boost::multi::layout_t<1> >&; DifferenceType = long int; Pointer = void*]	16	static
array_ref.hpp:1265:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::begin() const & [with T = std::complex<double>; ElementPtr = const std::complex<double>*; Layout = boost::multi::layout_t<1>]	64	static
array_ref.hpp:1269:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::end() const & [with T = std::complex<double>; ElementPtr = const std::complex<double>*; Layout = boost::multi::layout_t<1>]	64	static
adl.hpp:401:39:) const [with As = {const boost::multi::basic_array<std::complex<double>, 1, const std::complex<double>*, boost::multi::layout_t<1, long int> >&}]	32	static
adl.hpp:85:38:) const [with As = {boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>}]	96	dynamic,bounded
index_range.hpp:49:29:constexpr const self_type& boost::multi::iterator_facade<Self, ValueType, AccessCategory, Reference, DifferenceType, Pointer>::self() const [with Self = boost::multi::array_iterator<double, 2, const double*>; ValueType = void; AccessCategory = std::random_access_iterator_tag; Reference = const boost::multi::basic_array<double, 1, const double*, boost::multi::layout_t<1> >&; DifferenceType = long int; Pointer = void*]	16	static
adl.hpp:401:39:) const [with As = {const boost::multi::basic_array<double, 1, const double*, boost::multi::layout_t<1, long int> >&}]	32	static
adl.hpp:85:38:) const [with As = {boost::multi::array_iterator<double, 1, const double*>, boost::multi::array_iterator<double, 1, const double*>, boost::multi::array_iterator<double, 1, const double*>}]	96	dynamic,bounded
tuple:1392:7:static constexpr bool std::__tuple_compare<_Tp, _Up, __i, __size>::__eq(const _Tp&, const _Up&) [with _Tp = std::tuple<boost::multi::extension_t<long int, long int> >; _Up = std::tuple<boost::multi::extension_t<long int, long int> >; long unsigned int __i = 0; long unsigned int __size = 1]	48	static
array_ref.hpp:990:12:constexpr boost::multi::array_iterator<Element, 1, Ptr>::array_iterator(Ptr, typename boost::multi::basic_array<Element, 1, Ptr>::index) [with Element = double; Ptr = const double*]	16	static
numeric.hpp:52:21:constexpr boost::multi::blas::involuted<Ref, Involution>::involuted(Ref, Involution) [with Ref = const std::complex<double>&; Involution = boost::multi::blas::conjugate]	48	static
array_ref.hpp:246:54:constexpr boost::multi::basic_array<Element, (D - 1), ElementPtr> boost::multi::array_iterator<Element, D, ElementPtr>::operator*() const [with Element = std::complex<double>; long int D = 2; ElementPtr = boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >]	48	static
array_ref.hpp:1283:7:>&) && [with TT = std::complex<double>; As = {boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<1, long int>}; T = std::complex<double>; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<1>]	112	static
array_ref.hpp:1283:7:>&) && [with TT = std::complex<double>; As = {const std::complex<double>*, boost::multi::layout_t<1, long int>}; T = std::complex<double>; ElementPtr = std::complex<double>*; Layout = boost::multi::layout_t<1>]	96	static
stl_algobase.h:280:5:_Iterator std::__niter_base(_Iterator) [with _Iterator = const thrust::complex<double>*]	16	static
stl_algobase.h:393:5:_OI std::__copy_move_a(_II, _II, _OI) [with bool _IsMove = false; _II = const thrust::complex<double>*; _OI = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>]	64	static
stl_algobase.h:280:5:_Iterator std::__niter_base(_Iterator) [with _Iterator = thrust::complex<double>*]	16	static
stl_algobase.h:393:5:_OI std::__copy_move_a(_II, _II, _OI) [with bool _IsMove = false; _II = const thrust::complex<double>*; _OI = thrust::complex<double>*]	64	static
stl_algobase.h:295:5:_Iterator std::__niter_wrap(const _Iterator&, _Iterator) [with _Iterator = thrust::complex<double>*]	16	static
index_range.hpp:49:29:constexpr const self_type& boost::multi::iterator_facade<Self, ValueType, AccessCategory, Reference, DifferenceType, Pointer>::self() const [with Self = boost::multi::array_iterator<thrust::complex<double>, 2, const thrust::complex<double>*>; ValueType = void; AccessCategory = std::random_access_iterator_tag; Reference = const boost::multi::basic_array<thrust::complex<double>, 1, const thrust::complex<double>*, boost::multi::layout_t<1> >&; DifferenceType = long int; Pointer = void*]	16	static
array_ref.hpp:287:17:constexpr bool boost::multi::array_iterator<Element, D, ElementPtr>::operator==(const boost::multi::array_iterator<Element, D, ElementPtr>&) const [with Element = thrust::complex<double>; long int D = 2; ElementPtr = const thrust::complex<double>*]	32	static
array_ref.hpp:1265:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::begin() const & [with T = thrust::complex<double>; ElementPtr = const thrust::complex<double>*; Layout = boost::multi::layout_t<1>]	64	static
array_ref.hpp:1269:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::end() const & [with T = thrust::complex<double>; ElementPtr = const thrust::complex<double>*; Layout = boost::multi::layout_t<1>]	64	static
adl.hpp:401:39:) const [with As = {const boost::multi::basic_array<thrust::complex<double>, 1, const thrust::complex<double>*, boost::multi::layout_t<1, long int> >&}]	32	static
adl.hpp:85:38:) const [with As = {boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>, boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>, boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>}]	96	dynamic,bounded
numeric.hpp:52:21:constexpr boost::multi::blas::involuted<Ref, Involution>::involuted(Ref, Involution) [with Ref = const thrust::complex<double>&; Involution = boost::multi::blas::conjugate]	48	static
array_ref.hpp:1283:7:>&) && [with TT = thrust::complex<double>; As = {boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<1, long int>}; T = thrust::complex<double>; ElementPtr = thrust::complex<double>*; Layout = boost::multi::layout_t<1>]	112	static
adl.hpp:401:39:) const [with As = {const boost::multi::basic_array<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<1, long int> >&}]	64	static
adl.hpp:85:38:) const [with As = {boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>, boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>, boost::multi::array_iterator<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >}]	112	dynamic,bounded
array_ref.hpp:180:20:constexpr Ref boost::multi::basic_array_ptr<Ref, Layout>::operator*() const [with Ref = boost::multi::basic_array<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	24	static
stl_algobase.h:375:2:static _Tp* std::__copy_move<_IsMove, true, std::random_access_iterator_tag>::__copy_m(const _Tp*, const _Tp*, _Tp*) [with _Tp = double; bool _IsMove = false]	64	static
array_ref.hpp:990:12:constexpr boost::multi::array_iterator<Element, 1, Ptr>::array_iterator(Ptr, typename boost::multi::basic_array<Element, 1, Ptr>::index) [with Element = std::complex<double>; Ptr = const std::complex<double>*]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::basic_array<std::complex<double>, 1, const std::complex<double>*, boost::multi::layout_t<1> >&]	16	static
adl.hpp:399:48:) const [with T = const boost::multi::basic_array<std::complex<double>, 1, const std::complex<double>*, boost::multi::layout_t<1> >&; As = {}]	32	static
adl.hpp:81:47:) const [with As = {boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>, boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>}]	80	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::basic_array<double, 1, const double*, boost::multi::layout_t<1> >&]	16	static
adl.hpp:399:48:) const [with T = const boost::multi::basic_array<double, 1, const double*, boost::multi::layout_t<1> >&; As = {}]	32	static
adl.hpp:76:47:) const [with As = {boost::multi::array_iterator<double, 1, const double*>, boost::multi::array_iterator<double, 1, const double*>, boost::multi::array_iterator<double, 1, const double*>}]	80	static
tuple:1411:7:static constexpr bool std::__tuple_compare<_Tp, _Up, __size, __size>::__eq(const _Tp&, const _Up&) [with _Tp = std::tuple<boost::multi::extension_t<long int, long int> >; _Up = std::tuple<boost::multi::extension_t<long int, long int> >; long unsigned int __size = 1]	16	static
array_ref.hpp:180:20:constexpr Ref boost::multi::basic_array_ptr<Ref, Layout>::operator*() const [with Ref = boost::multi::basic_array<std::complex<double>, 1, boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	24	static
array_ref.hpp:1265:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::begin() const & [with T = std::complex<double>; ElementPtr = boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<1>]	32	static
numeric.hpp:152:17:constexpr auto boost::multi::blas::involuter<It, F, Reference>::operator+(boost::multi::blas::involuter<It, F, Reference>::difference_type) const [with It = const std::complex<double>*; F = boost::multi::blas::conjugate; Reference = boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate>]	64	static
array_ref.hpp:1269:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::end() const & [with T = std::complex<double>; ElementPtr = boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<1>]	48	static
move.h:99:5:constexpr typename std::remove_reference<_Tp>::type&& std::move(_Tp&&) [with _Tp = boost::multi::basic_array<std::complex<double>, 1, std::complex<double>*, boost::multi::layout_t<1> >&]	16	static
stl_algobase.h:337:2:static _OI std::__copy_move<false, false, std::random_access_iterator_tag>::__copy_m(_II, _II, _OI) [with _II = const thrust::complex<double>*; _OI = boost::multi::array_iterator<thrust::complex<double>, 1, thrust::complex<double>*>]	64	static
stl_algobase.h:375:2:static _Tp* std::__copy_move<_IsMove, true, std::random_access_iterator_tag>::__copy_m(const _Tp*, const _Tp*, _Tp*) [with _Tp = thrust::complex<double>; bool _IsMove = false]	64	static
array_ref.hpp:193:17:constexpr bool boost::multi::basic_array_ptr<Ref, Layout>::operator==(const boost::multi::basic_array_ptr<Ref, Layout>&) const [with Ref = boost::multi::basic_array<thrust::complex<double>, 1, const thrust::complex<double>*, boost::multi::layout_t<1> >; Layout = boost::multi::layout_t<1>]	48	static
array_ref.hpp:270:17:constexpr bool boost::multi::array_iterator<Element, D, ElementPtr>::equal(const boost::multi::array_iterator<Element, D, ElementPtr>&) const [with Element = thrust::complex<double>; long int D = 2; ElementPtr = const thrust::complex<double>*]	32	static
array_ref.hpp:990:12:constexpr boost::multi::array_iterator<Element, 1, Ptr>::array_iterator(Ptr, typename boost::multi::basic_array<Element, 1, Ptr>::index) [with Element = thrust::complex<double>; Ptr = const thrust::complex<double>*]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::basic_array<thrust::complex<double>, 1, const thrust::complex<double>*, boost::multi::layout_t<1> >&]	16	static
adl.hpp:399:48:) const [with T = const boost::multi::basic_array<thrust::complex<double>, 1, const thrust::complex<double>*, boost::multi::layout_t<1> >&; As = {}]	32	static
adl.hpp:76:47:) const [with As = {boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>, boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>, boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>}]	80	static
array_ref.hpp:1265:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::begin() const & [with T = thrust::complex<double>; ElementPtr = boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<1>]	32	static
numeric.hpp:152:17:constexpr auto boost::multi::blas::involuter<It, F, Reference>::operator+(boost::multi::blas::involuter<It, F, Reference>::difference_type) const [with It = const thrust::complex<double>*; F = boost::multi::blas::conjugate; Reference = boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate>]	64	static
array_ref.hpp:1269:27:constexpr boost::multi::basic_array<T, 1, ElementPtr, Layout>::const_iterator boost::multi::basic_array<T, 1, ElementPtr, Layout>::end() const & [with T = thrust::complex<double>; ElementPtr = boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> >; Layout = boost::multi::layout_t<1>]	48	static
move.h:99:5:constexpr typename std::remove_reference<_Tp>::type&& std::move(_Tp&&) [with _Tp = boost::multi::basic_array<thrust::complex<double>, 1, thrust::complex<double>*, boost::multi::layout_t<1> >&]	16	static
move.h:74:5:constexpr _Tp&& std::forward(typename std::remove_reference<_Tp>::type&) [with _Tp = const boost::multi::basic_array<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<1> >&]	16	static
adl.hpp:399:48:) const [with T = const boost::multi::basic_array<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> >, boost::multi::layout_t<1> >&; As = {}]	64	static
adl.hpp:76:47:) const [with As = {boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>, boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>, boost::multi::array_iterator<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >}]	96	dynamic,bounded
stl_algobase.h:1059:5:bool std::equal(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>; _II2 = boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>]	112	static
stl_algobase.h:1059:5:bool std::equal(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<double, 1, const double*>; _II2 = boost::multi::array_iterator<double, 1, const double*>]	112	static
array_ref.hpp:990:12:constexpr boost::multi::array_iterator<Element, 1, Ptr>::array_iterator(Ptr, typename boost::multi::basic_array<Element, 1, Ptr>::index) [with Element = std::complex<double>; Ptr = boost::multi::blas::involuter<const std::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate> >]	24	static
numeric.hpp:139:21:constexpr boost::multi::blas::involuter<It, F, Reference>::involuter(It, F) [with It = const std::complex<double>*; F = boost::multi::blas::conjugate; Reference = boost::multi::blas::involuted<const std::complex<double>&, boost::multi::blas::conjugate>]	48	static
array_ref.hpp:96:28:constexpr const layout_t& boost::multi::array_types<T, D, ElementPtr, Layout>::layout() const [with T = thrust::complex<double>; long int D = 1; ElementPtr = const thrust::complex<double>*; Layout = boost::multi::layout_t<1>]	16	static
stl_algobase.h:1059:5:bool std::equal(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>; _II2 = boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>]	112	static
array_ref.hpp:990:12:constexpr boost::multi::array_iterator<Element, 1, Ptr>::array_iterator(Ptr, typename boost::multi::basic_array<Element, 1, Ptr>::index) [with Element = thrust::complex<double>; Ptr = boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> >]	24	static
numeric.hpp:139:21:constexpr boost::multi::blas::involuter<It, F, Reference>::involuter(It, F) [with It = const thrust::complex<double>*; F = boost::multi::blas::conjugate; Reference = boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate>]	48	static
stl_algobase.h:1059:5:bool std::equal(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>; _II2 = boost::multi::array_iterator<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >]	144	dynamic,bounded
stl_algobase.h:841:5:bool std::__equal_aux(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>; _II2 = boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>]	96	static
stl_algobase.h:841:5:bool std::__equal_aux(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<double, 1, const double*>; _II2 = boost::multi::array_iterator<double, 1, const double*>]	96	static
move.h:99:5:constexpr typename std::remove_reference<_Tp>::type&& std::move(_Tp&&) [with _Tp = const std::complex<double>*&]	16	static
stl_algobase.h:841:5:bool std::__equal_aux(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>; _II2 = boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>]	96	static
move.h:99:5:constexpr typename std::remove_reference<_Tp>::type&& std::move(_Tp&&) [with _Tp = const thrust::complex<double>*&]	16	static
stl_algobase.h:841:5:bool std::__equal_aux(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>; _II2 = boost::multi::array_iterator<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >]	96	dynamic,bounded
stl_algobase.h:817:2:static bool std::__equal<_BoolType>::equal(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>; _II2 = boost::multi::array_iterator<std::complex<double>, 1, const std::complex<double>*>; bool _BoolType = false]	80	static
stl_algobase.h:817:2:static bool std::__equal<_BoolType>::equal(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<double, 1, const double*>; _II2 = boost::multi::array_iterator<double, 1, const double*>; bool _BoolType = false]	80	static
stl_algobase.h:817:2:static bool std::__equal<_BoolType>::equal(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>; _II2 = boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>; bool _BoolType = false]	80	static
numeric.hpp:86:24:constexpr auto boost::multi::blas::operator==(const decay_type&, const boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate>&)	64	static
stl_algobase.h:817:2:static bool std::__equal<_BoolType>::equal(_II1, _II1, _II2) [with _II1 = boost::multi::array_iterator<thrust::complex<double>, 1, const thrust::complex<double>*>; _II2 = boost::multi::array_iterator<thrust::complex<double>, 1, boost::multi::blas::involuter<const thrust::complex<double>*, boost::multi::blas::conjugate, boost::multi::blas::involuted<const thrust::complex<double>&, boost::multi::blas::conjugate> > >; bool _BoolType = false]	80	static
array_ref.hpp:1010:17:constexpr bool boost::multi::array_iterator<Element, 1, Ptr>::operator!=(const boost::multi::array_iterator<Element, 1, Ptr>&) const [with Element = double; Ptr = const double*]	16	static
array_ref.hpp:1010:17:constexpr bool boost::multi::array_iterator<Element, 1, Ptr>::operator!=(const boost::multi::array_iterator<Element, 1, Ptr>&) const [with Element = thrust::complex<double>; Ptr = const thrust::complex<double>*]	16	static
complex.inl:262:6:bool thrust::operator==(const thrust::complex<T>&, const thrust::complex<T1>&) [with T0 = double; T1 = double]	48	static
numeric.hpp:58:12:constexpr boost::multi::blas::involuted<Ref, Involution>::operator boost::multi::blas::involuted<Ref, Involution>::decay_type() const & [with Ref = const thrust::complex<double>&; Involution = boost::multi::blas::conjugate]	48	static
sp_counted_impl.hpp:68:46:boost::detail::sp_counted_impl_p<boost::unit_test::class_based_fixture<boost::test_tools::local_fpc_tolerance<double>, double> >::~sp_counted_impl_p()	32	static
sp_counted_impl.hpp:68:46:virtual boost::detail::sp_counted_impl_p<boost::unit_test::class_based_fixture<boost::test_tools::local_fpc_tolerance<double>, double> >::~sp_counted_impl_p()	32	static
sp_counted_impl.hpp:68:46:boost::detail::sp_counted_impl_p<boost::basic_wrap_stringstream<char> >::~sp_counted_impl_p()	32	static
sp_counted_impl.hpp:68:46:virtual boost::detail::sp_counted_impl_p<boost::basic_wrap_stringstream<char> >::~sp_counted_impl_p()	32	static
lazy_ostream.hpp:56:7:boost::unit_test::lazy_ostream_impl<boost::unit_test::lazy_ostream, boost::unit_test::basic_cstring<const char>, const boost::unit_test::basic_cstring<const char>&>::~lazy_ostream_impl()	32	static
lazy_ostream.hpp:56:7:virtual boost::unit_test::lazy_ostream_impl<boost::unit_test::lazy_ostream, boost::unit_test::basic_cstring<const char>, const boost::unit_test::basic_cstring<const char>&>::~lazy_ostream_impl()	32	static
trsm.cpp:501:1:void __static_initialization_and_destruction_0(int, int)	160	static
sp_counted_impl.hpp:88:18:void boost::detail::sp_counted_impl_p<X>::dispose() [with X = boost::unit_test::class_based_fixture<boost::test_tools::local_fpc_tolerance<double>, double>]	32	static
sp_counted_impl.hpp:96:20:void* boost::detail::sp_counted_impl_p<X>::get_deleter(const sp_typeinfo_&) [with X = boost::unit_test::class_based_fixture<boost::test_tools::local_fpc_tolerance<double>, double>]	16	static
sp_counted_impl.hpp:101:20:void* boost::detail::sp_counted_impl_p<X>::get_local_deleter(const sp_typeinfo_&) [with X = boost::unit_test::class_based_fixture<boost::test_tools::local_fpc_tolerance<double>, double>]	16	static
sp_counted_impl.hpp:106:20:void* boost::detail::sp_counted_impl_p<X>::get_untyped_deleter() [with X = boost::unit_test::class_based_fixture<boost::test_tools::local_fpc_tolerance<double>, double>]	16	static
sp_counted_impl.hpp:88:18:void boost::detail::sp_counted_impl_p<X>::dispose() [with X = boost::basic_wrap_stringstream<char>]	32	static
sp_counted_impl.hpp:96:20:void* boost::detail::sp_counted_impl_p<X>::get_deleter(const sp_typeinfo_&) [with X = boost::basic_wrap_stringstream<char>]	16	static
sp_counted_impl.hpp:101:20:void* boost::detail::sp_counted_impl_p<X>::get_local_deleter(const sp_typeinfo_&) [with X = boost::basic_wrap_stringstream<char>]	16	static
sp_counted_impl.hpp:106:20:void* boost::detail::sp_counted_impl_p<X>::get_untyped_deleter() [with X = boost::basic_wrap_stringstream<char>]	16	static
fixture.hpp:135:21:void boost::unit_test::class_based_fixture<F, Arg>::setup() [with F = boost::test_tools::local_fpc_tolerance<double>; Arg = double]	48	static
fixture.hpp:136:21:void boost::unit_test::class_based_fixture<F, Arg>::teardown() [with F = boost::test_tools::local_fpc_tolerance<double>; Arg = double]	32	static
lazy_ostream.hpp:65:29:std::ostream& boost::unit_test::lazy_ostream_impl<PrevType, T, StorageT>::operator()(std::ostream&) const [with PrevType = boost::unit_test::lazy_ostream; T = boost::unit_test::basic_cstring<const char>; StorageT = const boost::unit_test::basic_cstring<const char>&]	32	static
fpc_tolerance.hpp:47:5:boost::test_tools::local_fpc_tolerance<FPT>::local_fpc_tolerance(FPT) [with FPT = double]	48	static
scoped_ptr.hpp:91:10:void boost::scoped_ptr<T>::reset(T*) [with T = boost::test_tools::local_fpc_tolerance<double>]	48	static
scoped_ptr.hpp:97:9:T& boost::scoped_ptr<T>::operator*() const [with T = boost::test_tools::local_fpc_tolerance<double>]	32	static
fixture.hpp:112:6:void boost::unit_test::setup_conditional(U&) [with U = boost::test_tools::local_fpc_tolerance<double>]	48	static
fixture.hpp:118:6:void boost::unit_test::teardown_conditional(U&) [with U = boost::test_tools::local_fpc_tolerance<double>]	48	static
io.hpp:51:1:std::basic_ostream<_CharT, _Traits>& boost::unit_test::operator<<(std::basic_ostream<_CharT, _Traits>&, const boost::unit_test::basic_cstring<CharT2>&) [with CharT1 = char; Tr = std::char_traits<char>; CharT2 = const char]	128	static
scoped_ptr.hpp:117:10:void boost::scoped_ptr<T>::swap(boost::scoped_ptr<T>&) [with T = boost::test_tools::local_fpc_tolerance<double>]	16	static
fixture.hpp:98:58:void boost::unit_test::impl_fixture::call_setup<has_setup>::operator()(U&) [with U = boost::test_tools::local_fpc_tolerance<double>; bool has_setup = false]	16	static
fixture.hpp:104:58:void boost::unit_test::impl_fixture::call_teardown<has_teardown>::operator()(U&) [with U = boost::test_tools::local_fpc_tolerance<double>; bool has_teardown = false]	16	static
basic_cstring.hpp:488:1:const value_type* boost::unit_test::basic_cstring<CharT>::begin() const [with CharT = const char]	16	static
basic_cstring.hpp:506:1:const value_type* boost::unit_test::basic_cstring<CharT>::end() const [with CharT = const char]	16	static
trsm.cpp:501:1:cpp)	16	static
