\subsection{convert4qmc}
\label{sec:convert4qmc}
\ishell{Convert4qmc} allows conversion of orbitals and wavefunctions from
quantum chemistry output files to \qmcpack XML and HDF5 input files.
It is a small C++ executable that is built alongside the \qmcpack
executable and can be found in \texttt{build/bin}.\\

To date, \texttt{convert4qmc} supports the following codes:
GAMESS\cite{schmidt93}, PySCF\cite{Sun2018}, QP\cite{QP}
and GAMESS-FMO\cite{Fedorov2004,schmidt93}

\subsubsection{General use}
General use of \texttt{convert4qmc} can be prompted by running with no options:

\begin{lstlisting}[style=SHELL]
>convert4qmc

Defaults : -gridtype log -first 1e-6 -last 100 -size 1001 -ci required -threshold 0.01 -TargetState 0 -prefix sample

 convert [-gaussian|-casino|-gamesxml|-gamess|-gamessFMO|-QP|-pyscf|-orbitals] 
 filename                                                          
[-nojastrow -hdf5 -prefix title -addCusp -production -NbImages NimageX NimageY NimageZ]
[-psi_tag psi0 -ion_tag ion0 -gridtype log|log0|linear -first ri -last rf]
[-size npts -ci file.out -threshold cimin -TargetState state_number
-NaturalOrbitals NumToRead -optDetCoeffs]                                        
Defaults : -gridtype log -first 1e-6 -last 100 -size 1001 -ci required 
-threshold 0.01 -TargetState 0 -prefix sample                                
When the input format is missing, the  extension of filename is used to determine
the format                                                      
 *.Fchk -> gaussian; *.out -> gamess; *.data -> casino; *.xml -> gamesxml
\end{lstlisting}

As an example, to convert a GAMESS calculation using a single determinant, the following use is sufficient:\\
\begin{lstlisting}[style=SHELL]
convert4qmc -gamess MyGamessOutput.out
\end{lstlisting}

By default, the converter will generate multiple files:\\
\begin{table}[h]
\begin{center}
\begin{tabularx}{\textwidth}{l l l l X }
\hline
\multicolumn{5}{l}{\texttt{convert4qmc} output} \\
\hline
%\multicolumn{2}{l}{Outputfiles}  & \multicolumn{3}{l}{}\\
   &   \bfseries output     & \bfseries file type & \bfseries default   & \bfseries description \\
   &   \texttt{*.qmc.in-wfs.xml             } &  XML  & default& Main input file for QMCPACK\\
   &   \texttt{*.qmc.in-wfnoj.xml             } &  XML  & default& Main input file for QMCPACK\\
   &   \texttt{*.structure.xml             } &  XML   &default   & File containing the structure of the system\\
   &   \texttt{*.wfj.xml             } &  XML  & default & Wavefunction file with 1-, 2-, and 3-body Jastrows\\
   &   \texttt{*.wfnoj.xml             } &  XML   & default & Wavefunction file with no Jastrows \\
   &   \texttt{*.orbs.h5             } &  HDF5   & with -hdf5   & HDF5 file containing all wavefunction data\\
    \hline
    \end{tabularx}
\end{center}
\end{table}

If no \ishell{-prefix} option is specified, the prefix is taken from
the input file name. For instance, if the GAMESS output file is
\texttt{Mysim}.out, the files generated by \texttt{convert4qmc} will use the
prefix \texttt{Mysim} and output files will be
\ishell{Mysim.qmc.in-wfs.xml}, \ishell{Mysim.structure.xml}, and so on.

\begin{itemize}
 \item Files \texttt{.in-wfs.xml} and \texttt{.in-wfnoj.xml} \\ These
   are the input files for \qmcpack.  The geometry and the
   wavefunction are stored in external files \ishell{*.structure.xml}
   and \ishell{*.wfj.xml} (referenced from \ishell{*.in-wfs.xml}) or
   \ishell{*.qmc.wfnoj.xml} (referenced from
   \ishell{*.qmc.in-wfnoj.xml}). The Hamiltonian section is included,
   and the presence or lack of presence of an ECP is detected during the
   conversion. If use of an ECP is detected, a default ECP name is
   added (e.g., \ishell{H.qmcpp.xml}), and it is the responsibility of
   the user to modify the ECP name to match the one used to generate
   the wavefunction.\\
\begin{lstlisting}[style=QMCPXML]
  <?xml version="1.0"?>
<simulation>
  <!--
 
Example QMCPACK input file produced by convert4qmc
 
It is recommend to start with only the initial VMC block and adjust
parameters based on the measured energies, variance, and statistics.

-->
  <!--Name and Series number of the project.-->
  <project id="gms" series="0"/>
  <!--Link to the location of the Atomic Coordinates and the location of 
      the Wavefunction.-->
  <include href="gms.structure.xml"/>
  <include href="gms.wfnoj.xml"/>
  <!--Hamiltonian of the system. Default ECP filenames are assumed.-->
  <hamiltonian name="h0" type="generic" target="e">
    <pairpot name="ElecElec" type="coulomb" source="e" target="e" 
                                                   physical="true"/>
    <pairpot name="IonIon" type="coulomb" source="ion0" target="ion0"/>
    <pairpot name="PseudoPot" type="pseudo" source="ion0" wavefunction="psi0" 
                                                           format="xml">
      <pseudo elementType="H" href="H.qmcpp.xml"/>
      <pseudo elementType="Li" href="Li.qmcpp.xml"/>
    </pairpot>
  </hamiltonian>

 \end{lstlisting}

 The \ishell{qmc.in-wfnoj.xml} file will have one VMC block with a
 minimum number of blocks to reproduce the HF/DFT energy used to
 generate the trial wavefunction.
 
 \begin{lstlisting}[style=QMCPXML]
  <qmc method="vmc" move="pbyp" checkpoint="-1">
    <estimator name="LocalEnergy" hdf5="no"/>
    <parameter name="warmupSteps">100</parameter>
    <parameter name="blocks">20</parameter>
    <parameter name="steps">50</parameter>
    <parameter name="substeps">8</parameter>
    <parameter name="timestep">0.5</parameter>
    <parameter name="usedrift">no</parameter>
  </qmc>
</simulation>
 \end{lstlisting}

If the \ishell{qmc.in-wfj.xml} file is used, Jastrow optimization
blocks followed by a VMC and DMC block are included. These blocks
contain default values to allow the user to test the accuracy of a
system; however, they need to be updated and optimized for each
system. The initial values might only be suitable for a small molecule.

\begin{lstlisting}[style=QMCPXML]
  <loop max="4">
    <qmc method="linear" move="pbyp" checkpoint="-1">
      <estimator name="LocalEnergy" hdf5="no"/>
      <parameter name="warmupSteps">100</parameter>
      <parameter name="blocks">20</parameter>
      <parameter name="timestep">0.5</parameter>
      <parameter name="walkers">1</parameter>
      <parameter name="samples">16000</parameter>
      <parameter name="substeps">4</parameter>
      <parameter name="usedrift">no</parameter>
      <parameter name="MinMethod">OneShiftOnly</parameter>
      <parameter name="minwalkers">0.0001</parameter>
    </qmc>
  </loop>
  <!--

Example follow-up VMC optimization using more samples for greater accuracy:

-->
  <loop max="10">
    <qmc method="linear" move="pbyp" checkpoint="-1">
      <estimator name="LocalEnergy" hdf5="no"/>
      <parameter name="warmupSteps">100</parameter>
      <parameter name="blocks">20</parameter>
      <parameter name="timestep">0.5</parameter>
      <parameter name="walkers">1</parameter>
      <parameter name="samples">64000</parameter>
      <parameter name="substeps">4</parameter>
      <parameter name="usedrift">no</parameter>
      <parameter name="MinMethod">OneShiftOnly</parameter>
      <parameter name="minwalkers">0.3</parameter>
    </qmc>
  </loop>
  <!--

Production VMC and DMC:

Examine the results of the optimization before running these blocks.
For example, choose the best optimized jastrow from all obtained, put in the 
wavefunction file, and do not reoptimize.

-->
  <qmc method="vmc" move="pbyp" checkpoint="-1">
    <estimator name="LocalEnergy" hdf5="no"/>
    <parameter name="warmupSteps">100</parameter>
    <parameter name="blocks">200</parameter>
    <parameter name="steps">50</parameter>
    <parameter name="substeps">8</parameter>
    <parameter name="timestep">0.5</parameter>
    <parameter name="usedrift">no</parameter>
    <!--Sample count should match targetwalker count for 
      DMC. Will be obtained from all nodes.-->
    <parameter name="samples">16000</parameter>
  </qmc>
  <qmc method="dmc" move="pbyp" checkpoint="20">
    <estimator name="LocalEnergy" hdf5="no"/>
    <parameter name="targetwalkers">16000</parameter>
    <parameter name="reconfiguration">no</parameter>
    <parameter name="warmupSteps">100</parameter>
    <parameter name="timestep">0.005</parameter>
    <parameter name="steps">100</parameter>
    <parameter name="blocks">100</parameter>
    <parameter name="nonlocalmoves">yes</parameter>
  </qmc>
</simulation>

\end{lstlisting}

 \item File \texttt{.structure.xml} \\
 This file will be referenced from the main QMCPACK input. It contains the geometry of the system, position of the atoms, number of atoms, atomic types and charges, and number of electrons.
 
 \item Files \texttt{.wfj.xml} and \texttt{.wfnoj.xml}\\
 These files contain the basis set detail, orbital coefficients, and the 1-, 2-, and 3-body Jastrow (in the case of \texttt{.wfj.xml}). If the wavefunction is multideterminant, the expansion will be at the end of the file. We recommend using the option \texttt{-hdf5} when large molecules are studied to store the data more compactly in an HDF5 file.
 
 \item File \texttt{.orbs.h5} \\
 This file is generated only if the option \texttt{-hdf5} is added as follows:
 \begin{shade}
  convert4qmc -gamess MyGamessOutput.out -hdf5
 \end{shade}
In this case,  the \texttt{.wfj.xml} or \texttt{.wfnoj.xml} files will point to this HDF file.  Information about the basis set, orbital coefficients, and the multideterminant expansion is put in this file and removed from the wavefunction files, making them smaller. 

\end{itemize}



\begin{table}[h]
\begin{center}
\begin{tabularx}{\textwidth}{l l l l }
\hline
\multicolumn{4}{l}{\ishell{convert4qmc} input type} \\
\hline
   &   \bfseries Option name     &\bfseries description\\
   &   \texttt{-orbitals    } &  Generic HDF5 input file. Mainly automatically generated from QP and PySCF.  & Actively maintained\\
   &   \texttt{-pyscf       } &  PySCF code & Actively maintained\\
   &   \texttt{-QP          } &  QP code & Actively maintained\\
   &   \texttt{-gamess      } &  Gamess code & Maintained\\
   &   \texttt{-gamesFMO    } &  Gamess FMO & Maintained\\
   &   \texttt{-gaussian    } &  Gaussian code & Obsolete/untested \\
   &   \texttt{-casino      } &  Casino code & Obsolete/untested \\
   &   \texttt{-gamesxml    } &  Gamess xml format code  & Obsolete/untested\\
    \hline

    \end{tabularx}
\end{center}
\end{table}

\subsubsection{Command line options}

 \begin{table}[h]
 \begin{center}
 \begin{tabularx}{\textwidth}{l l l l l }
 \hline
 \multicolumn{5}{l}{\texttt{convert4qmc} command line options} \\
 \hline
    &   \bfseries Option name      & \bfseries Value & \bfseries default   & \bfseries description \\
    &   \texttt{-nojastrow    } &  -      &   - & Force no Jastrow. \texttt{qmc.in.wfj} will not be generated  \\
    &   \texttt{-hdf5         } &  -      &   - & Force the wf to be in HDF5 format   \\
    &   \texttt{-prefix       } & string  &   - & All created files will have the name of the string   \\
    &   \texttt{-multidet     } & string  &   - & HDF5 file containing a multideterminant expansion   \\
    &   \texttt{-addCusp      } &  -      &   - & Force to add orbital cusp correction (ONLY for all-electron)  \\
    &   \texttt{-production   } &  -      &   - & Generates specific blocks in the input     \\
    &   \texttt{-psi\_tag     } & string  & psi0& Name of the electrons particles inside \qmcpack   \\
    &   \texttt{-ion\_tag     } & string  & ion0& Name of the ion particles inside \qmcpack      \\
    \hline
     \end{tabularx}
 \end{center}
 \end{table}
\begin{itemize}
\item \texttt{-multidet}\\
This option is to be used when a multideterminant expansion (mainly a CI expansion) is present in an HDF5 file. The trial wavefunction file will not display the full list of multideterminants and will add a path to the HDF5 file as follows (full example for the C2 molecule in qmcpack/tests/molecules/C2\_pp).\\
  
\begin{lstlisting}[style=QMCPXML]
<?xml version="1.0"?>
<qmcsystem>
  <wavefunction name="psi0" target="e">
    <determinantset type="MolecularOrbital" name="LCAOBSet" source="ion0" transform="yes" href="C2.h5">
      <sposet basisset="LCAOBSet" name="spo-up" size="58">
        <occupation mode="ground"/>
        <coefficient size="58" spindataset="0"/>
      </sposet>
      <sposet basisset="LCAOBSet" name="spo-dn" size="58">
        <occupation mode="ground"/>
        <coefficient size="58" spindataset="0"/>
      </sposet>
      <multideterminant optimize="no" spo_up="spo-up" spo_dn="spo-dn">
        <detlist size="202" type="DETS" nca="0" ncb="0" nea="4" neb="4" nstates="58" cutoff="1e-20" href="C2.h5"/>
      </multideterminant>
    </determinantset>
  </wavefunction>
</qmcsystem>
\end{lstlisting}



To generate such trial wavefunction, the converter has to be invoked as follows:

\begin{shade}
> convert4qmc -orbitals C2.h5 -multidet C2.h5 
\end{shade}


\item \texttt{-nojastrow}\\
This option generates only an input file, \ishell{*.qmc.in.wfnoj.xml}, containing no Jastrow optimization blocks and references a wavefunction file, \ishell{*.wfnoj.xml}, containing no Jastrow section.

\item \texttt{-hdf5}\\
This option generates the \ishell{*.orbs.h5} HDF5 file containing the basis set and the orbital coefficients. If the wavefunction contains a multideterminant expansion from QP, it will also be stored in this file. This option minimizes the size of the \ishell{*.wfj.xml} file, which points to the HDF file, as in the following example: 

\begin{lstlisting}[style=QMCPXML]
 <?xml version="1.0"?>
<qmcsystem>
  <wavefunction name="psi0" target="e">
    <determinantset type="MolecularOrbital" name="LCAOBSet" source="ion0"
       transform="yes" href="test.orbs.h5">
      <slaterdeterminant>
        <determinant id="updet" size="39">
          <occupation mode="ground"/>
          <coefficient size="411" spindataset="0"/>
        </determinant>
        <determinant id="downdet" size="35">
          <occupation mode="ground"/>
          <coefficient size="411" spindataset="0"/>
        </determinant>
      </slaterdeterminant>
    </determinantset>
  </wavefunction>
</qmcsystem>
\end{lstlisting}

Jastrow functions will be included if the option ``-nojastrow'' was
not specified. Note that when initially optimization a wavefunction, we recommend
temporarily removing/disabling the 3-body Jastrow.

\item \textbf{-prefix}\\
Sets the prefix for all output generated by \texttt{convert4qmc}. \\
If not specified, \texttt{convert4qmc} will use the defaults for the following:\\
\begin{itemize}
 \item \textbf{Gamess}\\
If the Gamess output file  is named ``\textbf{Name}.out'' or ``\textbf{Name}.output,'' all files generated by \texttt{convert4qmc} will carry \textbf{Name} as a prefix (i.e., \textbf{Name}.qmc.in.xml).\\ 
\item \textbf{PySCF}\\
If the PySCF output file  is named ``\textbf{Name}.H5,'' all files generated by \texttt{convert4qmc} will carry \textbf{Name} as a prefix (i.e., \textbf{Name}.qmc.in.xml).\\ 
\item \textbf{QP}\\
If the QP output file  is named ``\textbf{Name}.dump,'' all files generated by \texttt{convert4qmc} will carry \textbf{Name} as a prefix (i.e., \textbf{Name}.qmc.in.xml).\\ 
\item \textbf{Generic HDF5 input}\\
If a generic HDF5 file (either from PySCF or QP in the HDF5 format) is named ``\textbf{Name}.H5,'' all files generated by \texttt{convert4qmc} will carry \textbf{Name} as a prefix (i.e., \textbf{Name}.qmc.in.xml).\\ 

\end{itemize}


\item \textbf{-addCusp} \\ This option is very important for
  all-electron (AE) calculations. In this case, orbitals have to be
  corrected for the electron-nuclear cusp. The cusp correction scheme
  follows the algorithm described by Ma et al. \cite{Ma2005}
  When this option is present, the wavefunction file has a new set of
  tags:

\begin{lstlisting}[style=QMCPXML]
 qmcsystem>
  <wavefunction name="psi0" target="e">
    <determinantset type="MolecularOrbital" name="LCAOBSet" source="ion0"
      transform="yes" cuspCorrection="yes">
      <basisset name="LCAOBSet">
\end{lstlisting}

The tag ``cuspCorrection'' in the \ishell{wfj.xml} (or \ishell{wfnoj.xml}) wavefunction file will force correction of the orbitals at the beginning of the \qmcpack run. \\
In the ``orbitals`` section of the wavefunction file, a new tag ``cuspInfo'' will be added for orbitals spin-up and orbitals spin-down:

\begin{lstlisting}[style=QMCPXML]
   <slaterdeterminant>
        <determinant id="updet" size="2"
            cuspInfo="../CuspCorrection/updet.cuspInfo.xml">
          <occupation mode="ground"/>
          <coefficient size="135" id="updetC">
          
  <determinant id="downdet" size="2"
           cuspInfo="../CuspCorrection/downdet.cuspInfo.xml">
          <occupation mode="ground"/>
          <coefficient size="135" id="downdetC">
\end{lstlisting}

These tags will point to the files \ishell{updet.cuspInfo.xml} and
\ishell{downdet.cuspInfo.xml}. By default, the converter assumes that
the files are located in the relative path
\texttt{../CuspCorrection/}. If the directory
\ishell{../CuspCorrection} does not exist, or if the files are not
present in that directory, \qmcpack will run the cusp correction
algorithm to generate both files.  If the files exist, then /qmcpack
will apply the corrections to the orbitals. \\

\textbf{Important notes:}\\
- The cusp correction implementations has been parallelized and performance improved.  However, since the correction needs
to be applied for every ion and then for every orbital on that ion, this operation can be costly (slow) for large
systems. We recommend saving and reusing the computed cusp correction files \ishell{updet.cuspInfo.xml} and
\ishell{downdet.cuspInfo.xml}, and transferring them between computer systems where relevant.
\\

\item \textbf{-psi\_tag}\\
\qmcpack builds the wavefunction as a named object. In the vast majority of cases, one wavefunction is simulated at a time, but there may be situations where we want to distinguish different parts of a wavefunction, or even use multiple wavefunctions. This option can change the name for these cases. 

\begin{lstlisting}[style=QMCPXML]
   <wavefunction name="psi0" target="e">
\end{lstlisting}

\item \textbf{-ion\_tag} \\
Although similar to \textbf{-psi\_tag}, this is used for the type of ions. \\
\begin{shade}
  <particleset name="ion0" size="2">
\end{shade}


\item \textbf{-production}\\

Without this option, input files with standard optimization, VMC, and
DMC blocks are generated. When the ``-production'' option is
specified, an input file containing complex options that may be
more suitable for large runs at HPC centers is generated. This option
is for users who are already familiar with QMC and \qmcpack. We encourage feedback
on the standard and production sample inputs.


\end{itemize}

The following options are specific to using MCSCF multideterminants from Gamess. 

 \begin{table}[h]
 \begin{center}
 \begin{tabularx}{\textwidth}{l l l l l }
 \hline
 \multicolumn{5}{l}{\texttt{convert4qmc} MCSCF arguments} \\
 \hline
    &   \bfseries option      & \bfseries Value & \bfseries default   & \bfseries description \\
    &   \texttt{-ci    } & String     &   none & Name of the file containing the CI expansion  \\
    &   \texttt{-threshold         } &  double    &  1e-20 & Cutoff of the weight of the determinants  \\
    &   \texttt{-TargetState      } & int  &  none & ?  \\
    &   \texttt{-NaturalOrbitals      } &  int      &  none   & ?  \\
    &   \texttt{-optDetCoeffs      } &  -      &   no & Enables the optimization of CI coefficients \\
    \hline
     \end{tabularx}
 \end{center}
 \end{table}
\begin{itemize}
\item keyword \textbf{-ci}\\
Path/name of the file containing the CI expansion in a Gamess Format.
\item keyword \textbf{-threshold}\\
The CI expansion contains coefficients (weights) for each determinant. This option sets the maximum coefficient to include in the QMC run. By default it is set to 1e-20 (meaning all determinants in an expansion are taken into account). At the same time, if the threshold is set to a different value, for example $1e-5$, any determinant with a weight $abs(weight) < 1e-5$ will be discarded and the determinant will not be considered. 
\item keyword \textbf{-TargetState}\\
?
\item keyword \textbf{-NaturalOrbitals}\\
?
\item keyword \textbf{-optDetCoeffs}\\
This flag enables optimization of the CI expansion coefficients. By default, optimization of the coefficients is disabled during wavefunction optimization runs. 
\end{itemize}

Examples and more thorough descriptions of these options can be found in the lab section of this manual: Chapter-\ref{chap:lab_advanced_molecules}\\

\subsubsection{Grid options}
                                          
% 
These parameters control how the basis set is projected on a grid. The default parameters are chosen to be very efficient. Unless you have a very good reason, we do not recommend modifying them. 

\begin{table}[h]
 \begin{center}
 \begin{tabularx}{\textwidth}{l l l l l }
 \hline
 \multicolumn{5}{l}{\texttt{convert4qmc} Grid Keywords} \\
 \hline
 \multicolumn{2}{l}{Tags}  & \multicolumn{3}{l}{}\\
    &   \bfseries keyword      & \bfseries Value & \bfseries default   & \bfseries description \\
    &   \texttt{-gridtype    } &  log|log0|linear      &  log & Grid type  \\
    &   \texttt{-first         } & double  &  1e-6 & First point of the grid   \\
    &   \texttt{-last       } & double  & 100 & Last point of the grid \\
    &   \texttt{-size      } &  int    &  1001& Number of point in the grid   \\
     \hline
     \end{tabularx}
 \end{center}
 \end{table}
\begin{itemize}
\item \textbf{-gridtype}\\
Grid type can be logarithmic, logarithmic base 10, or linear \\
\item \textbf{-first}\\
First value of the grid\\
\item \textbf{-last}\\
Last value of the grid\\
\item \textbf{-size}\\
Number of points in the grid between ``first'' and ``last.'' \\
\end{itemize}


\subsubsection{Supported codes}

\begin{itemize}
\item \textbf{PySCF}\\

PySCF\cite{Sun2018} is an all-purpose quantum chemistry code that can
run calculations from simple Hartree-Fock to DFT, MCSCF, and CCSD, and
for both isolated systems and periodic boundary conditions. PySCF can
be downloaded from \url{https://github.com/sunqm/pyscf}. Many examples
and tutorials can be found on the PySCF website, and all types of
single determinants calculations are compatible with \qmcpack, thanks
to active support from the authors of PySCF. A few additional steps
are necessary to generate an output readable by \texttt{convert4qmc}.


This example shows how to run a Hartree-Fock calculation for the $LiH$
dimer molecule from PySCF and convert the wavefunction for \qmcpack.\\

\begin{itemize}
\item \textbf{Python path}\\
  \begin{sloppypar}
    PySCF is a Python-based code. A Python module named \textbf{PyscfToQmcpack} containing the function \textbf{savetoqmcpack} is provided by \qmcpack and is located at\linebreak
    \ishell{qmcpack/src/QMCTools/PyscfToQmcpack.py}.
To be accessible to the PySCF script, this path must be added to the PYTHONPATH environment variable.
For the bash shell, this can be done as follows:\\
\end{sloppypar}
\begin{shade}
 export PYTHONPATH=/PATH_TO_QMCPACK/qmcpack/src/QMCTools:\$PYTHONPATH
\end{shade}


 \item \textbf{PySCF Input File}\\
 
Copy and paste the following code in a file named LiH.py.

\begin{lstlisting}[style=Python]
#! /usr/bin/env python3
from pyscf import gto, scf, df
import numpy

cell = gto.M(
   atom ='''
Li 0.0 0.0 0.0
H  0.0 0.0 3.0139239778''',
   basis ='cc-pv5z',
   unit="bohr",
   spin=0,
   verbose = 5,
   cart=False,
)
mf = scf.ROHF(cell)
mf.kernel()

###SPECIFIC TO QMCPACK###
title='LiH'
from PyscfToQmcpack import savetoqmcpack

savetoqmcpack(cell,mf,title)
\end{lstlisting}

The arguments to the function \textbf{savetoqmcpack} are:\\
\begin{itemize}
 \item \textbf{cell}\\
 This is the object returned from gto.M, containing the type of atoms, geometry, basisset, spin, etc. \\
 \item \textbf{mf}\\
This is an object representing the PySCF level of theory, in this example, ROHF. This object contains the orbital coefficients of the calculations. \\
 \item \textbf{title}\\
 The name of the output file generated by PySCF. By default, the name of the generated file will be ``default'' if nothing is specified.\\
 \end{itemize}

By adding the three lines below the ``SPECIFIC TO QMCPACK'' comment  in the input file, the script will dump all the necessary data for \qmcpack into an HDF5 file using the value of ``title'' as an output name. PySCF is run as follows:\\
\begin{shade}
 >python LiH.py
\end{shade}


The generated HDF5 can be read by \texttt{convert4qmc} to generate the appropriate \qmcpack input files.\\

 \item \textbf{Generating input files}\\
 
 As described in the previous section, generating input files for PySCF is as follows:\\
 \begin{shade}
  > convert4qmc -pyscf LiH.h5 
 \end{shade}

The HDF5 file produced by ``savetoqmcpack'' contains the wavefunction in a form directly readable by \qmcpack.
The wavefunction files from \texttt{convert4qmc} reference this HDF file as if the ``-hdf5" option were specified
(converting from PySCF implies the ``-hdf5'' option is always present).

\end{itemize}

 An implementation of periodic boundary conditions with Gaussian orbitals from PySCF is under development. 

\item \textbf{Quantum Package}\\
QP\cite{QP} is a quantum chemistry code developed by the LCPQ laboratory in Toulouse, France. It can be downloaded from \url{https://github.com/LCPQ/quantum_package}, and the tutorial within is quite extensive. The tutorial section of QP can guide you on how to install and run the code.\\

After a QP calculation, the data needed for \texttt{convert4qmc} can be generated through\\
\begin{shade}
 qp_run save_for_qmcpack Myrun.ezfio &> Myrun.dump
\end{shade}

\texttt{convert4qmc} can read this format and generate \qmcpack input files in XML and HDF5 format.  For example:

\begin{shade}
 convert4qmc -QP Myrun.dump
\end{shade}


The main reason to use QP is to access the CIPSI algorithm to generate a multideterminant wavefunction.
CIPSI is the preferred choice for generating a selected CI trial wavefunction for \qmcpack. 
An example on how to use QP for Hartree-Fock and selected CI can be found in Section-\ref{sec:cipsi}  of this manual.
The converter code is actively maintained and codeveloped by both \qmcpack and QP developers.\\

We recommend using a trial wavefunction stored in HDF5 format to reduce the reading time when a multideterminant expansion is too large (more than 1K determinants). This can be done with two paths:\\

using the \textit{-hdf5} option in the converter as follows:\\

 \item \textbf{Using -hdf5 tag}\\

\begin{shade}
 convert4qmc -QP Myrun.dump -hdf5
\end{shade}

This will read the multideterminant expansion in the \texttt{Myrun.dump} file and store it in \texttt{Myrun.dump.orbs.h5}. Note that this method will be deprecated as QP automatically generates a compatible HDF5 file usable by \qmcpack directly. \\

 \item \textbf{Using h5 file }\\

QP version 2.0 (released in 2019) directly generates an HDF5 file that completely mimics the \qmcpack readable format. This file can be generated after a CIPSI, Hartree-Fock, or range-separated DFT in QP as follows: \\

\begin{shade}
 qp_run save_for_qmcpack Myrun.ezfio > Myrun.dump
\end{shade}

In addition to \texttt{Myrun.dump}, an HDF5 file always named \texttt{QMC.h5} is created containing all relevant information to start a QMC run. Input files can be generated as follows:\\

\begin{shade}
 convert4qmc -orbitals QMC.h5 -multidet QMC.h5
\end{shade}

Note that the \texttt{QMC.h5} combined with the tags \texttt{-orbitals} and \texttt{-multidet} allows the user to choose orbitals from a different code such as PYSCF and the multideterminant section from QP. These two codes are fully compatible, and this route is also the only possible route for multideterminants for solids. 

\item \textbf{GAMESS}\\
\qmcpack can use the output of GAMESS\cite{schmidt93} for any type of single determinant calculation (HF or DFT) or multideterminant (MCSCF) calculation. A description with an example can be found in the Advanced Molecular Calculations Lab (Section~\ref{chap:lab_advanced_molecules}).
\end{itemize}

