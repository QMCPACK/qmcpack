\chapter{Obtaining, installing and validating QMCPACK}
\label{chap:obtaininginstalling}

This chapter describes how to obtain, build and validate QMCPACK. This process is designed to be as simple as
possible and should be no harder than building a modern plane-wave density
functional theory code such as Quantum ESPRESSO, QBox, or
VASP. Parallel builds enable a complete
compilation in under 2 minutes on a fast multicore system. If you
are unfamiliar with building codes we suggest working with your system
administrator to install QMCPACK.

\section{Installation steps}
To install QMCPACK, follow the steps listed below. Full details of
each step are given in the referenced sections.
\begin{enumerate}
\item Download the source code, Sections \ref{sec:obrelease} or \ref{sec:obdevelopment}.
\item Verify that you have the required compilers, libraries and tools
  installed, Section \ref{sec:prerequisites}.
\item Run the cmake configure step and build with make, Section
  \ref{sec:cmake} and \ref{sec:cmakequick}. Some examples for common
  systems are given in Section \ref{sec:installexamples}.
\item Run the tests to verify QMCPACK, Section \ref{sec:testing}.
\item Build the ppconvert utility in QMCPACK, Section \ref{sec:buildppconvert}.
\item Download and patch Quantum ESPRESSO. This patch adds the
  pw2qmcpack utility, Section \ref{sec:buildqe}.
\end{enumerate}

Hints for high performance are in Section \ref{sec:buildperformance}. Troubleshooting suggestions are in Section \ref{sec:troubleshoot}.

Note that there are two different QMCPACK executables that can be
produced: the general one, which is the default, and the ``complex''
version which support periodic calculations at arbitrary twist angles and
k-points. This second version is enabled via a cmake configuration
parameter, see Section \ref{sec:cmakeoptions}. The general version
only supports wavefunctions that can be made real. If you run a
calculation that needs the complex version, QMCPACK will stop and inform you.

\section{Obtaining the latest release version}
\label{sec:obrelease}
Major releases of QMCPACK are distributed from
\url{http://www.qmcpack.org}. These releases undergo the most testing. Unless there are
specific reasons we encourage all production calculations to use the
latest release versions.

Releases are usually compressed tar files indicating the version
number, date, and often the source code revision control number
corresponding to the release.

\begin{itemize}
\item Download the latest QMCPACK distribution from \url{http://www.qmcpack.org}.
\item Untar the archive, e.g., \texttt{tar xvf qmcpack\_v1.3.tar.gz}
\end{itemize}

Releases can also be obtained from the 'master' branch of the QMCPACK
git repository, similar to obtaining the development version (Sec. \ref{sec:obdevelopment}).

\section{Obtaining the latest development version}
\label{sec:obdevelopment}
The most recent development version of QMCPACK can be obtained anonymously via
\verbatimfont{\footnotesize}
\begin{verbatim}
git clone https://github.com/QMCPACK/qmcpack.git
\end{verbatim}
Once checked-out,
updates can be made via the standard \texttt{git pull}.

The 'develop' branch of the git repository contains the day-to-day development source
with the latest updates, bugfixes etc. This may be useful
for updates to the build system to support new machines, for support
of the latest versions of Quantum ESPRESSO, or for updates to the
documentation.  Note that the development version may not be fully
consistent with the online documentation.  We attempt to keep
the development version fully working. However, please be sure to run the tests and
compare with previous release versions before using for any serious
calculations. We try to keep bugs out, but occasionally they crawl
in! Reports of any breakages are appreciated.

\section{Prerequisites}
\label{sec:prerequisites}
The following are required to build QMCPACK. For workstations, these are available via the standard
package manager. On shared supercomputers this software is usually
installed by default and is often
access via a modules environment - check your system
documentation.

\textbf{Use of the latest versions of all compilers and libraries is
strongly encouraged}, but not absolutely essential. Generally newer versions are faster - see
Section \ref{sec:buildperformance} for performance suggestions.

\begin{itemize}
\item C/C++ compilers such as GNU, Clang, Intel, IBM XL. C++ compilers
  are required to support C++11 standard. Use of recent (``current
  year version'') compilers is strongly encouraged.
\item MPI library such as OpenMPI \url{http://open-mpi.org} or vendor
  optimized MPI.
\item BLAS/LAPACK, numerical and linear algebra libraries. Use
  platform-optimized libraries where available, such as Intel MKL.
  ATLAS or other optimized open-source libraries may also be used
  \url{http://math-atlas.sourceforge.net}
\item CMake, build utility, \url{http://www.cmake.org}
\item Libxml2, XML parser, \url{http://xmlsoft.org}
\item HDF5, portable I/O library, \url{http://www.hdfgroup.org/HDF5/}. Good performance at large scale requires parallel version $>=$ 1.10.
\item BOOST, peer-reviewed portable C++ source libraries, \url{http://www.boost.org}
\item FFTW, FFT library, \url{http://www.fftw.org/}
\end{itemize}

To build the GPU accelerated version of QMCPACK an installation of
NVIDIA CUDA development tools is required. Ensure that this is
compatible with the C and C++ compiler versions you plan to
use. Supported versions are included in the NVIDIA release notes.

Many of the utilities provided with QMCPACK use python (v2). The numpy
and matplotlib libraries are required for full functionality.

Note that the standalone einspline library used by previous versions of QMCPACK
is no longer required. A more optimized version is included
inside. The standalone version should \emph{not} be on any standard
search paths because conflicts between the old and new include files
can result.

\section{Building with CMake}
\label{sec:cmake}
The build system for QMCPACK is based on CMake.  It will autoconfigure
based on the detected compilers and libraries. The most recent
version of CMake has the best detection for the greatest variety of
systems - at the time of writing this means CMake 3.4.3. The much
older CMake 2.8 is known to work, but might not work optimally on your system.

Previously QMCPACK made extensive use of toolchains, but the build system
has since been updated to eliminate the use of toolchain files for
most cases.  The build system is verified to work with GNU, Intel, and IBM XLC
compilers.  Specific compile options can be specified either through
specific environmental or CMake variables.  When the libraries are
installed in standard locations, e.g., /usr, /usr/local, there is no
need to set environmental or cmake variables for the packages.

\subsection{Quick build instructions (try first)}
\label{sec:cmakequick}

If you are feeling lucky and are on a standard UNIX-like system such
as a Linux workstation, the following might quickly give a
working QMCPACK:

The safest quick build option is to specify the C and C++ compilers
through their MPI wrappers. Here we use Intel MPI and Intel
compilers. Move to the build directory, run cmake and make
\verbatimfont{\footnotesize}
\begin{verbatim}
cd build
cmake -DCMAKE_C_COMPILER=mpiicc -DCMAKE_CXX_COMPILER=mpiicpc ..
make -j 8
\end{verbatim}
You can increase the ``8'' to the number of cores on your system for
faster builds. Substitute mpicc and mpicxx or other wrapped compiler names to suit
  your system. e.g. With OpenMPI use
\verbatimfont{\footnotesize}
\begin{verbatim}
cd build
cmake -DCMAKE_C_COMPILER=mpicc -DCMAKE_CXX_COMPILER=mpicxx ..
make -j 8
\end{verbatim}

If you are feeling particularly lucky, you can skip the compiler specification:
\verbatimfont{\footnotesize}
\begin{verbatim}
cd build
cmake ..
make -j 8
\end{verbatim}

The complexities of modern computer hardware and software systems are
such that you should check that the autoconfiguration system has made
good choices and picked optimized libraries and compiler settings
before doing significant production. i.e. Check the details below. We
give examples for a number of common systems in Section \ref{sec:installexamples}.

\subsection{Environment variables}
\label{sec:envvar}
A number of environmental variables affect the build.  In particular
they can control the default paths for libraries, the default
compilers, etc.  The list of environmental variables is given below:
\verbatimfont{\footnotesize}%
\begin{verbatim}
CXX              C++ compiler
CC               C Compiler
MKL_ROOT         Path for MKL
LIBXML2_HOME     Path for libxml2
HDF5_ROOT        Path for HDF5
BOOST_ROOT       Path for Boost
FFTW_HOME        Path for FFTW
\end{verbatim}

\subsection{Configuration options}
\label{sec:cmakeoptions}
In addition to reading the environmental variables, CMake provides a
number of optional variables that can be set to control the build and
configure steps.  When passed to CMake, these variables will take
precedent over the environmental and default variables.  To set them
add -D FLAG=VALUE to the configure line between the cmake command and
the path to the source directory.

\begin{itemize}
\item  Key QMCPACK build options
\verbatimfont{\footnotesize}%
\begin{verbatim}
QMC_CUDA              Enable CUDA and GPU acceleration (1:yes, 0:no)
QMC_COMPLEX           Build the complex (general twist/k-point) version (1:yes, 0:no)
QMC_MIXED_PRECISION   Build the mixed precision (mixing double/float) version
                      (1:yes (GPU default), 0:no (CPU default)).
                      The CPU support is experimental.
                      Use float and double for base and full precision.
                      The GPU support is quite mature.
                      Use always double for host side base and full precision
                      and use float and double for CUDA base and full precision.
ENABLE_TIMERS         Enable fine-grained timers (1:yes, 0:no (default)).
                      Timers are off by default to avoid potential slowdown in small
                      systems. For large systems (100+ electrons) there is no risk.
ENABLE_SOA            (Experimental) Enable CPU optimization and GPU support using
                      Structure-of-Array (SoA) datatypes (1:yes, 0:no (default)).
\end{verbatim}

\item General build options
\verbatimfont{\footnotesize}%
\begin{verbatim}
CMAKE_BUILD_TYPE     A variable which controls the type of build
                     (defaults to Release). Possible values are:
                     None (Do not set debug/optmize flags, use
                     CMAKE_C_FLAGS or CMAKE_CXX_FLAGS)
                     Debug (create a debug build)
                     Release (create a release/optimized build)
                     RelWithDebInfo (create a release/optimized build with debug info)
                     MinSizeRel (create an executable optimized for size)
CMAKE_C_COMPILER     Set the C compiler
CMAKE_CXX_COMPILER   Set the C++ compiler
CMAKE_C_FLAGS        Set the C flags.  Note: to prevent default
                     debug/release flags from being used, set the CMAKE_BUILD_TYPE=None
                     Also supported: CMAKE_C_FLAGS_DEBUG,
                     CMAKE_C_FLAGS_RELEASE, and CMAKE_C_FLAGS_RELWITHDEBINFO
CMAKE_CXX_FLAGS      Set the C++ flags.  Note: to prevent default
                     debug/release flags from being used, set the CMAKE_BUILD_TYPE=None
                     Also supported: CMAKE_CXX_FLAGS_DEBUG,
                     CMAKE_CXX_FLAGS_RELEASE, and CMAKE_CXX_FLAGS_RELWITHDEBINFO
\end{verbatim}

\item Additional QMCPACK build options
\verbatimfont{\footnotesize}
\begin{verbatim}
QMC_INCLUDE         Add extra include paths
QMC_EXTRA_LIBS      Add extra link libraries
QMC_BUILD_STATIC    Add -static flags to build
QMC_DATA            Specify data directory for QMCPACK performance and integration tests
QE_BIN              Location of Quantum Espresso binaries including pw2qmcpack.x
\end{verbatim}

\item Intel MKL related
\verbatimfont{\footnotesize}%
\begin{verbatim}
ENABLE_MKL          Enable Intel MKL libraries (1:yes (default for intel compiler),
                                                0:no (default otherwise)).
MKL_ROOT            Path to MKL libraries (only necessary for non intel compilers
                    or intel without standard environment variables.)
                    One of the above environment variables can be used.
\end{verbatim}

\item libxml2 related
\verbatimfont{\footnotesize}%
\begin{verbatim}
Libxml2_INCLUDE_DIRS   Specify include directories for libxml2
Libxml2_LIBRARY_DIRS   Specify library directories for libxml2
\end{verbatim}

\item HDF5 related
\verbatimfont{\footnotesize}%
\begin{verbatim}
ENABLE_PHDF5    1(default)/0, enables/disable parallel collective IO.
\end{verbatim}

\item FFTW related
\verbatimfont{\footnotesize}%
\begin{verbatim}
FFTW_INCLUDE_DIRS   Specify include directories for FFTW
FFTW_LIBRARY_DIRS   Specify library directories for FFTW
\end{verbatim}

\item CTest related
\verbatimfont{\footnotesize}%
\begin{verbatim}
MPIEXEC                Specify the mpi wrapper, e.g. srun, aprun, mpirun, etc.
MPIEXEC_NUMPROC_FLAG   Specify the number of mpi processes flag,
                       e.g. "-n", "-np", etc.
\end{verbatim}

\end{itemize}

\subsection{Role of QMC\_DATA}
QMCPACK includes a variety of optional performance and integration
tests that use research quality wavefunctions to obtain meaningful
performance and to more thoroughly test the code. The necessarily
large input files are stored in the location pointed to by QMC\_DATA,
e.g. scratch or long-lived project space on a supercomputer. These
files are not included in the source code distribution to minimize
size. The tests are activated if cmake detects the files when
configured. See tests/performance/NiO/README,
tests/solids/NiO\_afqmc/README and tests/performance/C-graphite/README
for details of the current tests, input files, and downloading them.

Currently the files must be downloaded via\\
\url{https://anl.box.com/s/pveyyzrc2wuvg5tmxjzzwxeo561vh3r0} and \\
\url{https://anl.box.com/s/j5d6jeazpgx5441s04ajtv77iogoyjsh}.

A complete set of files is currently:
\verbatimfont{\footnotesize}%
\begin{verbatim}
QMC_DATA/C-graphite/lda.pwscf.h5
QMC_DATA/NiO/NiO-fcc-supertwist111-supershift000-S1.h5
QMC_DATA/NiO/NiO-fcc-supertwist111-supershift000-S2.h5
QMC_DATA/NiO/NiO-fcc-supertwist111-supershift000-S4.h5
QMC_DATA/NiO/NiO-fcc-supertwist111-supershift000-S8.h5
QMC_DATA/NiO/NiO-fcc-supertwist111-supershift000-S16.h5
QMC_DATA/NiO/NiO-fcc-supertwist111-supershift000-S32.h5
QMC_DATA/NiO/NiO-fcc-supertwist111-supershift000-S64.h5
QMC_DATA/NiO/NiO-fcc-supertwist111-supershift000-S128.h5
QMC_DATA/NiO/NiO-fcc-supertwist111-supershift000-S256.h5
QMC_DATA/NiO/NiO_afm_fcidump.h5
QMC_DATA/NiO/NiO_afm_wfn.dat
QMC_DATA/NiO/NiO_nm_choldump.h5
\end{verbatim}


\subsection{Configure and build using cmake and make}
To configure and build QMCPACK, move to build directory, run cmake and make
\verbatimfont{\footnotesize}
\begin{verbatim}
cd build
cmake ..
make -j 8
\end{verbatim}

As you will have gathered, cmake encourages ``out of source'' builds,
where all the files for a specific build configuration reside in their
own directory separate from the source files. This allows multiple
builds to be created from the same source files which is very useful
where the filesystem is shared between different systems. You can also
build versions with different settings (e.g. QMC\_COMPLEX) and
different compiler settings. The build directory does not have to be
called build - use something descriptive such as build\_machinename or
build\_complex. The ``..'' in the cmake line refers to the directory
containing CMakeLists.txt. Update the ``..'' for other build
directory locations.

\subsection{Example configure and build}
\begin{itemize}
\item Set the environments (the examples below assume bash, Intel compilers and MKL library)
\verbatimfont{\footnotesize}
\begin{verbatim}
export CXX=icpc
export CC=icc
export LIBXML2_HOME=/usr/local
export MKL_ROOT=/usr/local/intel/mkl/10.0.3.020
export HDF5_ROOT=/usr/local
export BOOST_ROOT=/usr/local/boost
export FFTW_HOME=/usr/local/fftw
\end{verbatim}

\item Move to build directory, run cmake and make
\verbatimfont{\footnotesize}
\begin{verbatim}
cd build
cmake -D CMAKE_BUILD_TYPE=Release ..
make -j 8
\end{verbatim}
\end{itemize}

\subsection{Build scripts}
It is recommended to create a helper script that contains the
configure line for CMake.  This is particularly useful when avoiding
environmental variables, packages are installed in custom locations,
or if the configure line is long or complex.  In this case it is also
recommended to add "rm -rf CMake*" before the configure line to remove
existing CMake configure files to ensure a fresh configure each time
that the script is called. Deleting all the files in the build
directory is also acceptable. If you do so we recommend to add some sanity
checks in case the script is run from the wrong directory, e.g.,
checking for the existence of some QMCPACK files.

Some build script examples for different systems are given in the
config directory. For example, on Cray systems these scripts might
load the appropriate modules to set the appropriate programming
environment, specific library versions etc.

An example script build.sh is given below. It is much more complex
than usually needed for comprehensiveness:

\verbatimfont{\footnotesize}
\begin{verbatim}
export CXX=mpic++
export CC=mpicc
export ACML_HOME=/opt/acml-5.3.1/gfortran64
export HDF5_ROOT=/opt/hdf5
export BOOST_ROOT=/opt/boost

rm -rf CMake*

cmake                                                \
  -D CMAKE_BUILD_TYPE=Debug                         \
  -D Libxml2_INCLUDE_DIRS=/usr/include/libxml2      \
  -D Libxml2_LIBRARY_DIRS=/usr/lib/x86_64-linux-gnu \
  -D FFTW_INCLUDE_DIRS=/usr/include                 \
  -D FFTW_LIBRARY_DIRS=/usr/lib/x86_64-linux-gnu    \
  -D QMC_EXTRA_LIBS="-ldl ${ACML_HOME}/lib/libacml.a -lgfortran" \
  -D QMC_DATA=/projects/QMCPACK/qmc-data            \
  ..
\end{verbatim}

\subsection{Using vendor optimized numerical libraries, e.g. Intel MKL}

Although QMC does not make extensive use of linear algebra, use of
vendor optimized libraries is strongly recommended for highest
performance. BLAS routines are used in the Slater determinant update, the VMC wavefunction optimizer
and to apply orbital coefficients in local basis calculations. Vectorized
math functions are also beneficial, e.g. for the phase factor
computation in solid state calculations. CMake is generally successful
in finding these libraries, but specific combinations can require
additional hints, as described below:

\subsubsection{Using Intel MKL with non-Intel compilers}

To use Intel MKL with, e.g. an MPICH wrapped gcc:
\verbatimfont{\footnotesize}
\begin{verbatim}
cmake \
 -DCMAKE_C_COMPILER=mpicc -DCMAKE_CXX_COMPILER=mpicxx \
 -DENABLE_MKL=1 -DMKL_ROOT=$MKLROOT/lib \
 ..
\end{verbatim}

MKLROOT is the directory containing the MKL binary, examples, and lib
directories (etc.) and is often /opt/intel/mkl

\subsection{Cross compiling}
Cross-compiling is often difficult but is required on supercomputers
with distinct host and compute processor generations or architectures.
QMCPACK tried to do its best with CMake to facilitate cross-compiling.

\begin{itemize}
  \item On a machine using Cray programming environment, we rely on
      compiler wrappers provided by Cray to set architecture specific
      flags correctly. The CMake configure log should indicate that a
      Cray machine was detected.
  \item If not on a Cray machine, by default we assume building for
    the host architecture. e.g. -xHost is added for the Intel compiler
    and -march=native is added for GNU/Clang compilers.
  \item If -x/-ax or -march is specified by the user in CMAKE\_C\_FLAGS and CMAKE\_CXX\_FLAGS,
    we respect user's intention and do not add any architecture specific flags.
\end{itemize}

The general strategy for cross-compiling should therefore be to
manually set CMAKE\_C\_FLAGS and CMAKE\_CXX\_FLAGS for the target
archicture. Using \texttt{make VERBOSE=1} is a useful way to check the
final compilation options.  If on a Cray machine, selection of the
appropriate programming environment should be sufficient.

\section{Installation instructions for common workstations and
  supercomputers}
\label{sec:installexamples}

This section describes how to build QMCPACK on various common systems
including multiple Linux distributions, Apple OS X, and various
supercomputers. The examples should serve as good starting points for
building QMCPACK on similar machines. For example, the software
environment on modern Crays is very consistent. Note that updates to
operating systems and system software may require small modifications
to these recipes. See Section \ref{sec:buildperformance} for key
points to check to obtain highest performance and
Section \ref{sec:troubleshoot} for troubleshooting hints.

\subsection{Installing on Ubuntu Linux or other apt-get based distributions}
\label{sec:buildubuntu}

The following is designed to obtain a working QMCPACK build on e.g. a
student laptop, starting from a basic Linux installation with none of
the developer tools installed. Fortunately, all the required packages
are available in the default repositories making for a quick
installation. Note that for convenience we use a generic BLAS. For
production a platform optimized BLAS should be used.

\verbatimfont{\footnotesize}
\begin{verbatim}
apt-get cmake g++ openmpi-bin libopenmpi-dev libboost-dev
apt-get libatlas-base-dev liblapack-dev libhdf5-dev libxml2-dev fftw3-dev
export CXX=mpiCC
cd build
cmake ..
make -j 8
ls -l bin/qmcpack
\end{verbatim}

For qmca and other tools to function, we install some python libraries:
\verbatimfont{\footnotesize}
\begin{verbatim}
sudo apt-get install python-numpy python-matplotlib
\end{verbatim}

\subsection{Installing on CentOS Linux or other yum based distributions}

The following is designed to obtain a working QMCPACK build on e.g. a
student laptop, starting from a basic Linux installation with none of
the developer tools installed. CentOS 7 (Red Hat compatible) is using
gcc 4.8.2. The installation is only complicated by the need to install
another repository to obtain HDF5 packages which are not available by
default. Note that for convenience we use a generic BLAS. For
production a platform optimized BLAS should be used.

\verbatimfont{\footnotesize}
\begin{verbatim}
sudo yum install make cmake gcc gcc-c++ openmpi openmpi-devel fftw fftw-devel \
                  boost boost-devel libxml2 libxml2-devel
sudo yum install blas-devel lapack-devel atlas-devel
module load mpi
\end{verbatim}

To setup repoforge as a source for the HDF5 package, go to
\url{http://repoforge.org/use} . Install the appropriate up to date
release package for your OS. By default the CentOS Firefox will offer
to run the installer. The CentOS 6.5 settings were still usable for HDF5 on
CentOS 7 in 2016, but use CentOS 7 versions when they become
available.

\verbatimfont{\footnotesize}
\begin{verbatim}
sudo yum install hdf5 hdf5-devel
\end{verbatim}

To build QMCPACK
\verbatimfont{\footnotesize}
\begin{verbatim}
module load mpi/openmpi-x86_64
which mpirun
# Sanity check; should print something like   /usr/lib64/openmpi/bin/mpirun
export CXX=mpiCC
cd build
cmake ..
make -j 8
ls -l bin/qmcpack
\end{verbatim}

\subsection{Installing on Mac OS X using Macports}
These instructions assume a fresh installation of macports
and use the gcc 6.1 compiler. Older versions are fine, but it is vital to ensure
matching compilers and libraries are used for all
packages and to force use of what is installed in /opt/local.  Performance should be very reasonable.
Note that we utilize the Apple provided Accelerate framework for
optimized BLAS.

Follow the Macports install instructions \url{https://www.macports.org/}

\begin{itemize}
\item Install Xcode and the Xcode Command Line Tools
\item Agree to Xcode license in Terminal: sudo xcodebuild -license
\item Install MacPorts for your version of OS X
\end{itemize}


Install the required tools:

\verbatimfont{\footnotesize}
\begin{verbatim}
sudo port install gcc6
sudo port select gcc mp-gcc6
sudo port install openmpi-devel-gcc6
sudo port select --set mpi openmpi-devel-gcc61-fortran

sudo port install fftw-3 +gcc6
sudo port install libxml2
sudo port install cmake
sudo post install boost +gcc6
sudo port install hdf5 +gcc6

sudo port select --set python python27
sudo port install py27-numpy +gcc6
sudo port install py27-matplotlib  #For graphical plots with qmca
\end{verbatim}

QMCPACK build:
\verbatimfont{\footnotesize}
\begin{verbatim}
cd build
cmake -DCMAKE_C_COMPILER=mpicc -DCMAKE_CXX_COMPILER=mpiCXX ..
make -j 6 # Adjust for available core count
ls -l bin/qmcpack
\end{verbatim}

Cmake should pickup the versions of HDF5, libxml (etc.) installed in
/opt/local by macports. If you have other copies of these libraries
installed and wish to force use of a specific version, use the
environment variables detailed in Sec. \ref{sec:envvar}.

This recipe was verified on 1 July 2016 on a Mac running OS X 10.11.5
``El Capitain''.

\subsection{Installing on Mac OS X using Homebrew (brew)}
Homebrew is a package manager for OS X that provides a convenient
route to install all the QMCPACK dependencies. The
following recipe will install the latest available versions of each
package. This was successfully tested under OS X 10.12 ``Sierra'' in December 2017. Note that it is necessary to build the MPI software from
source to use the brew-provided gcc instead of Apple CLANG.

\begin{enumerate}
\item Install Homebrew from \url{http://brew.sh/}
\verbatimfont{\footnotesize}%
\begin{verbatim}
/usr/bin/ruby -e "$(curl -fsSL
    https://raw.githubusercontent.com/Homebrew/install/master/install)"
\end{verbatim}

\item Install the prerequisites
\verbatimfont{\footnotesize}%
\begin{verbatim}
brew install gcc # installs gcc 7.2.0 on 2017-12-19
export HOMEBREW_CXX=g++-7
export HOMEBREW_CC=gcc-7
brew install mpich2 --build-from-source
# Build from source required to use homebrew compiled compilers as
# opposed to Apple CLANG. Check "mpicc -v" indicates Homebrew gcc
brew install cmake
brew install fftw
brew install boost
brew install homebrew/science/hdf5
#Note: Libxml2 is not required via brew since OS X already includes it.
\end{verbatim}
\item Configure and build QMCPACK
\verbatimfont{\footnotesize}%
\begin{verbatim}
cmake -DCMAKE_C_COMPILER=/usr/local/bin/mpicc \
      -DCMAKE_CXX_COMPILER=/usr/local/bin/mpicxx ..
make -j 12
\end{verbatim}
\item Run the short tests. When MPICH is used for the first time, OS
  X will request approval of the network connection for each executable.
\verbatimfont{\footnotesize}%
\begin{verbatim}
ctest -R short
\end{verbatim}
\end{enumerate}

\subsection{Installing on ANL ALCF Mira/Cetus IBM Blue Gene/Q}
\label{sec:buildbgq}
Mira/Cetus is a Blue Gene/Q supercomputer at Argonne National Laboratory's Argonne Leadership Computing Facility (ANL ALCF).
Mira has 49152 compute nodes and each node has a 16-core PowerPC A2 processor with 16 GB DDR3 memory.
Due to the fact that the login nodes and the compute nodes have different processors with distinct instruction sets,
cross-compiling is required on this platform. See details about using Blue Gene/Q at \url{http://www.alcf.anl.gov/user-guides/compiling-linking}.
On Mira, compilers are loaded via softenv and users need to add +mpiwrapper-bgclang and +cmake in \$HOME/.soft.
In order to build QMCPACK, a toolchain file is provided for setting up CMake.
\textbf{BGClang is required for C++11 support. IBM XL C/C++ compiler should not be used.}

\verbatimfont{\footnotesize}%
\begin{verbatim}
cd build
cmake -DCMAKE_TOOLCHAIN_FILE=../config/BGQ_Clang++11_ToolChain.cmake ..
make -j 16
ls -l bin/qmcpack
\end{verbatim}

\subsection{Installing on ALCF Theta, Cray XC40}
Theta is a 9.65 petaflops system manufactured by Cray with 3624 compute nodes.
Each node features a second-generation Intel Xeon Phi 7230 processor and 192 GB DDR4 RAM.

\verbatimfont{\footnotesize}%
\begin{verbatim}
export CRAYPE_LINK_TYPE=dynamic
module unload cray-libsci
module load cray-hdf5-parallel
export BOOST_ROOT=/soft/libraries/boost/1.64.0/intel
cmake ..
make -j 24
ls -l bin/qmcpack
\end{verbatim}

\subsection{Installing on ORNL OLCF Titan Cray XK7 (NVIDIA GPU
  accelerated)}
\label{sec:titanbuildgpu}
Titan is a GPU accelerated supercomputer at Oak Ridge National
Laboratory's  Oak Ridge Leadership Computing Facility  (ORNL OLCF). Each
compute node has a 16 core AMD 2.2GHz Opteron 6274 (Interlagos) and an
NVIDIA Kepler accelerator. The standard Cray software environment is
available, with libraries accessed via modules. The only extra
settings required to build the GPU version are the cudatoolkit module
and specifying -DQMC\_CUDA=1 on the cmake configure line.

Note that on Crays the compiler wrappers ``CC'' and ``cc'' are
used. The build system checks for these and does not (should not) use
the compilers directly.

\verbatimfont{\footnotesize}%
\begin{verbatim}
export CRAYPE_LINK_TYPE=dynamic
module swap PrgEnv-pgi PrgEnv-gnu # Use gnu compilers
module load cudatoolkit           # CUDA for GPU build
module load cray-hdf5-parallel
module load cmake3
module load fftw
export FFTW_HOME=$FFTW_DIR/..
module load boost
mkdir build_titan_gpu
cd build_titan_gpu
export CC=cc
export CXX=CC
cmake -DQMC_CUDA=1 ..             # Must enable CUDA capabilities
make -j 8
ls -l bin/qmcpack
\end{verbatim}

\subsection{Installing on ORNL OLCF Titan Cray XK7 (CPU version)}
As noted in Section\ref{sec:titanbuildgpu} for the GPU, building on
Crays requires only loading the appropriate library modules.

\verbatimfont{\footnotesize}%
\begin{verbatim}
export CRAYPE_LINK_TYPE=dynamic
module swap PrgEnv-pgi PrgEnv-gnu # Use gnu compilers
module unload cudatoolkit         # No CUDA for CPU build
module load cray-hdf5-parallel
module load cmake3
module load fftw
export FFTW_HOME=$FFTW_DIR/..
module load boost
mkdir build_titan_cpu
cd build_titan_cpu
export CC=cc
export CXX=CC
cmake ..
make -j 8
ls -l bin/qmcpack
\end{verbatim}

\subsection{Installing on ORNL OLCF Eos Cray XC30}
Eos is a Cray XC30 with 16 core Intel Xeon E5-2670 processors connected
by the Aries interconnect. The build process is identical to Titan,
except that we use the default Intel programming environment. This is
usually preferred to GNU.
\verbatimfont{\footnotesize}
\begin{verbatim}
export CRAYPE_LINK_TYPE=dynamic
module unload cray-libsci
module load cray-hdf5
module load cmake
module load fftw
export FFTW_HOME=$FFTW_DIR/..
module load boost
mkdir build_eos
cd build_eos
cmake ..
make -j 8
ls -l bin/qmcpack
\end{verbatim}

\subsection{Installing on ORNL OLCF SummitDev}
SummitDev is the development cluster for the next GPU accelerated
supercomputer Summit at Oak Ridge National Laboratory's
Leadership Computing Facility  (ORNL OLCF). It has IBM Power8 CPUs and NVIDIA Pascal GPUs.

\subsubsection{Building QMCPACK}
Please note that these build instructions are preliminary as the
software environment is subject to change. QMCPACK can be build with the following commands:
\verbatimfont{\footnotesize}
\begin{verbatim}
module load xl
module load essl
module load netlib-lapack
module load hdf5/1.8.18
module load fftw
export FFTW_HOME=$OLCF_FFTW_ROOT
module load python
module load cmake
module load boost
module load cuda
mkdir build_summitdev
cd build_summitdev
cmake -DCMAKE_C_COMPILER="mpixlc" \
      -DCMAKE_CXX_COMPILER="mpixlC" \
      -DBUILD_LMYENGINE_INTERFACE=0 \
      -DQMC_CUDA=1 \
      -DCUDA_ARCH="sm_60" \
      ..
make -j 8
ls -l bin/qmcpack
\end{verbatim}

\subsection{Installing on NERSC Edison Cray XC30}

Edison is a Cray XC30 with dual 12-core Intel "Ivy Bridge" nodes
installed at NERSC. The build settings are identical to eos.

\verbatimfont{\footnotesize}
\begin{verbatim}
export CRAYPE_LINK_TYPE=dynamic
module unload cray-libsci
module load boost
module load cmake
module load libxml2
module load cray-hdf5-parallel
cmake ..
make -j 8
ls -l bin/qmcpack
\end{verbatim}
When the above was tested on 15 September 2017, the following module and
software versions were present:
\verbatimfont{\footnotesize}
\begin{verbatim}
qmcpack@edison04:trunk> module list
urrently Loaded Modulefiles:
  1) modules/3.2.10.6                              14) rca/2.2.11-6.0.4.0_13.2__g84de67a.ari
  2) intel/17.0.2.174                              15) atp/2.1.1
  3) craype-network-aries                          16) PrgEnv-intel/6.0.4
  4) craype/2.5.12.3                               17) craype-ivybridge
  5) udreg/2.3.2-6.0.4.0_12.2__g2f9c3ee.ari        18) cray-shmem/7.6.0
  6) ugni/6.0.14-6.0.4.0_14.1__ge7db4a2.ari        19) cray-mpich/7.6.0
  7) pmi/5.0.12                                    20) altd/2.0
  8) dmapp/7.1.1-6.0.4.0_46.2__gb8abda2.ari        21) darshan/3.1.4
  9) gni-headers/5.0.11-6.0.4.0_7.2__g7136988.ari  22) boost/1.63
 10) xpmem/2.2.2-6.0.4.0_3.1__g43b0535.ari         23) cmake/3.8.1
 11) job/2.2.2-6.0.4.0_8.2__g3c644b5.ari           24) cray-hdf5-parallel/1.10.0.3
 12) dvs/2.7_2.2.30-6.0.4.1_5.4__gd731684          25) libxml2/2.9.4
 13) alps/6.4.1-6.0.4.0_7.2__g86d0f3d.ari
\end{verbatim}

\subsection{Installing on NERSC Cori, Haswell Partition, Cray XC40}
Cori is a Cray XC40 with 16-core Intel "Haswell" nodes
installed at NERSC.

\verbatimfont{\footnotesize}
\begin{verbatim}
export CRAYPE_LINK_TYPE=dynamic
module unload cray-libsci
module load boost
module load cray-hdf5-parallel
module load cmake
mkdir build_cori_hsw
cd build_cori_hsw
cmake ..
make -j 16
ls -l bin/qmcpack
\end{verbatim}

When the above was tested on 29 August 2017, the following module and
software versions were present:

\verbatimfont{\footnotesize}
\begin{verbatim}
build_cori_hsw> module list
Currently Loaded Modulefiles:
  1) modules/3.2.10.6                              14) alps/6.4.1-6.0.4.0_7.2__g86d0f3d.ari
  2) nsg/1.2.0                                     15) rca/2.2.11-6.0.4.0_13.2__g84de67a.ari
  3) intel/17.0.2.174                              16) atp/2.1.1
  4) craype-network-aries                          17) PrgEnv-intel/6.0.4
  5) craype/2.5.12                                 18) craype-haswell
  6) udreg/2.3.2-6.0.4.0_12.2__g2f9c3ee.ari        19) cray-shmem/7.6.0
  7) ugni/6.0.14-6.0.4.0_14.1__ge7db4a2.ari        20) cray-mpich/7.6.0
  8) pmi/5.0.12                                    21) altd/2.0
  9) dmapp/7.1.1-6.0.4.0_46.2__gb8abda2.ari        22) darshan/3.1.4
 10) gni-headers/5.0.11-6.0.4.0_7.2__g7136988.ari  23) boost/1.61
 11) xpmem/2.2.2-6.0.4.0_3.1__g43b0535.ari         24) cmake/3.3.2
 12) job/2.2.2-6.0.4.0_8.2__g3c644b5.ari           25) cray-hdf5-parallel/1.10.0.3
 13) dvs/2.7_2.2.31-6.0.4.1_6.1__gb3b87e6
\end{verbatim}

\subsection{Installing on NERSC Cori, Xeon Phi KNL partition, Cray XC40}
The second phase of NERSC's Cori uses Intel
Xeon Phi Knight's Landing (KNL) nodes. The following build recipe ensures that the code
generation is appropriate for the KNL nodes:

\verbatimfont{\footnotesize}
\begin{verbatim}
export CRAYPE_LINK_TYPE=dynamic
module swap craype-haswell craype-mic-knl
module unload cray-libsci
module load boost
module load cray-hdf5-parallel
module load cmake
mkdir build_cori_knl
cd build_cori_knl
cmake ..
make -j 16
ls -l bin/qmcpack
\end{verbatim}

When the above was tested on 29 August 2017, the following module and
software versions were present:

\verbatimfont{\footnotesize}
\begin{verbatim}
build_cori_knl> module list
Currently Loaded Modulefiles:
  1) modules/3.2.10.6                              10) gni-headers/5.0.11-6.0.4.0_7.2__g7136988.ari  19) cray-shmem/7.6.0
  2) nsg/1.2.0                                     11) xpmem/2.2.2-6.0.4.0_3.1__g43b0535.ari         20) cray-mpich/7.6.0
  3) intel/17.0.2.174                              12) job/2.2.2-6.0.4.0_8.2__g3c644b5.ari           21) altd/2.0
  4) craype-network-aries                          13) dvs/2.7_2.2.31-6.0.4.1_6.1__gb3b87e6          22) darshan/3.1.4
  5) craype/2.5.12                                 14) alps/6.4.1-6.0.4.0_7.2__g86d0f3d.ari          23) boost/1.61
  6) udreg/2.3.2-6.0.4.0_12.2__g2f9c3ee.ari        15) rca/2.2.11-6.0.4.0_13.2__g84de67a.ari         24) cray-hdf5-parallel/1.10.0.3
  7) ugni/6.0.14-6.0.4.0_14.1__ge7db4a2.ari        16) atp/2.1.1                                     25) cmake/3.3.2
  8) pmi/5.0.12                                    17) PrgEnv-intel/6.0.4
  9) dmapp/7.1.1-6.0.4.0_46.2__gb8abda2.ari        18) craype-mic-knl
\end{verbatim}

\subsection{Installing on Windows}
Install the Windows Subsystem for Linux and Bash on Windows.
Open a bash shell and follow the install directions for Ubuntu in Section \ref{sec:buildubuntu}.

\section{Installing via Spack (Beta)}
Spack is a relatively new package manager for scientific software.
One of goals of Spack is to reduce the barrier for the user to install scientific
software. Spack is intended to work on everything from laptop
computers to high-end supercomputers. More information about Spack can
be found here \url{https://spack.readthedocs.io/en/latest}. The major
advantage of installation with Spack is that all dependencies are
automatically built, potentially including all the compilers and libraries, and
different versions of QMCPACK can easily co-exist with each other.
The QMCPACK Spack package also knows how to build
and patch Quantum Espresso automatically. In principle QMCPACK may be installed with
a single Spack command, but to use vendor optimized compilers and libraries requires
additional configuration.

\subsection{Setting up the Spack Environment}
Begin by cloning Spack from GitHub and configuring your shell as described
here:
\url{https://spack.readthedocs.io/en/latest/getting_started.html}.

The goal of the next several steps is to set-up the Spack environment
for building. Firstly, it is highly recommended to limit the number of build jobs to
a reasonable value for your machine. This can be
accomplished by modifying your \texttt{~/.spack/config.yaml} file as follows:
\verbatimfont{\footnotesize}
\begin{verbatim}
config:
  build_jobs: 16
\end{verbatim}

Next, make sure any existing compilers are properly detected. For many
architectures, compilers are properly detected with no additional
effort.
\verbatimfont{\footnotesize}
\begin{verbatim}
your-laptop> spack compilers
==> Available compilers
-- gcc sierra-x86_64 --------------------------------------------
gcc@7.2.0  gcc@6.4.0  gcc@5.5.0  gcc@4.9.4  gcc@4.8.5  gcc@4.7.4  gcc@4.6.4
\end{verbatim}

However, if your compiler is not automatically detected, it is straightforward
to add one:
\verbatimfont{\footnotesize}
\begin{verbatim}
your-laptop> spack compiler add <path-to-compiler>
\end{verbatim}

This last step is the most troublesome. Pre-installed packages are not
automatically detected. If vendor optimized libraries and already installed,
you will need to manually add them to your
\texttt{~/.spack/packages.yaml}. For example, this works on Mac OS X for the Intel MKL package.
\verbatimfont{\footnotesize}
\begin{verbatim}
your-laptop> cat ~/.spack/packages.yaml
packages:
    intel-mkl:
        paths:
            intel-mkl@2018.0.128: /opt/intel/compilers_and_libraries_2018.0.104/mac
        buildable: False
\end{verbatim}

Some trial-and-error may be involved to get the directory correct. If
you do not include enough of the tree path, Spack will not be able to
register the package in its database. More information about system
packages can be found here

\url{http://spack.readthedocs.io/en/latest/getting_started.html#system-packages}

\subsection{Building QMCPACK}
The QMCPACK Spack package has a number of variants to support different compile time
options and different versions of the application. A full list can be displayed by typing:
\verbatimfont{\footnotesize}
\begin{verbatim}
your laptop> spack info qmcpack
Description:
    QMCPACK, is a modern high-performance open-source Quantum Monte Carlo
    (QMC) simulation code.

Homepage: http://www.qmcpack.org/

Tags:
    None

Preferred version:
    3.4.0      [git] https://github.com/QMCPACK/qmcpack.git

Safe versions:
    develop    [git] https://github.com/QMCPACK/qmcpack.git
    3.4.0      [git] https://github.com/QMCPACK/qmcpack.git
    3.3.0      [git] https://github.com/QMCPACK/qmcpack.git
    3.2.0      [git] https://github.com/QMCPACK/qmcpack.git
    3.1.1      [git] https://github.com/QMCPACK/qmcpack.git
    3.1.0      [git] https://github.com/QMCPACK/qmcpack.git

Variants:
    Name [Default]                 Allowed values          Description


    build_type [RelWithDebInfo]    Debug, Release,         CMake build type
                                   RelWithDebInfo,
                                   MinSizeRel
    complex [off]                  True, False             Build the complex (general
                                                           twist/k-point) version
    cuda [off]                     True, False             Enable CUDA and GPU
                                                           acceleration
    da [off]                       True, False             Install with support for basic
                                                           data analysis tools
    debug [off]                    True, False             Build debug version
    gui [off]                      True, False             Install with Matplotlib (long
                                                           installation time)
    mixed [off]                    True, False             Build the mixed precision
                                                           (mixture of single and double
                                                           precision) version for gpu and
                                                           cpu
    mpi [on]                       True, False             Build with MPI support
    qe [on]                        True, False             Install with patched Quantum
                                                           Espresso 5.3.0
    soa [off]                      True, False             Build with Structure-of-Array
                                                           instead of Array-of-Structure
                                                           code. Only for CPU codeand
                                                           only in mixed precision
    timers [off]                   True, False             Build with support for timers

Installation Phases:
    cmake    build    install

Build Dependencies:
    blas  boost  cmake  cuda  espresso  fftw  hdf5  lapack  libxml2  mpi

Link Dependencies:
    blas  boost  cuda  espresso  fftw  hdf5  lapack  libxml2  mpi

Run Dependencies:
    py-matplotlib  py-numpy

Virtual Packages:
    None
\end{verbatim}

For example, to install the complex version of QMCPACK in mixed-precision use:
\verbatimfont{\footnotesize}
\begin{verbatim}
your-laptop> spack install qmcpack+mixed+complex%gcc@7.2.0 ^intel-mkl
\end{verbatim}
where
\verbatimfont{\footnotesize}
\begin{verbatim}
%gcc@7.2.0
\end{verbatim}
specifies the compiler version to be used and
\verbatimfont{\footnotesize}
\begin{verbatim}
^intel-mkl
\end{verbatim}
specifies the Intel MKL should be used as the BLAS and LAPACK provider.

It is also possible to run the QMCPACK regression tests as part of the
installation process, for example:
\verbatimfont{\footnotesize}
\begin{verbatim}
your-laptop> spack install --test=root qmcpack+mixed+complex%gcc@7.2.0 ^intel-mkl
\end{verbatim}
will run the unit and short tests. The current behavior of the QMCPACK
Spack package is to completed the install as long as all the unit tests
pass. If the short tests fail, a warning is issued at the command prompt.

\subsection{Loading QMCPACK into your environment}
Spack does not set-up an environment to find its packages
automatically. A few additional steps are needed. First, install the
modules package by executing:
\verbatimfont{\footnotesize}
\begin{verbatim}
your-laptop> spack install environment-modules
\end{verbatim}

Then modify your\texttt{ ~/.cshrc} file with something like
\verbatimfont{\footnotesize}
\begin{verbatim}
source ${HOME}/spack/opt/spack/darwin-sierra-x86_64/\
          clang-7.3.0-apple/environment-modules-3.2.10-kenvhysdws4zw26tvbrjl37fdyn7inhb/\
          Modules/init/csh
\end{verbatim}

You should then be able to load the qmcpack binary into your path by
invoking
\verbatimfont{\footnotesize}
\begin{verbatim}
your-laptop> spack load qmcpack+mixed+complex%gcc@7.2.0
\end{verbatim}
or more generally
\verbatimfont{\footnotesize}
\begin{verbatim}
your-laptop> spack load qmcpack+<spec>
\end{verbatim}

\subsection{Installing QMCPACK with Spack on Linux}
Spack works robustly on the standard flavors of Linux (Ubuntu, CentOS,
Ubuntu, etc.) using GCC or Intel compilers.

\subsection{Installing QMCPACK with Spack on Mac OS X}
Spack works on Mac OS X, but requires installation of a few packages
using Homebrew. You will need to install at minimum the GCC compilers,
CMake, and pkg-config. Intel compiler for Mac on OS X is not well
supported by Spack packages and will most likely lead to a compile
time failure in one of QMCPACK's dependencies.

\subsection{Installing QMCPACK with Spack on IBM Blue Gene}
Untested at this time. In principle, it should work as long as each of
package found in
\verbatimfont{\footnotesize}
\begin{verbatim}
Blue Gene prompt> spack spec qmcpack
\end{verbatim}
can be compiled for the compute nodes.

\subsection{Installing QMCPACK with Spack on Cray Supercomputers}
There are a number of issues in the Cray module environment. Spack
contributors are working to fix these problems. We will update this
section once we have a recipe that works reliably.

\subsection{Reporting Bugs}
Bugs with the QMCPACK Spack package should be filed as a GitHub issue
against this fork \url{https://github.com/naromero77/spack}

\section{Testing and validation of QMCPACK}
\label{sec:testing}
We \textbf{strongly encourage} running the included tests each time
QMCPACK is built. These compare the results from the executable with
known-good mean-field, quantum chemical, and other QMC results.

The tests included with QMCPACK currently mainly test the VMC code with
single determinant wavefunction and simple spline Jastrow
wavefunctions, and for gaussian and periodic spline basis
sets. We check that the known mean
field results are obtained with no Jastrow. When Jastrow functions are
included we test against previous QMC data. The tests are statistical
with a generous 3 $\sigma$ tolerance, however the system sizes are
small, typically $<10$ electrons, so the error bars are typically
small. Limited DMC and optimizer tests included and are scheduled for expansion.

 The ``short'' tests only take a few minutes on a 16
core machine. You can run these tests using the command below in the
build directory:

\verbatimfont{\footnotesize}
\begin{verbatim}
ctest -R short   # Run the tests with "short" in their name
\end{verbatim}
The output should be similar to the following:
\verbatimfont{\footnotesize}
\begin{verbatim}
Test project build_gcc
      Start  1: short-LiH_dimer_ae-vmc_hf_noj-16-1
 1/44 Test  #1: short-LiH_dimer_ae-vmc_hf_noj-16-1 ..............  Passed   11.20 sec
      Start  2: short-LiH_dimer_ae-vmc_hf_noj-16-1-kinetic
 2/44 Test  #2: short-LiH_dimer_ae-vmc_hf_noj-16-1-kinetic ......  Passed    0.13 sec
..
42/44 Test #42: short-monoO_1x1x1_pp-vmc_sdj-1-16 ...............  Passed   10.02 sec
      Start 43: short-monoO_1x1x1_pp-vmc_sdj-1-16-totenergy
43/44 Test #43: short-monoO_1x1x1_pp-vmc_sdj-1-16-totenergy .....  Passed    0.08 sec
      Start 44: short-monoO_1x1x1_pp-vmc_sdj-1-16-samples
44/44 Test #44: short-monoO_1x1x1_pp-vmc_sdj-1-16-samples .......  Passed    0.08 sec

100% tests passed, 0 tests failed out of 44

Total Test time (real) = 167.14 sec
\end{verbatim}
Note that the number of tests that are run varies between the
standard, complex, and GPU compilations.

The  full set of tests consist of significantly longer versions of the short
tests, as well as tests of the conversion utilities. The runs require
several hours each for improved statistics and a much more
stringent test of the code. To run all the tests simply run ctest in the build
directory:

\verbatimfont{\footnotesize}
\begin{verbatim}
ctest            # Run all the tests. This will take several hours.
\end{verbatim}

You can also run verbose tests which direct the QMCPACK
output to the standard output:
\verbatimfont{\footnotesize}
\begin{verbatim}
ctest -V -R short   # Verbose short tests
\end{verbatim}

The test system includes specific tests for the complex version of the code.

The input data files for the tests are located in the \texttt{tests} directory.
The system-level test directories are grouped into \texttt{heg}, \texttt{molecules}, and \texttt{solids}, with particular physical systems under each (for example \texttt{molecules/H4\_ae}
\footnote{The suffix `ae' is short for `all-electron' and `pp' is short for `pseudopotential'}).
Under each physical system directory there may be tests for multiple QMC methods or parameter variations.
The numerical comparisons and test definitions are in the \texttt{CMakeLists.txt} file in each physical system directory.

If \textit{all} the QMC tests fail it is likely
that the appropriate mpiexec (or aprun, srun) is not being
called or found. If the QMC runs appear to work but all the other
tests fail it is possible that python is not working on your system -
we suggest checking some of the test console output in \texttt{build/Testing/Temporary/LastTest.log}
or the output files under \texttt{build/tests/}.
%The runs occur in \texttt{build/tests/test\_dir/test\_name}.


Note that because most of these tests are very small, consisting of only a few
electrons, the performance is not representative of larger
calculations. For example, while the calculations might fit in cache,
there will be essentially no vectorization due to the small electron
counts. \textbf{These tests should therefore not be used for any benchmarking or
performance analysis}.

Example runs that can be used for testing performance are described in
Sec. \ref{sec:perftests}

\subsection{Unit tests}

QMCPACK has a set of unit tests.
All of the unit tests can be run with the following command (in the build directory):
\verbatimfont{\footnotesize}
\begin{verbatim}
ctest -L unit
\end{verbatim}

The output should look similar to the following:
\verbatimfont{\footnotesize}
\begin{verbatim}
Test project qmcpack/build
      Start  1: unit_test_numerics
 1/11 Test  #1: unit_test_numerics ...............   Passed    0.06 sec
      Start  2: unit_test_utilities
 2/11 Test  #2: unit_test_utilities ..............   Passed    0.02 sec
      Start  3: unit_test_einspline
 ...
10/11 Test #10: unit_test_hamiltonian ............   Passed    1.88 sec
      Start 11: unit_test_drivers
11/11 Test #11: unit_test_drivers ................   Passed    0.01 sec

100% tests passed, 0 tests failed out of 11

Label Time Summary:
unit    =   2.20 sec

Total Test time (real) =   2.31 sec
\end{verbatim}

Individual unit test executables can be found in \texttt{build/tests/bin}.
The source for the unit tests is located in the \texttt{tests} directory under each directory in \texttt{src} (e.g. \texttt{src/QMCWavefunctions/tests}).

See Chapter \ref{chap:unit_testing} for more details about unit tests.

\subsection{Integration tests with Quantum Espresso}
\label{sec:integtestqe}
As described in Sec. \ref{sec:buildqe}, it is possible to test entire
workflows of trial wavefunction generation, conversion, and eventual
QMC calculation. A patched QE must be installed so that the
pw2qmcpack converter is available.

By adding \texttt{-D QE\_BIN=your\_QE\_binary\_path} in the cmake command line when building your QMCPACK,
tests named with ``qe-'' prefix will be included in the test set of your build.
You can test the whole pw$\to$pw2qmcpack$\to$qmcpack workflow by
\verbatimfont{\footnotesize}
\begin{verbatim}
ctest -R qe
\end{verbatim}
This provides a very solid test of the entire QMC
toolchain for plane wave generated wavefunctions.

\subsection{Performance tests}
\label{sec:perftests}
Performance tests representative of real research runs are included in the
tests/performance directory. They can be used for benchmarking, comparing machine
performance, or assessing optimizations. This is in
contrast to the majority of the conventional integration tests where the particle
counts are too small to be representative. Care is still needed to
remove initialization, I/O, and compute a representative performance
measure.

The ctest integration is sufficient to run the benchmarks and measure
relative performance from version to version of QMCPACK and assess
proposed code changes. Performance tests are prefixed with
``performance''. To obtain highest performance on a particular
platform, you must run the benchmarks in a standalone manner and tune
thread counts, placement, walker count (etc.) This is essential to
fairly compare different machines. Check with the
developers if you are unsure of what is a fair change.

\subsubsection{NiO performance tests}

Follow the instructions in tests/performance/NiO/README to
enable and run the NiO tests.

The NiO tests are for bulk supercells of varying size. The QMC runs consist of short blocks of (i) VMC
without drift (ii) VMC with drift term included (iii) DMC with
constant population. The tests use spline wavefunctions that must be
downloaded as described in the README due to their large size. You
will need to set ``-DQMC\_DATA=YOUR\_DATA\_FOLDER -DENABLE\_TIMERS=1''
when running cmake as
described in the README.

Two sets of wavefunction are tested: spline orbitals with a one and
two body Jastrow functions, and a more complex form with an additional
three body Jastrow function. The Jastrows are the same for each run
and are not reoptimized, as might be done for research purposes.  Runs
in the hundreds of electrons up to low thousands of electrons are representative of
research runs performed in 2017. The largest runs target
future machines and require very large memory.

\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
\bfseries Performance Test Name&  \bfseries Historical name &\bfseries Atoms& \bfseries Electrons&  \bfseries Electrons/spin \\
\hline
performance-NiO-cpu-a32-e384  & S8 & 32 & 384 & 192 \\
performance-NiO-cpu-a64-e768  & S16 & 64 & 768 & 384 \\
performance-NiO-cpu-a128-e1536 & S32 & 128 & 1536 & 768 \\
performance-NiO-cpu-a256-e3072 & S64 & 256 & 3072 & 1536 \\
performance-NiO-cpu-a512-e6144 & S128 & 512 & 6144 & 3072 \\
performance-NiO-cpu-a1024-e12288& S256 & 1024 & 12288 & 6144 \\
\hline
\end{tabular}
  \caption{System sizes and names for NiO performance tests. GPU performance
    tests are named similarly but have different walker counts.}
  \label{tab:niotests}
\end{center}
\end{table}

\subsection{Troubleshooting tests}
ctest reports briefly pass or fail of tests in printout and also collects all the standard outputs to help investigating how tests fail.
If the ctest execution is completed, look at \texttt{Testing/Temporary/LastTest.log}.
If you manually stop the testing (ctrl+c), look at \texttt{Testing/Temporary/LastTest.log.tmp}.
You can locate the failing tests by searching for the key word `Fail'.

\subsection{Slow testing with OpenMPI}
OpenMPI has a default binding policy making all the threads running on a single core during testing when there are two or fewer MPI ranks.
This significantly increases the testing time. If you are authorized to change the default setting, you can just add `hwloc\_base\_binding\_policy=none' in /etc/openmpi/openmpi-mca-params.conf.

\section{Automated testing of QMCPACK}

The QMCPACK developers run automatic tests of QMCPACK on several
different computer systems,  many on a continuous basis. See reports at
\url{https://cdash.qmcpack.org/CDash/index.php?project=QMCPACK}.
We currently test
the following combinations nightly (workstations) and weekly (supercomputers):

\begin{itemize}
\item On a Linux Intel Xeon workstation:
  \begin{itemize}
  \item GCC 4.8.5 with OpenMPI and CUDA 8.0 (GPU build, run on NVIDIA K40s)
  \item GCC 4.8.5 with OpenMPI with Netlib BLAS
  \item GCC 4.8.5 with OpenMPI with Intel MKL
  \item Intel 2017 with Intel MPI and MKL
  \item Intel 2015 with Intel MPI and MKL and CUDA 8.0 (GPU build, run on NVIDIA K40s)
  \item Intel 2015 with Intel MPI  and MKL
  \end{itemize}
\item On a Linux Intel Knight's Landing workstation:
  \begin{itemize}
  \item Intel 2017 with Intel MPI and MKL
 \item GCC 4.8.5 with Intel MPI and MKL
  \end{itemize}
\item On Eos, a Cray XC30 Intel machine:
  \begin{itemize}
\item The default Intel programming environment and compiler with Cray MPI and Intel MKL
  \end{itemize}

\item On Titan, a Cray XK7 CPU+GPU machine:
  \begin{itemize}
  \item The GCC programming environment and compiler with Cray MPI and CUDA
  \item The GCC programming environment and compiler with Cray MPI
  \end{itemize}
\item On Cetus, an IBM Blue Gene Q machine:
\begin{itemize}
\item Blue Gene Clang 4.0
\end{itemize}
\end{itemize}

\begin{figure}
  \centering
  \includegraphics[width=10cm]{./figures/QMCPACK_CDash_CTest_Results_20160129.png}
  \caption{Example test results for QMCPACK, showing data for a
    workstation (Intel, GCC, both CPU and GPU builds) and for two ORNL
    supercomputers. In this example, 4 errors were found. This
    dashboard is accessible at \url{https://cdash.qmcpack.org}.}
\end{figure}

\section{Building ppconvert, a pseudopotential format converter}
\label{sec:buildppconvert}
QMCPACK includes a utility, ppconvert, to convert between different
pseudopotential formats. Examples include effective core potential
formats (in Gaussians), the UPF format used by Quantum ESPRESSO, and
the XML format used by QMCPACK itself. The utility also enables the
atomic orbitals to recomputed via a numerical density functional
calculation if they need to be reconstructed for use in an
electronic structure calculation.

It is a stand alone C++ executable that is not built by default but accessible via adding
\texttt{-DBUILD\_PPCONVERT=1} to cmake and then typing \texttt{make ppconvert}.
Userguide is provided in section~\ref{sec:ppconvert}.

\section{Installing and patching Quantum ESPRESSO}
\label{sec:buildqe}
For trial wavefunctions obtained in a plane-wave basis we mainly
support Quantum ESPRESSO. Note that ABINIT and QBox were supported historically
and could be reactivated.

Quantum ESPRESSO currently stores wavefunctions in a non-standard internal
``save'' format. To convert these to a conventional HDF5 format file
we have developed a converter, pw2qmcpack. This is an add on to the
Quantum ESPRESSO distribution.

To simplify the process of patching Quantum ESPRESSO we have developed
a script that will automatically download and patch the source
code. The patches are specific to each version. e.g. To download and
patch QE v6.3:
\verbatimfont{\footnotesize}
\begin{verbatim}
cd external_codes/quantum_espresso
./download_and_patch_qe6.3.sh
\end{verbatim}
After running the patch, you must configure Quantum ESPRESSO with
the HDF5 capability enabled in either way:
\begin{itemize}
\item if your system already has HDF5 installed with Fortran, use the -{}-with-hdf5 configuration option.
\verbatimfont{\footnotesize}
\begin{verbatim}
cd qe-6.3
./configure --with-hdf5=/opt/local   # Specify HDF5 base directory
\end{verbatim}
   {\bf check} the end of configure output if HDF5 libraries are found properly.
   If not, either install a complete library or use the other scheme. If using a parallel HDF5 library, be sure to use
   the same MPI with QE as used to build the parallel HDF5 library.

   Currently HDF5 support in QE itself is preliminary. To enable use of pw2qmcpack
   but use the old non-HDF5 I/O within QE, replace \texttt{-D\_\_HDF5} with \texttt{-D\_\_HDF5\_C} in make.inc.
\item if your system has HDF5 with C only, manually edit make.inc by adding \texttt{-D\_\_HDF5\_C} and \texttt{-DH5\_USE\_16\_API}
   in \texttt{DFLAGS} and provide include and library path in \texttt{IFLAGS} and \texttt{HDF5\_LIB}
\end{itemize}

The complete process is described in external\_codes/quantum\_espresso/README.

The tests involving pw.x and pw2qmcpack.x have been integrated in the test suite of QMCPACK.
By adding \texttt{-D QE\_BIN=your\_QE\_binary\_path} in the cmake command line when building your QMCPACK,
tests named with ``qe-'' prefix will be included in the test set of your build.
You can test the whole pw$\to$pw2qmcpack$\to$qmcpack workflow by
\verbatimfont{\footnotesize}
\begin{verbatim}
ctest -R qe
\end{verbatim}
See Sec.\ref{sec:integtestqe} and the testing section for more details.

\section{How to build the fastest executable version of QMCPACK}
\label{sec:buildperformance}
To build the fastest version of QMCPACK we recommend the following:
\begin{itemize}
\item Use the latest C++ compilers available for your
  system. Substantial gains have been made optimizing C++ in recent
  years.
\item Use a vendor optimized BLAS library such as Intel MKL and AMD ACML. Although
  QMC does not make extensive use of linear algebra, it is used in the
  VMC wavefunction optimizer, to apply the orbital coefficients in local basis
  calculations, and in the Slater determinant update.
\item Use a vector math library such as Intel VML.  For periodic
  calculations, the calculation of the structure factor and Ewald
  potential benefit from vectorized evaluation of sin and
  cos. Currently we only autodetect Intel VML, as provided with MKL,
  but support for MASSV and AMD LibM is included via \#defines. See,
  e.g. src/Numerics/e2iphi.h. For
  large supercells, this optimization can gain 10\% in performance.
\end{itemize}

Note that greater speedups of QMC calculations can usually be obtained by
carefully choosing the required statistics for each
investigation. i.e. Do not compute smaller error bars than necessary.

\section{Troubleshooting the installation}
\label{sec:troubleshoot}
Some tips to help troubleshoot installations of QMCPACK:
\begin{itemize}
\item First, build QMCPACK on a workstation that you control, or on any
  system that has a simple and up-to-date set of development
  tools. You can compare the results of cmake and QMCPACK on this
  system with any more difficult systems you encounter.
\item Use up to date development software, particularly a recent
  CMake.
\item Verify that the compilers and libraries that you expect are
  being configured. It is common to have multiple versions
  installed. The configure system will stop at the first version it
  finds which might not be the most recent. If this occurs, specify the appropriate
  directories and files directly (Section
  \ref{sec:cmakeoptions}). e.g. cmake -DCMAKE\_C\_COMPILER=/full/path/to/mpicc -DCMAKE\_CXX\_COMPILER=/full/path/to/mpicxx ..
\item To monitor the compiler and linker settings, use a verbose build, ``make
  VERBOSE=1''. If an individual source file fails to compile you
  can experiment by hand using the output of the verbose build to
  reconstruct the full compilation line.
\end{itemize}

If you still have problems please post to the QMCPACK Google group with full
details, or contact a developer.
