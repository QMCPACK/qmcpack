\section{Reptation Monte Carlo}
\label{sec:rmc}
Like diffusion monte carlo, reptation monte carlo (RMC) is a projector based method, allowing us the ability to sample the fixed-node wavefunciton.  However, by exploiting the path-integral formulation of Schr\"{o}dinger's equation, the RMC algorithm can offer some advantages over traditional DMC, such as sampling both the mixed and pure fixed-node distributions in polynomial time, as well as not having population fluctuations and biases.  The current implementation does not work with T-moves.

There are two adjustable parameters that affect the quality of the RMC projection:  imaginary projection time $\beta$ of the sampling path (commonly called a ``reptile"), and the Trotter time step $\tau$.  $\beta$ must be chosen to be large enough such that $e^{-\beta \hat{H}}|\Psi_T\rangle \approx |\Phi_0\rangle$ for mixed observables, and $e^{-\frac{\beta}{2} \hat{H}}|\Psi_T\rangle \approx |\Phi_0\rangle$ for pure observables.  The reptile is discretized into $M=\beta/\tau$ beads at the cost of an $\mathcal{O}(\tau)$ time-step error for observables arising from the Trotter-Suzuki breakup of the short-time propagator.  

The following table lists some of the more practical 
\begin{table}[h]
\begin{center}
\begin{tabularx}{\textwidth}{l l l l l l }
\hline
\multicolumn{6}{l}{\texttt{vmc} method} \\
\hline
\multicolumn{2}{l}{parameters}  & \multicolumn{4}{l}{}\\
   &   \bfseries name     & \bfseries datatype & \bfseries values & \bfseries default   & \bfseries description \\
   &   \texttt{beta            } &  real  & $> 0$ & dep.   & reptile projection time $\beta$  \\
   &   \texttt{timestep            } &  real     & $> 0$ & 0.1 & Trotter time step $\tau$ for each electron move \\
   &   \texttt{beads           } &  int     & $> 0$ & 1 & Number of reptile beads $M=\beta/\tau$ \\
   &   \texttt{blocks              } &  integer  & $\ge 0$ & 1   & number of blocks            \\
   &   \texttt{steps               } &  integer  & $\ge 0$ & 1   & number of steps per block   \\
   &   \texttt{vmcpresteps        } &  integer  & $\ge 0$ & 0   & propagates reptile using VMC for given number of steps\\
   &   \texttt{warmupsteps         } &  integer  & $\ge 0$ & 0   & number of steps for warming up\\
   &   \texttt{MaxAge              }   & integer & $\ge 0 $   & 0   & force accept for stuck reptile if age exceeds MaxAge. \\
  \hline
\end{tabularx}
\end{center}
\end{table}

Additional information:

Because of the sampling differences between DMC ensembles of walkers and RMC reptiles, the RMC block should contain the following estimator declaration to ensure correct sampling:  \texttt{ <estimator name="RMC" hdf5="no">}. 
  
\begin{itemize}
\item \texttt{beta} or \texttt{beads}?  One can specify one or the other, and from the Trotter time-step, the code will construct an appropriately sized reptile.  If both are given, \texttt{beta} overrides \texttt{beads}.  

\item \textbf{Mixed vs. Pure observables?}  Configurations sampled by the endpoints of the reptile are distributed according to the mixed distribution $f(\mathbf{R})=\Psi_T(\mathbf{R})\Phi_0(\mathbf{R})$.  Any observable that is computable within DMC and is dumped to the scalar.dat file will likewise be found in the scalar.dat file generated by RMC, except there will be an appended \texttt{\_m} to alert the user that the observable was computed on the mixed distribution.  For pure observables, care must be taken in the interpretation.  If the observable is diagonal in the position basis (in layman's terms, if it is entirely computable from a single electron configuration $\mathbf{R}$, like the potential energy), and if the observable does not have an explicit dependence on the trial wavefunction (for example, the local energy has an explicit dependence on the trial wavefunction from the kinetic energy term), then pure estimates will be correctly computed.  These observables will be found in either the scalar.dat file, where they will be appended with a \texttt{\_p} suffix, or in the stat.h5 file.  No mixed estimators will be dumped to the h5 file. 

\item \textbf{Sampling}.  For pure estimators, one should check the traces of both pure and mixed estimates.  Ergodicity is a known problem in RMC.  Because we use the bounce algorithm, it is possible for the reptile to bounce back and forth without changing the electron coordinates of the central beads.  This might not easily show up with mixed estimators, since these are accumulated at constantly regrown ends, but pure estimates are accumulated on these central beads, and so can exhibit strong autocorrelations in pure estimate traces.  

\item \textbf{Propagator}:  Our implementation of RMC uses Moroni's DMC link action (symmetrized), with Umrigar's scaled drift near nodes.  In this regard, the propagator is identical to the one QMCPACK uses in DMC.  

\item \textbf{Sampling}:  We use Ceperley's bounce algorithm.  MaxAge is used in case the reptile gets stuck, at which point the code forces move acceptance, stops accumulating statistics, and requilibrates the reptile.  Very rarely will this be required.  For move proposals, we use particle-by-particle VMC a total of $N_e$ times to generate a new all-electron configuration, at which point the action is computed and the move is either accepted or rejected.  
\end{itemize}




