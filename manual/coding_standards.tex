\section{QMCPACK Coding Standards}

The following document presents best practices for the code at the current time. New development should follow these guidelines and contributors are expected to adhere to them for the sake of consistency in the code base. A well prepared PR should follow these standards before inclusion in the mainline. A Clang format file can be found in ? that should be run to fix and check the code style whenever possible.

Keep reformatting, feature, and bug commits separate whenever possible.  

\section{Files}
Each file should start with the header
\lstset{language=C++,style=C++}
\begin{lstlisting}
//////////////////////////////////////////////////////////////////////////////////////
// This file is distributed under the University of Illinois/NCSA Open Source License.
// See LICENSE file in top directory for details.
//
// Copyright (c) 2018 QMCPACK developers
//
// File developed by: Name, email, affiliation
//
// File created by: Name, email, affiliation
//////////////////////////////////////////////////////////////////////////////////////
\end{lstlisting}
If you make significant changes to an existing file, add yourself to the list of developed by authors.

\subsection{File organization}
Header files should be placed in the same directory as their implementations. 
Unit tests should be written for all new functionality. These tests should be placed in a \inlinecode{tests} subdirectory below the implementations.

\subsection{File Names}
Each class should be defined in a separate file whose name is the same as the class name. Use separate \inlinecode{.cpp} implementation files whenever possible to aid in incremental compilation. 

The filenames of tests are composed by the filename of the object tested and the prefix \inlinecode{test_}.
The filenames of \emph{fake} and \emph{mock} objects used in tests are composed by the prefixes \inlinecode{fake_} and \inlinecode{mock_}, respectively, and the filename of the object that is imitated.

\subsection{Header files}
All header files should be self-contained i.e. it is not dependent on following any other header when it is included. Nor should they include files that are not necessary for their use, i.e. headers only needed by the implementation. Implementation files should not include files only for the benefit of files they include.

There are many header files that violate this currently.
Each header must use \inlinecode{\#define} guards to prevent multiple inclusion.
The symbol name of the \inlinecode{\#define} guards should be \inlinecode{NAMESPACE(s)_CLASSNAME_H}.

\subsection{Includes}
Header files should be included with the full path based on the \verb|src| directory.
For example, the file \verb|qmcpack/src/QMCWaveFunctions/SPOSetBase.h| should be included as
\begin{lstlisting}
#include "QMCWaveFunctions/SPOSetBash.h"
\end{lstlisting}
Even if the included file is located in the same directory as the including file this rule should be obeyed. Header files from external projects and standard libraries should be includes using \inlinecode{<iostream>} convention, while headers that are part of the QMCPACK project should be included using the \verb|"our_header.h"| convention.

For readability it is suggested to use the standard order of includes:
\begin{enumerate}
	\item related header
	\item std C library headers
	\item std C++ library headers
	\item Other libraries' headers
	\item QMCPACK headers
\end{enumerate}

In each section the included files should be sorted in alphabetical order.

\section{Naming}
The balance between description and ease of implementation should be balanced such that the code remains self documenting within a single terminal window.  If an extremely short variable name is used its scope must be shorter than $\sim 40$ lines. An exception is made for template parameters which must be in all CAPS.

\subsection{Type and Class Names}

Type and class names should start with a capital letter and have a capital letter for each new word.
Underscores \inlinecode{_} are not allowed. 
\subsection{Namespace Names}

Namespace names should be one word, lowercase.

\subsection{Variable Names}

Variable names should not begin with a capital letter this is reserved for type and class names. Mixed caps or underscores to separate words are both permitable but only one convention should be used in a file.

\subsection{Class Data Members}

Class private/protected data members names should follow the convention of variable names with a trailing underscore \inlinecode{_}.

\subsection{Function Names}

Function names should start with a lowercase character and have a capital letter for each new word.

\subsection{Lambda Expressions}

Named lambda expressions follow the naming convention for variables:

\begin{lstlisting}[showspaces=false]
auto myWhatever = [](int i) { return i + 4; };
\end{lstlisting}

\subsection{Macro Names}

Macro names should be all uppercase and can include underscores (\inlinecode{_}).
The underscore is not allowed as first or last character.

\subsection{Test Case and Test Names}

\section{Comments}

\subsection{Comment Style}

Use the \inlinecode{// Comment} syntax for actual comments.
Use:
\begin{lstlisting}
/** base class for Single-particle orbital sets
 *
 * SPOSetBase stands for S(ingle)P(article)O(rbital)SetBase which contains
 * a number of single-particle orbitals with capabilities of
 * evaluating \f$ \psi_j({\bf r}_i)\f$
 */
\end{lstlisting}
or
\begin{lstlisting}
///index in the builder list of sposets
int builder_index;
\end{lstlisting}

\subsection{Documentation}
Doxygen will be used for source documentation. Doxygen commands should be used when appropriate guidance on this TBD.

\subsubsection{File Docs}
Do not put the file name after the \verb|\file| doxygen command. Doxygen will fill it in for the file the tag appears in.
\begin{lstlisting}
/** \file
 *  File level documentation 
 */
\end{lstlisting}

\subsubsection{Class Docs}
Every class should have a short description (in the header of the file) of what it is and what is does.
Comments for public class member functions follow the same rules as general function comments.
Comments for private members are allowed, but not mandatory.

\subsubsection{Function Docs}
For function parameters whose type is non-const reference or pointer to non-const memory,
it should be specified if they are input (In:), output (Out:) or input-output parameters (InOut:).

Example:
\begin{lstlisting}
/** Updates foo and computes bar using in_1 .. in_5.
 * \param[in] in_3
 * \param[in] in_5
 * \param[in,out] foo
 * \param[out] bar
 */

//This is probably not what our clang-format would do
void computeFooBar(Type in_1, const Type& in_2, Type& in_3,
                   const Type* in_4, Type* in_5, Type& foo,
                   Type& bar);
\end{lstlisting}

\subsubsection{Variable Documentation}
Name should be self-descriptive.  If you need documentation consider renaming first.

\subsubsection{Golden Rule of Comments}
If you modify a piece of code, also adapt the comments that belong to it if necessary.

\section{Formatting}
Use the provided clang-format style in \inlinecode{config/.clang-format} to format \verb|.h|, \verb|.hpp|, \verb|.cu| and \verb|.cpp| files. In general you should run clang-format on every file you modify, however if it hasn't been run on the file before, you should make a separate reformat PR and rebase your changes onto that.  We do not want reformatting and change commits mixed.

The following should cover the formats specified.
\subsection{Line Length}
The length of each line of your code should, in principle, be at most \emph{120} characters.

\subsection{Horizontal Spacing}
No trailing whitespaces should be added to any line.
Use no space before a comma (\inlinecode{,}) and a semicolon (\inlinecode{;}) and add a space after them if they are not at the end of a line.

\subsubsection{Binary Operators}
The assignment operator should always have spaces around it.
Other operators may have spaces around them, but it is not mandatory.

\subsubsection{Unary Operators}
Do not put any space between an unary operator and their argument.

\subsubsection{Types}
The \inlinecode{using} syntax is preferred to \inlinecode{typedef} for type aliases.
If the actual type is not excessively long or complex simple just use it.

The angle brackets of templates should not have any external and internal padding.
Pointer or Reference operators should go with the type.
Examples:
\begin{lstlisting}
Type* var;
Type& var;

Class1<Class2<type1>> object;
\end{lstlisting}

\subsection{Vertical Spacing}
Use empty lines when it helps to improve the readability of the code, but do not use too many.
Do not use empty lines after a brace which opens a scope,
or before a brace which closes a scope.
Each file should contain an empty line at the end of the file.
Some editors add an empty line automatically, some do not.

\subsection{Indentation}
Indentation consists of 2 spaces.
Do not use tabs in the code.

\subsection{Variable Declarations and Definitions}

\begin{itemize}
\item Avoid declaring multiple variables in the same declaration, especially if they are not fundamental types:

\begin{lstlisting}[showspaces=false]
int x, y;                        // Not recommended.
Matrix a("my-matrix"), b(size);  // Disallowed.

// Preferred way.
int x;
int y;
Matrix a("my-matrix");
Matrix b(10);
\end{lstlisting}

\item Use the following order for keywords and modifiers in  variable declarations:

\begin{lstlisting}[showspaces=false]
// General type
[static] [const/constexpr] Type variable_name;

// Pointer
[static] [const] Type* [const] variable_name;

// Integer
// int is optional, if a signedness or size modifier is present.
[static] [const/constexpr] [signedness] [size] int variable_name;

// Examples:
static const Matrix a(10);
const double* const d(3.14);
constexpr unsigned long l(42);
\end{lstlisting}

\end{itemize}

\subsection{Function Declarations and Definitions}

The return type should be on the same line as the function name.
Parameters should be on the same line, too, unless they do not fit on it.
Include the parameter names also in the declaration of a function, i.e.
\begin{lstlisting}
/** calculates a*b+c
 */
double function(double a, double b, double c);
\end{lstlisting}
avoid
\begin{lstlisting}
Type function(Type1, Type2, Type3);
\end{lstlisting}

\subsection{Conditionals}

Examples:
\begin{lstlisting}
if (condition)
  statement;
else
  statement;

if (condition) {
  statement;
}
else if (condition2) {
  statement;
}
else {
  statement;
}
\end{lstlisting}

\subsection{Switch statement}

Switch statements should always have a default case.

Example:
\begin{lstlisting}
switch (var) {
  case 0:
    statement1;
    statement2;
    break;

  case 1:
    statement1;
    statement2;
    break;

  default:
    statement1;
    statement2;
}
\end{lstlisting}

\subsection{Loops}

Examples:
\begin{lstlisting}
for (statement; condition; statement)
  statement;

for (statement; condition; statement) {
  statement1;
  statement2;
}

while (condition)
  statement;

while (condition) {
  statement1;
  statement2;
}

do {
  statement;
}
while (condition);
\end{lstlisting}

\subsection{Preprocessor Directives}
The preprocessor directives are not indented.
The hash is the first character of the line.

\subsection{Class Format}
\label{subsec:class_format}
\inlinecode{public}, \inlinecode{protected} and \inlinecode{private} keywords are not indented.
Do not to use \inlinecode{struct} as a way to avoid controlling access to the class. In rare cases where
a class is a fully public data structure \inlinecode{struct} is appropriate.

Example:
\begin{lstlisting}
class Foo : public Bar {
public:
  Foo();
  explicit Foo(int var);

  void function();
  void emptyFunction() {}

  void set_var(const int var) {
    var_ = var;
  }
  int get_var() const {
    return var_;
  }

private:
  bool privateFunction();

  int var_;
  int var2_;
};
\end{lstlisting}

\subsubsection{Constructor Initializer Lists}

Examples:
\begin{lstlisting}
// When everything fits on one line:
Foo::Foo(int var) : var_(var) {
  statement;
}

// If the signature and the initializer list do not
// fit on one line, the colon is indented by 4 spaces:
Foo::Foo(int var)
    : var_(var), var2_(var + 1) {
  statement;
}

// If the initializer list occupies more lines,
// they are aligned in the following way:
Foo::Foo(int var)
    : some_var_(var),
      some_other_var_(var + 1) {
  statement;
}

// No statements:
Foo::Foo(int var)
    : some_var_(var) {}
\end{lstlisting}

\subsection{Namespace Formatting}

The content of namespaces is not indented.
A comment should indicate when a namespace is closed.
If nested namespaces are used, a comment with the full namespace is required after opening a set of namespaces or an inner namespace.

Examples:
\begin{lstlisting}
namespace ns{
void foo();
}  // ns
\end{lstlisting}

\begin{lstlisting}
namespace ns1{
namespace ns2{
// ns1::ns2::
void foo();

namespace ns3{
// ns1::ns2::ns3::
void bar();
}  // ns3
}  // ns2

namespace ns4{
namespace ns5{
// ns1::ns4::ns5::
void foo();
}  // ns5
}  // ns4
}  // ns1
\end{lstlisting}


\section{Other C++ Features}

\subsection{Pre-increment and pre-decrement}

Use the pre-increment (pre-decrement) operator when a variable is incremented (decremented) and the value of the expression is not used.
In particular, use the pre-increment (pre-decrement) operator for loop counters where i is not used:

\begin{lstlisting}[showspaces=false]
for (int i = 0; i < N; ++i) {
  doSomething();
}

for (int i = 0; i < N; i++) {
  doSomething(i);
}
\end{lstlisting}

The post-increment and post-decrement operators create an unnecessary copy, that the compiler cannot optimize away in the case of iterators or other classes with overloaded increment and decrement operators.

\subsection{Alternative Operator Representations}

Alternative representations of operators and other tokens such as \inlinecode{and}, \inlinecode{or}, and \inlinecode{not} instead of \inlinecode{&&}, \inlinecode{||}, and \inlinecode{!} are not allowed.
For the reason of consistency, the far more common primary tokens should always be used.

\subsection{Use of const}

\begin{itemize}

\item Add the \inlinecode{const} qualifier to all function parameters that are not modified in the function body.
For parameters passed by value, only add the keyword in the function definition.

\begin{lstlisting}[showspaces=false]
// Declaration
int computeFoo(int bar, const Matrix& m) {

// Definition
int computeFoo(const int bar, const Matrix& m) {
  int foo = 42;

  // Compute foo without changing bar or m.
  // ...

  return foo;
}
\end{lstlisting}

\end{itemize}

\subsection{In-class member initialization}

In-class member initialization is recommended for members that are \emph{always} initialized with the same value to avoid code duplication.
In all other cases it is disallowed.

\begin{lstlisting}[showspaces=false]
std::string getNameFromId(const int id);

class Customer {
public:
  Customer(const std::string& name = "Doe",
           const std::string& address = default_address_)
    : name_(name), address_(address) {}
  Customer(const int id,
           const std::string& address = default_address_)
    : name_(getNameFromId(id)), address_(address) {}

private:
  static const std::string default_address_;

  std::string name_;
  std::string address_;
  int num_orders_ = 0;
};

const std::string Customer::default_address_ = "Zurich";
\end{lstlisting}
