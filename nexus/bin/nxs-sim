#! /usr/bin/env python3

import os
from optparse import OptionParser

# Copied from qmca. Modification must done on qmca first
# Locate and import the closely coupled Nexus module
def find_nexus_modules():
    import os
    import sys
    # Prepend the assumed path of a folder containing the closely coupled nexus module to module search path
    # It points to the top Nexus directory not necessarily the top QMCPACK directory.
    nexus_lib = os.path.realpath(os.path.join(__file__,'..','..'))

    # "import nexus" will succeed if nexus directory exists without __init__.py in it.
    # Explicitly check the existence of nexus/__init__.py at the closely coupled location
    nexus_init = os.path.join(nexus_lib,'nexus','__init__.py')
    if not os.path.exists(nexus_init):
        print('\nFile '+nexus_init+' does not exist!'
              '\nBroken Nexus installation!'
              '\nMake sure Nexus modules are available at:'
              '\n  '+nexus_lib+'\n')
        sys.exit(1)

    # check import of nexus modules
    sys.path.insert(0,nexus_lib)
    try:
        import nexus
    except Exception as err:
        print('\nImporting Nexus modules failed for an unknown reason.'
              '\nThis is likely a developer error.'
              '\nFor more information, the original exception is reproduced below.'
              '\nPlease report this error to the Nexus developers.'+2*'\n')
        import traceback
        exc_type, exc_value, exc_traceback = sys.exc_info()
        exc_lines = traceback.format_exception(exc_type, exc_value, exc_traceback)
        for line in exc_lines:
            print(line.rstrip())
        print()
        sys.exit(1)

    # Sanity check. Most likely errors get caught earlier.
    # ensure closely coupled nexus module is in use.
    nexus_lib2 = os.path.realpath(os.path.join(nexus.__file__,'..','..'))
    if nexus_lib != nexus_lib2:
        exe_full_path = os.path.abspath(sys.argv[0])
        print('\nNexus executables and modules are not from the same installation!'
              '\nLocations required : '
              '\n  exectuables reside at <nexus_root>/bin'
              '\n  modules reside at <nexus_root>/nexus'
              '\nLocations detected : '
              '\n  Nexus executable            : ' + exe_full_path +
              '\n  Module derived <nexus_root> : ' + nexus_lib2 + '\n')
        sys.exit(1)
#end def find_nexus_modules

# Load Nexus modules
find_nexus_modules()
from nexus.nexus_version import nexus_version
from nexus.developer import obj


class SimTool(obj):
    
    indicators = ['setup','sent_files','submitted','finished','failed','got_output','analyzed']

    fields = set(indicators)


    def __init__(self):
        self.paths = []
        self.sims  = []
    #end def __init__


    def load(self,paths):
        for path in paths:
            sim = obj()
            sim.load(path)
            self.sims.append(sim)
            self.paths.append(path)
        #end for
    #end def load


    def write_state(self,fields=[]):
        if len(fields)==0:
            fields = self.indicators
        #end if
        forbidden = set(fields)-set(self.fields)
        if len(forbidden)>0:
            print('unrecognized fields encountered:')
            for f in forbidden:
                print('  ',f)
            #end for
            exit()
        #end if
        for i in range(len(self.paths)):
            path = self.paths[i]
            sim  = self.sims[i]
            print(path)
            for f in fields:
                print('   {0:<12} {1}'.format(f,int(sim[f])))
            #end for
        #end for
    #end def write_state


    def write_state_all(self,fields=[]):
        if len(fields)==0:
            fields = self.indicators
        #end if
        forbidden = set(fields)-set(self.fields)
        if len(forbidden)>0:
            print('unrecognized fields encountered:')
            for f in forbidden:
                print('  ',f)
            #end for
            exit()
        #end if
        for i in range(len(self.paths)):
            path = self.paths[i]
            sim  = self.sims[i]
            print(path)
            print(sim)
        #end for
    #end def write_state_all

                
    def backup(self):
        for path in self.paths:
            base,file = os.path.split(path)
            bufile = os.path.join(base,'backup_'+file)
            os.system('cp '+path+' '+bufile)
        #end for
    #end def backup

                
    def restore(self):
        for path in self.paths:
            base,file = os.path.split(path)
            bufile = os.path.join(base,'backup_'+file)
            os.system('cp '+bufile+' '+path)
        #end for
    #end def restore


    def set_indicators(self,inds,val=1):
        if len(inds)==0:
            print('no indicators specified')
            print('  options are: '+self.indicators)
            exit()
        #end if
        forbidden = set(inds)-set(self.indicators)
        if len(forbidden)>0:
            print('unrecognized indicators encountered:')
            for f in forbidden:
                print('  ',f)
            #end for
            exit()
        #end if
        for i in range(len(self.paths)):
            path = self.paths[i]
            sim  = self.sims[i]
            for ind in inds:
                sim[ind] = val
                if ind=='submitted' and val==0:
                    sim.process_id = None
                #end if
            #end for
            sim.save(path)
        #end for
    #end def set_indicators
                
#end class SimTool


if __name__=='__main__':
    parser = OptionParser()
    (opts,inargs) = parser.parse_args()

    allowed_commands = ['show','showall','complete','reset','set','unset','backup','restore']
    if len(inargs)==0:
        print('simtool usage:')
        print('  allowed commands are')
        for comm in allowed_commands:
            print('   ',comm)
        #end for
        exit()
    #end if

    paths = []
    command = ''
    args = []
    if len(inargs)>0:
        command = inargs[0]
        inargs=inargs[1:]
    #end if
    for arg in inargs:
        if os.path.exists(arg):
            paths.append(arg)
        else:
            args.append(arg)
        #end if
    #end for


    if not command in allowed_commands:
        print('command '+command+' not recognized')
        exit()
    #end if

    if len(paths)==0:
        if os.path.exists('./sim.p'):
            paths = ['./sim.p']
        else:
            print('no simulation images found')
            exit()
        #end if
    #end if

    st = SimTool()
    st.load(paths)

    if command=='show':
        st.write_state(args)
    elif command=='showall':
        st.write_state_all(args)
    elif command=='complete':
        inds = ['setup','sent_files','submitted','finished','got_output','analyzed']
        st.set_indicators(inds)
    elif command=='reset':
        st.set_indicators(st.indicators,val=0)
    elif command=='set':
        st.set_indicators(args)
    elif command=='unset':
        st.set_indicators(args,val=0)
    elif command=='backup':
        st.backup()
    elif command=='restore':
        st.restore()
    #end if
    
#end if
