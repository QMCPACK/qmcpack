//////////////////////////////////////////////////////////////////////////////////////
// This file is distributed under the University of Illinois/NCSA Open Source License.
// See LICENSE file in top directory for details.
//
// Copyright (c) 2016 Jeongnim Kim and QMCPACK developers.
//
// File developed by: Jeremy McMinnis, jmcminis@gmail.com, University of Illinois at Urbana-Champaign   
//
// File created by: Jeongnim Kim, jeongnim.kim@gmail.com, University of Illinois at Urbana-Champaign 
//////////////////////////////////////////////////////////////////////////////////////


#ifndef OHMMS_VECTOR_OPERATORS_H
#define OHMMS_VECTOR_OPERATORS_H

namespace qmcplusplus
{

///////////////////////////////////////////////////////////////////////////////
//
// WARNING: THIS FILE WAS GENERATED AUTOMATICALLY!
// YOU SHOULD MODIFY THE INPUT FILES INSTEAD OF CHANGING THIS FILE DIRECTLY!
//
// THE FOLLOWING INPUT FILES WERE USED TO MAKE THIS FILE:
//
// MakeOperators
// VectorDefs.in
//
///////////////////////////////////////////////////////////////////////////////


template<class T1, class C1>
inline typename MakeReturn<UnaryNode<FnArcCos,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t> >::Expression_t
       acos(const Vector<T1, C1> & l)
{
  typedef UnaryNode<FnArcCos,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l)));
}

template<class T1, class C1>
inline typename MakeReturn<UnaryNode<FnArcSin,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t> >::Expression_t
       asin(const Vector<T1, C1> & l)
{
  typedef UnaryNode<FnArcSin,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l)));
}

template<class T1, class C1>
inline typename MakeReturn<UnaryNode<FnArcTan,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t> >::Expression_t
       atan(const Vector<T1, C1> & l)
{
  typedef UnaryNode<FnArcTan,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l)));
}

template<class T1, class C1>
inline typename MakeReturn<UnaryNode<FnCeil,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t> >::Expression_t
       ceil(const Vector<T1, C1> & l)
{
  typedef UnaryNode<FnCeil,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l)));
}

template<class T1, class C1>
inline typename MakeReturn<UnaryNode<FnCos,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t> >::Expression_t
       cos(const Vector<T1, C1> & l)
{
  typedef UnaryNode<FnCos,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l)));
}

template<class T1, class C1>
inline typename MakeReturn<UnaryNode<FnHypCos,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t> >::Expression_t
       cosh(const Vector<T1, C1> & l)
{
  typedef UnaryNode<FnHypCos,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l)));
}

template<class T1, class C1>
inline typename MakeReturn<UnaryNode<FnExp,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t> >::Expression_t
       exp(const Vector<T1, C1> & l)
{
  typedef UnaryNode<FnExp,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l)));
}

template<class T1, class C1>
inline typename MakeReturn<UnaryNode<FnFabs,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t> >::Expression_t
       abs(const Vector<T1, C1> & l)
{
  typedef UnaryNode<FnFabs,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l)));
}

template<class T1, class C1>
inline typename MakeReturn<UnaryNode<FnFloor,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t> >::Expression_t
       floor(const Vector<T1, C1> & l)
{
  typedef UnaryNode<FnFloor,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l)));
}

template<class T1, class C1>
inline typename MakeReturn<UnaryNode<FnLog,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t> >::Expression_t
       log(const Vector<T1, C1> & l)
{
  typedef UnaryNode<FnLog,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l)));
}

template<class T1, class C1>
inline typename MakeReturn<UnaryNode<FnLog10,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t> >::Expression_t
       log10(const Vector<T1, C1> & l)
{
  typedef UnaryNode<FnLog10,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l)));
}

template<class T1, class C1>
inline typename MakeReturn<UnaryNode<FnSin,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t> >::Expression_t
       sin(const Vector<T1, C1> & l)
{
  typedef UnaryNode<FnSin,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l)));
}

template<class T1, class C1>
inline typename MakeReturn<UnaryNode<FnHypSin,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t> >::Expression_t
       sinh(const Vector<T1, C1> & l)
{
  typedef UnaryNode<FnHypSin,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l)));
}

template<class T1, class C1>
inline typename MakeReturn<UnaryNode<FnSqrt,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t> >::Expression_t
       sqrt(const Vector<T1, C1> & l)
{
  typedef UnaryNode<FnSqrt,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l)));
}

template<class T1, class C1>
inline typename MakeReturn<UnaryNode<FnTan,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t> >::Expression_t
       tan(const Vector<T1, C1> & l)
{
  typedef UnaryNode<FnTan,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l)));
}

template<class T1, class C1>
inline typename MakeReturn<UnaryNode<FnHypTan,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t> >::Expression_t
       tanh(const Vector<T1, C1> & l)
{
  typedef UnaryNode<FnHypTan,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l)));
}

template<class T1, class C1>
inline typename MakeReturn<UnaryNode<OpUnaryMinus,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t> >::Expression_t
       operator-(const Vector<T1, C1> & l)
{
  typedef UnaryNode<OpUnaryMinus,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l)));
}

template<class T1, class C1>
inline typename MakeReturn<UnaryNode<OpUnaryPlus,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t> >::Expression_t
       operator+(const Vector<T1, C1> & l)
{
  typedef UnaryNode<OpUnaryPlus,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l)));
}

template<class T1, class C1>
inline typename MakeReturn<UnaryNode<OpBitwiseNot,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t> >::Expression_t
       operator~(const Vector<T1, C1> & l)
{
  typedef UnaryNode<OpBitwiseNot,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l)));
}

template<class T1, class C1>
inline typename MakeReturn<UnaryNode<OpIdentity,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t> >::Expression_t
       PETE_identity(const Vector<T1, C1> & l)
{
  typedef UnaryNode<OpIdentity,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l)));
}

template<class T1, class C1>
inline typename MakeReturn<UnaryNode<OpNot,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t> >::Expression_t
       operator!(const Vector<T1, C1> & l)
{
  typedef UnaryNode<OpNot,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<UnaryNode<OpCast<T1>,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       peteCast(const T1&, const Vector<T2, C2> & l)
{
  typedef UnaryNode<OpCast<T1>,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T2, C2> >::make(l)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpAdd,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator+(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpAdd,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpSubtract,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator-(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpSubtract,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpMultiply,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator*(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpMultiply,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpDivide,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator/(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpDivide,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpMod,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator%(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpMod,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator&(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator|(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator^(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<FnLdexp,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       ldexp(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<FnLdexp,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<FnPow,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       pow(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<FnPow,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<FnFmod,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       fmod(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<FnFmod,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       atan2(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<FnArcTan2,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpLT,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator<(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpLT,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpLE,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator<=(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpLE,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpGT,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator>(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpGT,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpGE,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator>=(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpGE,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpEQ,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator==(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpEQ,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpNE,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator!=(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpNE,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpAnd,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator&&(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpAnd,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpOr,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator||(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpOr,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpLeftShift,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator<<(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpLeftShift,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpRightShift,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator>>(const Vector<T1, C1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpRightShift,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpAdd,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator+(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpAdd,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpSubtract,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator-(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpSubtract,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpMultiply,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator*(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpMultiply,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpDivide,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator/(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpDivide,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpMod,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator%(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpMod,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator&(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator|(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator^(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<FnLdexp,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       ldexp(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<FnLdexp,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<FnPow,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       pow(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<FnPow,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<FnFmod,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       fmod(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<FnFmod,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       atan2(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<FnArcTan2,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpLT,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator<(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpLT,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpLE,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator<=(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpLE,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpGT,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator>(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpGT,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpGE,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator>=(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpGE,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpEQ,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator==(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpEQ,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpNE,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator!=(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpNE,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpAnd,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator&&(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpAnd,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpOr,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator||(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpOr,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpLeftShift,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator<<(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpLeftShift,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpRightShift,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator>>(const Vector<T1, C1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpRightShift,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpAdd,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator+(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpAdd,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpSubtract,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator-(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpSubtract,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpMultiply,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator*(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpMultiply,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpDivide,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator/(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpDivide,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpMod,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator%(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpMod,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator&(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator|(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator^(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<FnLdexp,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       ldexp(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<FnLdexp,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<FnPow,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       pow(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<FnPow,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<FnFmod,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       fmod(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<FnFmod,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       atan2(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<FnArcTan2,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpLT,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator<(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpLT,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpLE,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator<=(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpLE,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpGT,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator>(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpGT,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpGE,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator>=(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpGE,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpEQ,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator==(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpEQ,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpNE,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator!=(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpNE,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpAnd,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator&&(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpAnd,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpOr,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator||(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpOr,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpLeftShift,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator<<(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpLeftShift,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpRightShift,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator>>(const Expression<T1> & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpRightShift,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpAdd,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator+(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<OpAdd,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpSubtract,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator-(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<OpSubtract,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpMultiply,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator*(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<OpMultiply,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpDivide,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator/(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<OpDivide,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpMod,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator%(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<OpMod,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator&(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<OpBitwiseAnd,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator|(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<OpBitwiseOr,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator^(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<OpBitwiseXor,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<FnLdexp,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       ldexp(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<FnLdexp,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<FnPow,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       pow(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<FnPow,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<FnFmod,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       fmod(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<FnFmod,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       atan2(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<FnArcTan2,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpLT,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator<(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<OpLT,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpLE,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator<=(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<OpLE,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpGT,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator>(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<OpGT,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpGE,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator>=(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<OpGE,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpEQ,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator==(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<OpEQ,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpNE,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator!=(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<OpNE,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpAnd,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator&&(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<OpAnd,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpOr,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator||(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<OpOr,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpLeftShift,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator<<(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<OpLeftShift,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1, class C1,class T2>
inline typename MakeReturn<BinaryNode<OpRightShift,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator>>(const Vector<T1, C1> & l,const T2 & r)
{
  typedef BinaryNode<OpRightShift,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpAdd,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator+(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpAdd,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpSubtract,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator-(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpSubtract,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpMultiply,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator*(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpMultiply,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpDivide,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator/(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpDivide,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpMod,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator%(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpMod,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator&(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator|(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator^(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<FnLdexp,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       ldexp(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<FnLdexp,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<FnPow,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       pow(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<FnPow,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<FnFmod,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       fmod(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<FnFmod,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       atan2(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<FnArcTan2,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpLT,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator<(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpLT,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpLE,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator<=(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpLE,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpGT,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator>(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpGT,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpGE,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator>=(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpGE,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpEQ,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator==(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpEQ,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpNE,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator!=(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpNE,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpAnd,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator&&(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpAnd,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpOr,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator||(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpOr,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}
#ifdef PETE_ALLOW_SCALAR_SHIFT

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpLeftShift,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator<<(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpLeftShift,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}

template<class T1,class T2, class C2>
inline typename MakeReturn<BinaryNode<OpRightShift,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Vector<T2, C2> >::Leaf_t> >::Expression_t
       operator>>(const T1 & l,const Vector<T2, C2> & r)
{
  typedef BinaryNode<OpRightShift,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Vector<T2, C2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Vector<T2, C2> >::make(r)));
}
#endif // PETE_ALLOW_SCALAR_SHIFT

template<class T1, class C1,class T2,class T3>
inline typename MakeReturn<TrinaryNode<FnWhere,
       typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t,
       typename CreateLeaf<T3 >::Leaf_t> >::Expression_t
       where(const Vector<T1, C1> & c,const T2 & t,const T3 & f)
{
  typedef TrinaryNode<FnWhere,
          typename CreateLeaf<Vector<T1, C1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t,
          typename CreateLeaf<T3 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Vector<T1, C1> >::make(c),
                                    CreateLeaf<T2 >::make(t),
                                    CreateLeaf<T3 >::make(f)));
}
#ifndef PETE_EXPRESSION_OPERATORS
#define PETE_EXPRESSION_OPERATORS

template<class T1>
inline typename MakeReturn<UnaryNode<FnArcCos,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       acos(const Expression<T1> & l)
{
  typedef UnaryNode<FnArcCos,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<FnArcSin,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       asin(const Expression<T1> & l)
{
  typedef UnaryNode<FnArcSin,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<FnArcTan,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       atan(const Expression<T1> & l)
{
  typedef UnaryNode<FnArcTan,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<FnCeil,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       ceil(const Expression<T1> & l)
{
  typedef UnaryNode<FnCeil,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<FnCos,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       cos(const Expression<T1> & l)
{
  typedef UnaryNode<FnCos,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<FnHypCos,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       cosh(const Expression<T1> & l)
{
  typedef UnaryNode<FnHypCos,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<FnExp,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       exp(const Expression<T1> & l)
{
  typedef UnaryNode<FnExp,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<FnFabs,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       abs(const Expression<T1> & l)
{
  typedef UnaryNode<FnFabs,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<FnFloor,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       floor(const Expression<T1> & l)
{
  typedef UnaryNode<FnFloor,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<FnLog,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       log(const Expression<T1> & l)
{
  typedef UnaryNode<FnLog,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<FnLog10,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       log10(const Expression<T1> & l)
{
  typedef UnaryNode<FnLog10,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<FnSin,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       sin(const Expression<T1> & l)
{
  typedef UnaryNode<FnSin,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<FnHypSin,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       sinh(const Expression<T1> & l)
{
  typedef UnaryNode<FnHypSin,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<FnSqrt,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       sqrt(const Expression<T1> & l)
{
  typedef UnaryNode<FnSqrt,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<FnTan,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       tan(const Expression<T1> & l)
{
  typedef UnaryNode<FnTan,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<FnHypTan,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       tanh(const Expression<T1> & l)
{
  typedef UnaryNode<FnHypTan,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<OpUnaryMinus,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       operator-(const Expression<T1> & l)
{
  typedef UnaryNode<OpUnaryMinus,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<OpUnaryPlus,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       operator+(const Expression<T1> & l)
{
  typedef UnaryNode<OpUnaryPlus,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<OpBitwiseNot,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       operator~(const Expression<T1> & l)
{
  typedef UnaryNode<OpBitwiseNot,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<OpIdentity,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       PETE_identity(const Expression<T1> & l)
{
  typedef UnaryNode<OpIdentity,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<OpNot,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       operator!(const Expression<T1> & l)
{
  typedef UnaryNode<OpNot,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1,class T2>
inline typename MakeReturn<UnaryNode<OpCast<T1>,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       peteCast(const T1&, const Expression<T2> & l)
{
  typedef UnaryNode<OpCast<T1>,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T2> >::make(l)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpAdd,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator+(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpAdd,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpSubtract,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator-(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpSubtract,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMultiply,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator*(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpMultiply,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpDivide,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator/(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpDivide,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMod,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator%(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpMod,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator&(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator|(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator^(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<FnLdexp,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       ldexp(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<FnLdexp,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<FnPow,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       pow(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<FnPow,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<FnFmod,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       fmod(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<FnFmod,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       atan2(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<FnArcTan2,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpLT,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator<(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpLT,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpLE,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator<=(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpLE,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpGT,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator>(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpGT,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpGE,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator>=(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpGE,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpEQ,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator==(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpEQ,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpNE,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator!=(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpNE,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpAnd,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator&&(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpAnd,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpOr,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator||(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpOr,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpLeftShift,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator<<(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpLeftShift,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpRightShift,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator>>(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpRightShift,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpAdd,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator+(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpAdd,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpSubtract,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator-(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpSubtract,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMultiply,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator*(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpMultiply,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpDivide,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator/(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpDivide,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMod,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator%(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpMod,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator&(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpBitwiseAnd,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator|(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpBitwiseOr,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator^(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpBitwiseXor,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<FnLdexp,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       ldexp(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<FnLdexp,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<FnPow,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       pow(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<FnPow,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<FnFmod,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       fmod(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<FnFmod,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       atan2(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<FnArcTan2,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpLT,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator<(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpLT,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpLE,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator<=(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpLE,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpGT,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator>(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpGT,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpGE,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator>=(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpGE,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpEQ,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator==(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpEQ,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpNE,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator!=(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpNE,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpAnd,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator&&(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpAnd,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpOr,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator||(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpOr,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpLeftShift,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator<<(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpLeftShift,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpRightShift,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator>>(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpRightShift,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpAdd,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator+(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpAdd,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpSubtract,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator-(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpSubtract,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMultiply,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator*(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpMultiply,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpDivide,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator/(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpDivide,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMod,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator%(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpMod,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator&(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator|(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator^(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<FnLdexp,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       ldexp(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<FnLdexp,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<FnPow,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       pow(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<FnPow,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<FnFmod,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       fmod(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<FnFmod,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<FnArcTan2,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       atan2(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<FnArcTan2,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpLT,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator<(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpLT,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpLE,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator<=(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpLE,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpGT,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator>(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpGT,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpGE,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator>=(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpGE,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpEQ,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator==(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpEQ,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpNE,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator!=(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpNE,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpAnd,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator&&(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpAnd,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpOr,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator||(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpOr,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}
#ifdef PETE_ALLOW_SCALAR_SHIFT

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpLeftShift,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator<<(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpLeftShift,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpRightShift,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator>>(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpRightShift,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}
#endif // PETE_ALLOW_SCALAR_SHIFT

template<class T1,class T2,class T3>
inline typename MakeReturn<TrinaryNode<FnWhere,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t,
       typename CreateLeaf<T3 >::Leaf_t> >::Expression_t
       where(const Expression<T1> & c,const T2 & t,const T3 & f)
{
  typedef TrinaryNode<FnWhere,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t,
          typename CreateLeaf<T3 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(c),
                                    CreateLeaf<T2 >::make(t),
                                    CreateLeaf<T3 >::make(f)));
}
#endif  // PETE_EXPRESSION_OPERATORS

template<class T1, class C1,class RHS>
inline
Vector<T1, C1>& assign(Vector<T1, C1>& lhs,const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs,OpAssign(),MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1, class C1,class RHS>
inline
Vector<T1, C1>& operator+=(Vector<T1, C1>& lhs,const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs,OpAddAssign(),MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1, class C1,class RHS>
inline
Vector<T1, C1>& operator-=(Vector<T1, C1>& lhs,const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs,OpSubtractAssign(),MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1, class C1,class RHS>
inline
Vector<T1, C1>& operator*=(Vector<T1, C1>& lhs,const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs,OpMultiplyAssign(),MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1, class C1,class RHS>
inline
Vector<T1, C1>& operator/=(Vector<T1, C1>& lhs,const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs,OpDivideAssign(),MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1, class C1,class RHS>
inline
Vector<T1, C1>& operator%=(Vector<T1, C1>& lhs,const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs,OpModAssign(),MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1, class C1,class RHS>
inline
Vector<T1, C1>& operator|=(Vector<T1, C1>& lhs,const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs,OpBitwiseOrAssign(),MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1, class C1,class RHS>
inline
Vector<T1, C1>& operator&=(Vector<T1, C1>& lhs,const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs,OpBitwiseAndAssign(),MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1, class C1,class RHS>
inline
Vector<T1, C1>& operator^=(Vector<T1, C1>& lhs,const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs,OpBitwiseXorAssign(),MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1, class C1,class RHS>
inline
Vector<T1, C1>& operator<<=(Vector<T1, C1>& lhs,const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs,OpLeftShiftAssign(),MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1, class C1,class RHS>
inline
Vector<T1, C1>& operator>>=(Vector<T1, C1>& lhs,const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs,OpRightShiftAssign(),MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

}

#endif //  GENERATED_OPERATORS_H

