///////////////////////////////////////////////////////////////////////////////////////////////////
/// \file formic/utils/zero_one.h
///
/// \brief   header file for functions related to zero and one
///
///////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef FORMIC_UTILS_ZERO_ONE_HEADER
#define FORMIC_UTILS_ZERO_ONE_HEADER

namespace formic {

  ///////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief   returns the number zero for real types
  ///
  /// \return the number zero
  ///
  ///////////////////////////////////////////////////////////////////////////////////////////////////
  template <class S> inline S zero(S x) { return 0; }

  ///////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief   returns the number zero for complex types
  ///
  /// \return the number zero
  ///
  ///////////////////////////////////////////////////////////////////////////////////////////////////
  template <class S> inline std::complex<S> zero(std::complex<S> x) { return std::complex<S>(0, 0); }

  ///////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief   returns the number one for real types
  ///
  /// \return the number one
  ///
  ///////////////////////////////////////////////////////////////////////////////////////////////////
  template <class S> inline S unity(S x) { return 1; }

  ///////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief   returns the number one for complex types
  ///
  /// \return the number one
  ///
  ///////////////////////////////////////////////////////////////////////////////////////////////////
  template <class S> inline std::complex<S> unity(std::complex<S> x) { return std::complex<S>(1, 0); }

  ///////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief   returns the square root of -1 for complex types
  ///
  /// \return the number i
  ///
  ///////////////////////////////////////////////////////////////////////////////////////////////////
  template <class S> inline std::complex<S> imaginary_unity(std::complex<S> x) { return std::complex<S>(0, 1); }

  ///////////////////////////////////////////////////////////////////////////////////////////////////
  /// \brief   returns zero instead of the square root of -1 for real types
  ///
  /// \return  0
  ///
  ///////////////////////////////////////////////////////////////////////////////////////////////////
  template <class S> inline S imaginary_unity(S x) { return 0; }

}

#endif
