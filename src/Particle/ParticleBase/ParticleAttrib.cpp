//////////////////////////////////////////////////////////////////////////////////////
// This file is distributed under the University of Illinois/NCSA Open Source License.
// See LICENSE file in top directory for details.
//
// Copyright (c) 2016 Jeongnim Kim and QMCPACK developers.
//
// File developed by: Jeongnim Kim, jeongnim.kim@gmail.com, University of Illinois at Urbana-Champaign
//                    Jeremy McMinnis, jmcminis@gmail.com, University of Illinois at Urbana-Champaign
//                    Mark A. Berrill, berrillma@ornl.gov, Oak Ridge National Laboratory
//
// File created by: Jeongnim Kim, jeongnim.kim@gmail.com, University of Illinois at Urbana-Champaign
//////////////////////////////////////////////////////////////////////////////////////


#ifndef OHMMS_PARTICLEATTRIB_PEPE_OPERATORS_H
#define OHMMS_PARTICLEATTRIB_PEPE_OPERATORS_H
///////////////////////////////////////////////////////////////////////////////
//
// WARNING: THIS FILE WAS GENERATED AUTOMATICALLY!
// YOU SHOULD MODIFY THE INPUT FILES INSTEAD OF CHANGING THIS FILE DIRECTLY!
//
// THE FOLLOWING INPUT FILES WERE USED TO MAKE THIS FILE:
//
// MakeOperators

// WHERE are these Files?

// matrixOps.in
// MatrixDefs.in
//
///////////////////////////////////////////////////////////////////////////////

namespace qmcplusplus
{
template<class T1>
inline typename MakeReturn<UnaryNode<OpUnaryMinus, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t>>::Expression_t
    operator-(const ParticleAttrib<T1>& l)
{
  typedef UnaryNode<OpUnaryMinus, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<OpUnaryPlus, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t>>::Expression_t
    operator+(const ParticleAttrib<T1>& l)
{
  typedef UnaryNode<OpUnaryPlus, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<OpBitwiseNot, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t>>::Expression_t
    operator~(const ParticleAttrib<T1>& l)
{
  typedef UnaryNode<OpBitwiseNot, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<OpIdentity, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t>>::Expression_t
    PETE_identity(const ParticleAttrib<T1>& l)
{
  typedef UnaryNode<OpIdentity, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l)));
}

template<class T1, class T2>
inline typename MakeReturn<UnaryNode<OpCast<T1>, typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::Expression_t
    peteCast(const T1&, const ParticleAttrib<T2>& l)
{
  typedef UnaryNode<OpCast<T1>, typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<ParticleAttrib<T2>>::make(l)));
}

template<class T1, class T2>
inline typename MakeReturn<BinaryNode<OpAdd,
                                      typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                                      typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::Expression_t
    operator+(const ParticleAttrib<T1>& l, const ParticleAttrib<T2>& r)
{
  typedef BinaryNode<OpAdd, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                     typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(
      Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l), CreateLeaf<ParticleAttrib<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<BinaryNode<OpSubtract,
                                      typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                                      typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::Expression_t
    operator-(const ParticleAttrib<T1>& l, const ParticleAttrib<T2>& r)
{
  typedef BinaryNode<OpSubtract, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                     typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(
      Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l), CreateLeaf<ParticleAttrib<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<BinaryNode<OpMultiply,
                                      typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                                      typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::Expression_t
    operator*(const ParticleAttrib<T1>& l, const ParticleAttrib<T2>& r)
{
  typedef BinaryNode<OpMultiply, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                     typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(
      Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l), CreateLeaf<ParticleAttrib<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<BinaryNode<OpMod,
                                      typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                                      typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::Expression_t
    operator%(const ParticleAttrib<T1>& l, const ParticleAttrib<T2>& r)
{
  typedef BinaryNode<OpMod, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                     typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(
      Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l), CreateLeaf<ParticleAttrib<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
                                      typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                                      typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::Expression_t
    operator&(const ParticleAttrib<T1>& l, const ParticleAttrib<T2>& r)
{
  typedef BinaryNode<OpBitwiseAnd, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                     typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(
      Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l), CreateLeaf<ParticleAttrib<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
                                      typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                                      typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::Expression_t
    operator|(const ParticleAttrib<T1>& l, const ParticleAttrib<T2>& r)
{
  typedef BinaryNode<OpBitwiseOr, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                     typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(
      Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l), CreateLeaf<ParticleAttrib<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
                                      typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                                      typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::Expression_t
    operator^(const ParticleAttrib<T1>& l, const ParticleAttrib<T2>& r)
{
  typedef BinaryNode<OpBitwiseXor, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                     typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(
      Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l), CreateLeaf<ParticleAttrib<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpAdd, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t>>::
    Expression_t
    operator+(const ParticleAttrib<T1>& l, const Expression<T2>& r)
{
  typedef BinaryNode<OpAdd, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                     typename CreateLeaf<Expression<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l), CreateLeaf<Expression<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<BinaryNode<OpSubtract,
                                      typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                                      typename CreateLeaf<Expression<T2>>::Leaf_t>>::Expression_t
    operator-(const ParticleAttrib<T1>& l, const Expression<T2>& r)
{
  typedef BinaryNode<OpSubtract, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                     typename CreateLeaf<Expression<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l), CreateLeaf<Expression<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<BinaryNode<OpMultiply,
                                      typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                                      typename CreateLeaf<Expression<T2>>::Leaf_t>>::Expression_t
    operator*(const ParticleAttrib<T1>& l, const Expression<T2>& r)
{
  typedef BinaryNode<OpMultiply, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                     typename CreateLeaf<Expression<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l), CreateLeaf<Expression<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpMod, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t>>::
    Expression_t
    operator%(const ParticleAttrib<T1>& l, const Expression<T2>& r)
{
  typedef BinaryNode<OpMod, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                     typename CreateLeaf<Expression<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l), CreateLeaf<Expression<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
                                      typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                                      typename CreateLeaf<Expression<T2>>::Leaf_t>>::Expression_t
    operator&(const ParticleAttrib<T1>& l, const Expression<T2>& r)
{
  typedef BinaryNode<OpBitwiseAnd, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                     typename CreateLeaf<Expression<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l), CreateLeaf<Expression<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
                                      typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                                      typename CreateLeaf<Expression<T2>>::Leaf_t>>::Expression_t
    operator|(const ParticleAttrib<T1>& l, const Expression<T2>& r)
{
  typedef BinaryNode<OpBitwiseOr, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                     typename CreateLeaf<Expression<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l), CreateLeaf<Expression<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
                                      typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                                      typename CreateLeaf<Expression<T2>>::Leaf_t>>::Expression_t
    operator^(const ParticleAttrib<T1>& l, const Expression<T2>& r)
{
  typedef BinaryNode<OpBitwiseXor, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                     typename CreateLeaf<Expression<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l), CreateLeaf<Expression<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpAdd, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::
    Expression_t
    operator+(const Expression<T1>& l, const ParticleAttrib<T2>& r)
{
  typedef BinaryNode<OpAdd, typename CreateLeaf<Expression<T1>>::Leaf_t,
                     typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l), CreateLeaf<ParticleAttrib<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<BinaryNode<OpSubtract,
                                      typename CreateLeaf<Expression<T1>>::Leaf_t,
                                      typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::Expression_t
    operator-(const Expression<T1>& l, const ParticleAttrib<T2>& r)
{
  typedef BinaryNode<OpSubtract, typename CreateLeaf<Expression<T1>>::Leaf_t,
                     typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l), CreateLeaf<ParticleAttrib<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<BinaryNode<OpMultiply,
                                      typename CreateLeaf<Expression<T1>>::Leaf_t,
                                      typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::Expression_t
    operator*(const Expression<T1>& l, const ParticleAttrib<T2>& r)
{
  typedef BinaryNode<OpMultiply, typename CreateLeaf<Expression<T1>>::Leaf_t,
                     typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l), CreateLeaf<ParticleAttrib<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpMod, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::
    Expression_t
    operator%(const Expression<T1>& l, const ParticleAttrib<T2>& r)
{
  typedef BinaryNode<OpMod, typename CreateLeaf<Expression<T1>>::Leaf_t,
                     typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l), CreateLeaf<ParticleAttrib<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
                                      typename CreateLeaf<Expression<T1>>::Leaf_t,
                                      typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::Expression_t
    operator&(const Expression<T1>& l, const ParticleAttrib<T2>& r)
{
  typedef BinaryNode<OpBitwiseAnd, typename CreateLeaf<Expression<T1>>::Leaf_t,
                     typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l), CreateLeaf<ParticleAttrib<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
                                      typename CreateLeaf<Expression<T1>>::Leaf_t,
                                      typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::Expression_t
    operator|(const Expression<T1>& l, const ParticleAttrib<T2>& r)
{
  typedef BinaryNode<OpBitwiseOr, typename CreateLeaf<Expression<T1>>::Leaf_t,
                     typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l), CreateLeaf<ParticleAttrib<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
                                      typename CreateLeaf<Expression<T1>>::Leaf_t,
                                      typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::Expression_t
    operator^(const Expression<T1>& l, const ParticleAttrib<T2>& r)
{
  typedef BinaryNode<OpBitwiseXor, typename CreateLeaf<Expression<T1>>::Leaf_t,
                     typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l), CreateLeaf<ParticleAttrib<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpAdd, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t>>::Expression_t
    operator+(const ParticleAttrib<T1>& l, const T2& r)
{
  typedef BinaryNode<OpAdd, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l), CreateLeaf<T2>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpSubtract, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t>>::
    Expression_t
    operator-(const ParticleAttrib<T1>& l, const T2& r)
{
  typedef BinaryNode<OpSubtract, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l), CreateLeaf<T2>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpMultiply, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t>>::
    Expression_t
    operator*(const ParticleAttrib<T1>& l, const T2& r)
{
  typedef BinaryNode<OpMultiply, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l), CreateLeaf<T2>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpMod, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t>>::Expression_t
    operator%(const ParticleAttrib<T1>& l, const T2& r)
{
  typedef BinaryNode<OpMod, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l), CreateLeaf<T2>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpBitwiseAnd, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t>>::
    Expression_t
    operator&(const ParticleAttrib<T1>& l, const T2& r)
{
  typedef BinaryNode<OpBitwiseAnd, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l), CreateLeaf<T2>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpBitwiseOr, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t>>::
    Expression_t
    operator|(const ParticleAttrib<T1>& l, const T2& r)
{
  typedef BinaryNode<OpBitwiseOr, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l), CreateLeaf<T2>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpBitwiseXor, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t>>::
    Expression_t
    operator^(const ParticleAttrib<T1>& l, const T2& r)
{
  typedef BinaryNode<OpBitwiseXor, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(l), CreateLeaf<T2>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpAdd, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::Expression_t
    operator+(const T1& l, const ParticleAttrib<T2>& r)
{
  typedef BinaryNode<OpAdd, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<T1>::make(l), CreateLeaf<ParticleAttrib<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpSubtract, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::
    Expression_t
    operator-(const T1& l, const ParticleAttrib<T2>& r)
{
  typedef BinaryNode<OpSubtract, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<T1>::make(l), CreateLeaf<ParticleAttrib<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpMultiply, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::
    Expression_t
    operator*(const T1& l, const ParticleAttrib<T2>& r)
{
  typedef BinaryNode<OpMultiply, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<T1>::make(l), CreateLeaf<ParticleAttrib<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpMod, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::Expression_t
    operator%(const T1& l, const ParticleAttrib<T2>& r)
{
  typedef BinaryNode<OpMod, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<T1>::make(l), CreateLeaf<ParticleAttrib<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpBitwiseAnd, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::
    Expression_t
    operator&(const T1& l, const ParticleAttrib<T2>& r)
{
  typedef BinaryNode<OpBitwiseAnd, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<T1>::make(l), CreateLeaf<ParticleAttrib<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpBitwiseOr, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::
    Expression_t
    operator|(const T1& l, const ParticleAttrib<T2>& r)
{
  typedef BinaryNode<OpBitwiseOr, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<T1>::make(l), CreateLeaf<ParticleAttrib<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpBitwiseXor, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>>::
    Expression_t
    operator^(const T1& l, const ParticleAttrib<T2>& r)
{
  typedef BinaryNode<OpBitwiseXor, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<ParticleAttrib<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<T1>::make(l), CreateLeaf<ParticleAttrib<T2>>::make(r)));
}
#ifdef PETE_ALLOW_SCALAR_SHIFT
#endif // PETE_ALLOW_SCALAR_SHIFT

template<class T1, class T2, class T3>
inline typename MakeReturn<TrinaryNode<FnWhere,
                                       typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t,
                                       typename CreateLeaf<T2>::Leaf_t,
                                       typename CreateLeaf<T3>::Leaf_t>>::Expression_t
    where(const ParticleAttrib<T1>& c, const T2& t, const T3& f)
{
  typedef TrinaryNode<FnWhere, typename CreateLeaf<ParticleAttrib<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t,
                      typename CreateLeaf<T3>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(
      Tree_t(CreateLeaf<ParticleAttrib<T1>>::make(c), CreateLeaf<T2>::make(t), CreateLeaf<T3>::make(f)));
}
#ifndef PETE_EXPRESSION_OPERATORS
#define PETE_EXPRESSION_OPERATORS

template<class T1>
inline typename MakeReturn<UnaryNode<OpUnaryMinus, typename CreateLeaf<Expression<T1>>::Leaf_t>>::Expression_t
    operator-(const Expression<T1>& l)
{
  typedef UnaryNode<OpUnaryMinus, typename CreateLeaf<Expression<T1>>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<OpUnaryPlus, typename CreateLeaf<Expression<T1>>::Leaf_t>>::Expression_t operator+(
    const Expression<T1>& l)
{
  typedef UnaryNode<OpUnaryPlus, typename CreateLeaf<Expression<T1>>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<OpBitwiseNot, typename CreateLeaf<Expression<T1>>::Leaf_t>>::Expression_t
    operator~(const Expression<T1>& l)
{
  typedef UnaryNode<OpBitwiseNot, typename CreateLeaf<Expression<T1>>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<OpIdentity, typename CreateLeaf<Expression<T1>>::Leaf_t>>::Expression_t
    PETE_identity(const Expression<T1>& l)
{
  typedef UnaryNode<OpIdentity, typename CreateLeaf<Expression<T1>>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l)));
}

template<class T1, class T2>
inline typename MakeReturn<UnaryNode<OpCast<T1>, typename CreateLeaf<Expression<T2>>::Leaf_t>>::Expression_t peteCast(
    const T1&,
    const Expression<T2>& l)
{
  typedef UnaryNode<OpCast<T1>, typename CreateLeaf<Expression<T2>>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T2>>::make(l)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpAdd, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t>>::
    Expression_t
    operator+(const Expression<T1>& l, const Expression<T2>& r)
{
  typedef BinaryNode<OpAdd, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l), CreateLeaf<Expression<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpSubtract, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t>>::
    Expression_t
    operator-(const Expression<T1>& l, const Expression<T2>& r)
{
  typedef BinaryNode<OpSubtract, typename CreateLeaf<Expression<T1>>::Leaf_t,
                     typename CreateLeaf<Expression<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l), CreateLeaf<Expression<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpMultiply, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t>>::
    Expression_t
    operator*(const Expression<T1>& l, const Expression<T2>& r)
{
  typedef BinaryNode<OpMultiply, typename CreateLeaf<Expression<T1>>::Leaf_t,
                     typename CreateLeaf<Expression<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l), CreateLeaf<Expression<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpMod, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t>>::
    Expression_t
    operator%(const Expression<T1>& l, const Expression<T2>& r)
{
  typedef BinaryNode<OpMod, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l), CreateLeaf<Expression<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
                                      typename CreateLeaf<Expression<T1>>::Leaf_t,
                                      typename CreateLeaf<Expression<T2>>::Leaf_t>>::Expression_t
    operator&(const Expression<T1>& l, const Expression<T2>& r)
{
  typedef BinaryNode<OpBitwiseAnd, typename CreateLeaf<Expression<T1>>::Leaf_t,
                     typename CreateLeaf<Expression<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l), CreateLeaf<Expression<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpBitwiseOr, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t>>::
    Expression_t
    operator|(const Expression<T1>& l, const Expression<T2>& r)
{
  typedef BinaryNode<OpBitwiseOr, typename CreateLeaf<Expression<T1>>::Leaf_t,
                     typename CreateLeaf<Expression<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l), CreateLeaf<Expression<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
                                      typename CreateLeaf<Expression<T1>>::Leaf_t,
                                      typename CreateLeaf<Expression<T2>>::Leaf_t>>::Expression_t
    operator^(const Expression<T1>& l, const Expression<T2>& r)
{
  typedef BinaryNode<OpBitwiseXor, typename CreateLeaf<Expression<T1>>::Leaf_t,
                     typename CreateLeaf<Expression<T2>>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l), CreateLeaf<Expression<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpAdd, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t>>::Expression_t
    operator+(const Expression<T1>& l, const T2& r)
{
  typedef BinaryNode<OpAdd, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l), CreateLeaf<T2>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpSubtract, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t>>::Expression_t
    operator-(const Expression<T1>& l, const T2& r)
{
  typedef BinaryNode<OpSubtract, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l), CreateLeaf<T2>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpMultiply, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t>>::Expression_t
    operator*(const Expression<T1>& l, const T2& r)
{
  typedef BinaryNode<OpMultiply, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l), CreateLeaf<T2>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpMod, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t>>::Expression_t
    operator%(const Expression<T1>& l, const T2& r)
{
  typedef BinaryNode<OpMod, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l), CreateLeaf<T2>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpBitwiseAnd, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t>>::
    Expression_t
    operator&(const Expression<T1>& l, const T2& r)
{
  typedef BinaryNode<OpBitwiseAnd, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l), CreateLeaf<T2>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpBitwiseOr, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t>>::Expression_t
    operator|(const Expression<T1>& l, const T2& r)
{
  typedef BinaryNode<OpBitwiseOr, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l), CreateLeaf<T2>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpBitwiseXor, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t>>::
    Expression_t
    operator^(const Expression<T1>& l, const T2& r)
{
  typedef BinaryNode<OpBitwiseXor, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<Expression<T1>>::make(l), CreateLeaf<T2>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpAdd, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t>>::Expression_t
    operator+(const T1& l, const Expression<T2>& r)
{
  typedef BinaryNode<OpAdd, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<T1>::make(l), CreateLeaf<Expression<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpSubtract, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t>>::Expression_t
    operator-(const T1& l, const Expression<T2>& r)
{
  typedef BinaryNode<OpSubtract, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<T1>::make(l), CreateLeaf<Expression<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpMultiply, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t>>::Expression_t
    operator*(const T1& l, const Expression<T2>& r)
{
  typedef BinaryNode<OpMultiply, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<T1>::make(l), CreateLeaf<Expression<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpMod, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t>>::Expression_t
    operator%(const T1& l, const Expression<T2>& r)
{
  typedef BinaryNode<OpMod, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<T1>::make(l), CreateLeaf<Expression<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpBitwiseAnd, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t>>::
    Expression_t
    operator&(const T1& l, const Expression<T2>& r)
{
  typedef BinaryNode<OpBitwiseAnd, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<T1>::make(l), CreateLeaf<Expression<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpBitwiseOr, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t>>::Expression_t
    operator|(const T1& l, const Expression<T2>& r)
{
  typedef BinaryNode<OpBitwiseOr, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<T1>::make(l), CreateLeaf<Expression<T2>>::make(r)));
}

template<class T1, class T2>
inline typename MakeReturn<
    BinaryNode<OpBitwiseXor, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t>>::
    Expression_t
    operator^(const T1& l, const Expression<T2>& r)
{
  typedef BinaryNode<OpBitwiseXor, typename CreateLeaf<T1>::Leaf_t, typename CreateLeaf<Expression<T2>>::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(CreateLeaf<T1>::make(l), CreateLeaf<Expression<T2>>::make(r)));
}
#ifdef PETE_ALLOW_SCALAR_SHIFT
#endif // PETE_ALLOW_SCALAR_SHIFT

template<class T1, class T2, class T3>
inline typename MakeReturn<TrinaryNode<FnWhere,
                                       typename CreateLeaf<Expression<T1>>::Leaf_t,
                                       typename CreateLeaf<T2>::Leaf_t,
                                       typename CreateLeaf<T3>::Leaf_t>>::Expression_t
    where(const Expression<T1>& c, const T2& t, const T3& f)
{
  typedef TrinaryNode<FnWhere, typename CreateLeaf<Expression<T1>>::Leaf_t, typename CreateLeaf<T2>::Leaf_t,
                      typename CreateLeaf<T3>::Leaf_t>
      Tree_t;
  return MakeReturn<Tree_t>::make(
      Tree_t(CreateLeaf<Expression<T1>>::make(c), CreateLeaf<T2>::make(t), CreateLeaf<T3>::make(f)));
}
#endif // PETE_EXPRESSION_OPERATORS

template<class T1, class RHS>
inline ParticleAttrib<T1>& assign(ParticleAttrib<T1>& lhs, const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs, OpAssign(), MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1, class RHS>
inline ParticleAttrib<T1>& operator+=(ParticleAttrib<T1>& lhs, const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs, OpAddAssign(), MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1, class RHS>
inline ParticleAttrib<T1>& operator-=(ParticleAttrib<T1>& lhs, const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs, OpSubtractAssign(), MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1, class RHS>
inline ParticleAttrib<T1>& operator*=(ParticleAttrib<T1>& lhs, const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs, OpMultiplyAssign(), MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1, class RHS>
inline ParticleAttrib<T1>& operator%=(ParticleAttrib<T1>& lhs, const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs, OpModAssign(), MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1, class RHS>
inline ParticleAttrib<T1>& operator|=(ParticleAttrib<T1>& lhs, const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs, OpBitwiseOrAssign(), MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1, class RHS>
inline ParticleAttrib<T1>& operator&=(ParticleAttrib<T1>& lhs, const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs, OpBitwiseAndAssign(), MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1, class RHS>
inline ParticleAttrib<T1>& operator^=(ParticleAttrib<T1>& lhs, const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs, OpBitwiseXorAssign(), MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

/////////////////////////////////////////////////////////////////////////////
// specialization of CreateLeaf for ParticleAttrib
/////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
// We need to specialize CreateLeaf<T> for our class, so that operators
// know what to stick in the leaves of the expression tree.
//-----------------------------------------------------------------------------
template<class T>
struct CreateLeaf<ParticleAttrib<T>>
{
  typedef Reference<ParticleAttrib<T>> Leaf_t;
  inline static Leaf_t make(const ParticleAttrib<T>& a) { return Leaf_t(a); }
};

//-----------------------------------------------------------------------------
// We need to write a functor that is capable of comparing the size of
// the vector with a stored value. Then, we supply LeafFunctor specializations
// for Scalar<T> and STL vector leaves.
//-----------------------------------------------------------------------------
class SizeLeafPA
{
public:
  SizeLeafPA(int s) : size_m(s) {}
  SizeLeafPA(const SizeLeafPA& model) : size_m(model.size_m) {}
  bool operator()(int s) const { return size_m == s; }

private:
  int size_m;
};

template<class T>
struct LeafFunctor<Scalar<T>, SizeLeafPA>
{
  typedef bool Type_t;
  inline static bool apply(const Scalar<T>&, const SizeLeafPA&)
  {
    // Scalars always conform.
    return true;
  }
};

template<class T>
struct LeafFunctor<ParticleAttrib<T>, SizeLeafPA>
{
  typedef bool Type_t;
  inline static bool apply(const ParticleAttrib<T>& v, const SizeLeafPA& s) { return s(v.size()); }
};

//-----------------------------------------------------------------------------
// EvalLeaf1 is used to evaluate expression with vectors.
// (It's already defined for Scalar values.)
//-----------------------------------------------------------------------------

template<class T>
struct LeafFunctor<ParticleAttrib<T>, EvalLeaf1>
{
  typedef T Type_t;
  inline static Type_t apply(const ParticleAttrib<T>& vec, const EvalLeaf1& f) { return vec[f.val1()]; }
};

//////////////////////////////////////////////////////////////////////////////////
// LOOP is done by evaluate function
//////////////////////////////////////////////////////////////////////////////////
template<class T, class Op, class RHS>
inline void evaluate(ParticleAttrib<T>& lhs, const Op& op, const Expression<RHS>& rhs)
{
  if (forEach(rhs, SizeLeafPA(lhs.size()), AndCombine()))
  {
    // We get here if the vectors on the RHS are the same size as those on
    // the LHS.
    for (int i = 0; i < lhs.size(); ++i)
    {
      // The actual assignment operation is performed here.
      // PETE operator tags all define operator() to perform the operation.
      // (In this case op performs an assignment.) forEach is used
      // to compute the rhs value.  EvalLeaf1 gets the
      // values at each node using random access, and the tag
      // OpCombine tells forEach to use the operator tags in the expression
      // to combine values together.
      op(lhs[i], forEach(rhs, EvalLeaf1(i), OpCombine()));
    }
  }
  else
  {
    throw std::runtime_error("Error in evaluate: LHS and RHS don't conform in ParticleAttrib.");
  }
}

// I/O
template<class T>
std::ostream& operator<<(std::ostream& out, const ParticleAttrib<T>& rhs)
{
  for (int i = 0; i < rhs.size(); i++)
    out << rhs[i] << std::endl;
  return out;
}

} // namespace qmcplusplus
#endif // OHMMS_PARTICLEATTRIB_PEPE_OPERATORS_H
