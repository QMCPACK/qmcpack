//////////////////////////////////////////////////////////////////////////////////////
// This file is distributed under the University of Illinois/NCSA Open Source License.
// See LICENSE file in top directory for details.
//
// Copyright (c) 2016 Jeongnim Kim and QMCPACK developers.
//
// File developed by: Jeremy McMinnis, jmcminis@gmail.com, University of Illinois at Urbana-Champaign
//                    Jeongnim Kim, jeongnim.kim@gmail.com, University of Illinois at Urbana-Champaign
//                    Cynthia Gu, zg1@ornl.gov, Oak Ridge National Laboratory
//                    Mark A. Berrill, berrillma@ornl.gov, Oak Ridge National Laboratory
//
// File created by: Jeongnim Kim, jeongnim.kim@gmail.com, University of Illinois at Urbana-Champaign
//////////////////////////////////////////////////////////////////////////////////////


#include <Particle/MCWalkerConfiguration.h>
#include <Particle/HDFWalkerInput_0_4.h>
#include <io/hdf_archive.h>
#include <mpi/mpi_datatype.h>
#include <mpi/collectives.h>
#include "Utilities/FairDivide.h"

namespace qmcplusplus
{
HDFWalkerInput_0_4::HDFWalkerInput_0_4(MCWalkerConfiguration& W, Communicate* c, const HDFVersion& v)
    : targetW(W), myComm(c), cur_version(0, 4)
{
  i_info.version = v;
}

HDFWalkerInput_0_4::~HDFWalkerInput_0_4()
{
  //if(h_plist != H5P_DEFAULT) H5Pclose(h_plist);
}

void HDFWalkerInput_0_4::checkOptions(xmlNodePtr cur)
{
  i_info.reset();
  std::string froot, cfile;
  std::string collected("no");
  OhmmsAttributeSet pAttrib;
  pAttrib.add(i_info.nprocs, "nprocs");
  pAttrib.add(i_info.rank, "node");
  pAttrib.add(cfile, "href");
  pAttrib.add(cfile, "file");
  pAttrib.add(froot, "fileroot");
  pAttrib.add(collected, "collected");
  pAttrib.put(cur);
  if (froot.empty())
    return;
  int ext;
  {
    ext = froot.find(hdf::config_ext);
  }
  if (ext < froot.size())
  {
    //remove extenstion
    froot.erase(froot.begin() + ext, froot.end());
  }
  //file generated by a serial run is automatically collected
  i_info.collected = ((collected == "yes") || (i_info.nprocs == 1));
  if (i_info.collected)
    FileStack.push(froot);
  else
  {
    if (i_info.nprocs > 1) //need to process multiple files
    {
      int nprocs_now = myComm->size();
      if (i_info.nprocs > nprocs_now) //using less nodes
      {
        int np  = i_info.nprocs / nprocs_now;
        int pid = myComm->rank(), ip = 0;
        while (pid < i_info.nprocs && ip < np)
        {
          char* h5name = new char[froot.size() + 10];
          sprintf(h5name, "%s.p%03d", froot.c_str(), pid++);
          FileStack.push(h5name);
          delete[] h5name;
          pid += nprocs_now;
        }
      }
      else
      {
        int pid      = myComm->rank() % i_info.nprocs;
        char* h5name = new char[froot.size() + 10];
        sprintf(h5name, "%s.p%03d", froot.c_str(), pid);
        FileStack.push(h5name);
        delete[] h5name;
      }
    }
    else
    {
      FileStack.push(froot);
    }
  }
}

bool HDFWalkerInput_0_4::put(xmlNodePtr cur)
{
  checkOptions(cur);
  if (FileStack.empty())
  {
    app_error() << "  No valid input hdf5 is found." << std::endl;
    return false;
  }
  bool success = true;
  while (FileStack.size())
  {
    FileName = FileStack.top();
    FileStack.pop();
    std::string h5name(FileName);
    //success |= read_hdf5_scatter(h5name);
#ifdef ENABLE_PHDF5
    success |= read_phdf5(h5name);
#else
    success |= read_hdf5(h5name);
#endif
  }
  return success;
}

bool HDFWalkerInput_0_4::read_hdf5(std::string h5name)
{
  int nw_in = 0;

  h5name.append(hdf::config_ext);
  hdf_archive hin(myComm, false); //everone reads this
  bool success = hin.open(h5name, H5F_ACC_RDONLY);
  //check if hdf and xml versions can work together
  HDFVersion aversion;

  hin.read(aversion, hdf::version);
  if (!(aversion < i_info.version))
  {
    int found_group = hin.is_group(hdf::main_state);
    hin.push(hdf::main_state);
    hin.read(nw_in, hdf::num_walkers);
  }
  else
  {
    app_error() << " Mismatched version. xml = " << i_info.version << " hdf = " << aversion << std::endl;
  }

  if (nw_in == 0)
  {
    app_error() << " No walkers in " << h5name << std::endl;
    return false;
  }

  typedef std::vector<QMCTraits::RealType> Buffer_t;
  Buffer_t posin;
  std::array<int, 3> dims{nw_in, static_cast<int>(targetW.getTotalNum()), OHMMS_DIM};
  posin.resize(dims[0] * dims[1] * dims[2]);
  hin.readSlabReshaped(posin, dims, hdf::walkers);

  std::vector<int> woffsets;
  hin.read(woffsets, "walker_partition");

  int np1 = myComm->size() + 1;
  std::vector<int> counts(np1);
  if (woffsets.size() != np1)
  {
    woffsets.resize(myComm->size() + 1, 0);
    FairDivideLow(nw_in, myComm->size(), woffsets);
  }

  app_log() << " HDFWalkerInput_0_4::put getting " << dims[0] << " walkers " << posin.size() << std::endl;
  nw_in = woffsets[myComm->rank() + 1] - woffsets[myComm->rank()];
  {
    int nitems    = targetW.getTotalNum() * OHMMS_DIM;
    int curWalker = targetW.getActiveWalkers();
    targetW.createWalkers(nw_in);
    Buffer_t::iterator it(posin.begin() + woffsets[myComm->rank()] * nitems);
    for (int i = 0, iw = curWalker; i < nw_in; ++i, ++iw)
    {
      copy(it, it + nitems, get_first_address(targetW[iw]->R));
      it += nitems;
    }
  }

  //{
  //  char fname[128];
  //  sprintf(fname,"%s.p%03d.xyz",FileName.c_str(),myComm->rank());
  //  std::ofstream fout(fname);
  //  MCWalkerConfiguration::iterator it = targetW.begin();
  //  int iw=0;
  //  while(it != targetW.end())
  //  {
  //    fout << iw << std::endl;
  //    MCWalkerConfiguration::Walker_t& thisWalker(**it);
  //    for(int iat=0; iat<targetW.getTotalNum(); ++iat)
  //      fout << thisWalker.R[iat] << std::endl;
  //    ++it; ++iw;
  //  }
  //}
  return true;
}

bool HDFWalkerInput_0_4::read_hdf5_scatter(std::string h5name)
{
  int nw_in = 0;
  h5name.append(hdf::config_ext);

  if (myComm->rank() == 0)
  {
    hdf_archive hin(myComm); //everone reads this
    bool success = hin.open(h5name, H5F_ACC_RDONLY);
    //check if hdf and xml versions can work together
    HDFVersion aversion;

    hin.read(aversion, hdf::version);
    if (!(aversion < i_info.version))
    {
      int found_group = hin.is_group(hdf::main_state);
      hin.push(hdf::main_state);
      hin.read(nw_in, hdf::num_walkers);
    }
    else
    {
      app_error() << " Mismatched version. xml = " << i_info.version << " hdf = " << aversion << std::endl;
    }
  }

  myComm->barrier();
  mpi::bcast(*myComm, nw_in);

  if (nw_in == 0)
  {
    app_error() << " No walkers in " << h5name << std::endl;
    return false;
  }

  typedef std::vector<QMCTraits::RealType> Buffer_t;

  int np1 = myComm->size() + 1;
  std::vector<int> counts(myComm->size()), woffsets(np1, 0);
  FairDivideLow(nw_in, myComm->size(), woffsets);

  int nw_loc = woffsets[myComm->rank() + 1] - woffsets[myComm->rank()];

  int nitems = targetW.getTotalNum() * OHMMS_DIM;
  for (int i = 0; i < woffsets.size(); ++i)
    woffsets[i] *= nitems;
  for (int i = 0; i < counts.size(); ++i)
    counts[i] = woffsets[i + 1] - woffsets[i];

  std::array<int, 3> dims{nw_in, static_cast<int>(targetW.getTotalNum()), OHMMS_DIM};
  Buffer_t posin(nw_in * nitems), posout(counts[myComm->rank()]);

  if (myComm->rank() == 0)
  {
    hdf_archive hin(myComm);
    bool success = hin.open(h5name, H5F_ACC_RDONLY);
    hin.push(hdf::main_state);
    hin.readSlabReshaped(posin, dims, hdf::walkers);
  }

  mpi::scatterv(*myComm, posin, posout, counts, woffsets);

  int curWalker = targetW.getActiveWalkers();
  targetW.createWalkers(nw_loc);
  Buffer_t::iterator it(posout.begin());
  for (int i = 0, iw = curWalker; i < nw_loc; ++i, ++iw)
  {
    copy(it, it + nitems, get_first_address(targetW[iw]->R));
    it += nitems;
  }
  return true;
}

bool HDFWalkerInput_0_4::read_phdf5(std::string h5name)
{
  int nw_in = 0;
  h5name.append(hdf::config_ext);
  std::vector<int> woffsets;
  int woffsets_size = 0;
  bool success = false;

  { // handle small dataset with master rank
    hdf_archive hin(myComm, false);
    if (!myComm->rank())
    {
      success = hin.open(h5name, H5F_ACC_RDONLY);
      //check if hdf and xml versions can work together
      HDFVersion aversion;

      hin.read(aversion, hdf::version);
      if (!(aversion < i_info.version))
      {
        int found_group = hin.is_group(hdf::main_state);
        hin.push(hdf::main_state);
        hin.read(nw_in, hdf::num_walkers);
        if (nw_in == 0)
        {
          app_error() << " No walkers in " << h5name << std::endl;
          success = false;
        }
      }
      else
      {
        app_error() << " Mismatched version. xml = " << i_info.version << " hdf = " << aversion << std::endl;
        success = false;
      }
    }
    mpi::bcast(*myComm, success);
    if (!success)
      return false;

    // load woffsets by master
    // can not read collectively since the size may differ from Nranks+1.
    if (!myComm->rank())
    {
      hin.read(woffsets, "walker_partition");
      woffsets_size = woffsets.size();
      assert(woffsets[woffsets_size - 1] == nw_in);
    }

    mpi::bcast(*myComm, woffsets_size);
    woffsets.resize(woffsets_size);
    mpi::bcast(*myComm, woffsets.data(), woffsets_size);
    nw_in = woffsets[woffsets_size - 1];
  }

  hdf_archive hin(myComm, true); //everone reads this
  success         = hin.open(h5name, H5F_ACC_RDONLY);
  int found_group = hin.is_group(hdf::main_state);
  hin.push(hdf::main_state);

  typedef std::vector<QMCTraits::RealType> Buffer_t;
  Buffer_t posin;
  std::array<int, 3> dims{nw_in, static_cast<int>(targetW.getTotalNum()), OHMMS_DIM};

  if (woffsets.size() != myComm->size() + 1)
  {
    woffsets.resize(myComm->size() + 1, 0);
    FairDivideLow(nw_in, myComm->size(), woffsets);
  }

  int nw_loc = woffsets[myComm->rank() + 1] - woffsets[myComm->rank()];

  std::array<int, 3> counts{nw_loc, static_cast<int>(targetW.getTotalNum()), OHMMS_DIM};
  std::array<int, 3> offsets{woffsets[myComm->rank()], 0, 0};
  posin.resize(nw_loc * dims[1] * dims[2]);

  hyperslab_proxy<Buffer_t, 3> slab(posin, dims, counts, offsets);
  hin.read(slab, hdf::walkers);

  app_log() << " HDFWalkerInput_0_4::put getting " << dims[0] << " walkers " << posin.size() << std::endl;
  nw_in = woffsets[myComm->rank() + 1] - woffsets[myComm->rank()];
  {
    int nitems    = targetW.getTotalNum() * OHMMS_DIM;
    int curWalker = targetW.getActiveWalkers();
    targetW.createWalkers(nw_in);
    Buffer_t::iterator it(posin.begin());
    for (int i = 0, iw = curWalker; i < nw_in; ++i, ++iw)
    {
      copy(it, it + nitems, get_first_address(targetW[iw]->R));
      it += nitems;
    }
  }
  return true;
}

} // namespace qmcplusplus
