//////////////////////////////////////////////////////////////////////////////////////
// This file is distributed under the University of Illinois/NCSA Open Source License.
// See LICENSE file in top directory for details.
//
// Copyright (c) 2016 Jeongnim Kim and QMCPACK developers.
//
// File developed by: Jeremy McMinnis, jmcminis@gmail.com, University of Illinois at Urbana-Champaign
//                    Jeongnim Kim, jeongnim.kim@gmail.com, University of Illinois at Urbana-Champaign
//                    Cynthia Gu, zg1@ornl.gov, Oak Ridge National Laboratory
//                    Mark A. Berrill, berrillma@ornl.gov, Oak Ridge National Laboratory
//
// File created by: Jeongnim Kim, jeongnim.kim@gmail.com, University of Illinois at Urbana-Champaign
//////////////////////////////////////////////////////////////////////////////////////


#include "HDFWalkerInput_0_4.h"
#include "hdf/hdf_archive.h"
#include "mpi/mpi_datatype.h"
#include "mpi/collectives.h"
#include "Utilities/FairDivide.h"

namespace qmcplusplus
{
HDFWalkerInput_0_4::HDFWalkerInput_0_4(WalkerConfigurations& wc_list,
                                       size_t num_ptcls,
                                       Communicate* c,
                                       const HDFVersion& v)
    : wc_list_(wc_list), num_ptcls_(num_ptcls), myComm(c), cur_version(0, 4)
{
  i_info.version = v;
}

HDFWalkerInput_0_4::~HDFWalkerInput_0_4()
{
  //if(h_plist != H5P_DEFAULT) H5Pclose(h_plist);
}

void HDFWalkerInput_0_4::checkOptions(xmlNodePtr cur)
{
  i_info.reset();
  std::string froot, cfile;
  std::string collected("no");
  OhmmsAttributeSet pAttrib;
  pAttrib.add(i_info.nprocs, "nprocs");
  pAttrib.add(i_info.rank, "node");
  pAttrib.add(cfile, "href");
  pAttrib.add(cfile, "file");
  pAttrib.add(froot, "fileroot");
  pAttrib.add(collected, "collected");
  pAttrib.put(cur);
  if (froot.empty())
    return;
  int ext;
  {
    ext = froot.find(hdf::config_ext);
  }
  if (ext < froot.size())
  {
    //remove extenstion
    froot.erase(froot.begin() + ext, froot.end());
  }
  //file generated by a serial run is automatically collected
  i_info.collected = ((collected == "yes") || (i_info.nprocs == 1));
  if (i_info.collected)
    FileStack.push(froot);
  else
  {
    if (i_info.nprocs > 1) //need to process multiple files
    {
      int nprocs_now = myComm->size();
      if (i_info.nprocs > nprocs_now) //using less nodes
      {
        int np  = i_info.nprocs / nprocs_now;
        int pid = myComm->rank(), ip = 0;
        while (pid < i_info.nprocs && ip < np)
        {
          char* h5name = new char[froot.size() + 10];
          sprintf(h5name, "%s.p%03d", froot.c_str(), pid++);
          FileStack.push(h5name);
          delete[] h5name;
          pid += nprocs_now;
        }
      }
      else
      {
        int pid      = myComm->rank() % i_info.nprocs;
        char* h5name = new char[froot.size() + 10];
        sprintf(h5name, "%s.p%03d", froot.c_str(), pid);
        FileStack.push(h5name);
        delete[] h5name;
      }
    }
    else
    {
      FileStack.push(froot);
    }
  }
}

bool HDFWalkerInput_0_4::put(xmlNodePtr cur)
{
  checkOptions(cur);
  if (FileStack.empty())
  {
    app_error() << "  No valid input hdf5 is found." << std::endl;
    return false;
  }
  bool success = true;
  while (FileStack.size())
  {
    FileName = FileStack.top();
    FileStack.pop();
    std::string h5name(FileName);
    //success |= read_hdf5_scatter(h5name);
#ifdef ENABLE_PHDF5
    success |= read_phdf5(h5name);
#else
    success |= read_hdf5(h5name);
#endif
  }
  return success;
}

bool HDFWalkerInput_0_4::read_hdf5(std::string h5name)
{
  size_t nw_in = 0;

  h5name.append(hdf::config_ext);
  hdf_archive hin(myComm, false); //everone reads this
  bool success = hin.open(h5name, H5F_ACC_RDONLY);
  //check if hdf and xml versions can work together
  HDFVersion aversion;

  hin.read(aversion, hdf::version);
  if (!(aversion < i_info.version))
  {
    int found_group = hin.is_group(hdf::main_state);
    hin.push(hdf::main_state);
    hin.read(nw_in, hdf::num_walkers);
  }
  else
  {
    app_error() << " Mismatched version. xml = " << i_info.version << " hdf = " << aversion << std::endl;
  }

  if (nw_in == 0)
  {
    app_error() << " No walkers in " << h5name << std::endl;
    return false;
  }

  using Buffer_t = std::vector<QMCTraits::RealType>;
  Buffer_t posin;
  std::array<size_t, 3> dims{nw_in, num_ptcls_, OHMMS_DIM};
  posin.resize(dims[0] * dims[1] * dims[2]);
  hin.readSlabReshaped(posin, dims, hdf::walkers);

  std::vector<int> woffsets;
  hin.read(woffsets, "walker_partition");

  int np1 = myComm->size() + 1;
  if (woffsets.size() != np1)
  {
    woffsets.resize(myComm->size() + 1, 0);
    FairDivideLow(nw_in, myComm->size(), woffsets);
  }

  app_log() << " HDFWalkerInput_0_4::put getting " << dims[0] << " walkers " << posin.size() << std::endl;
  nw_in = woffsets[myComm->rank() + 1] - woffsets[myComm->rank()];
  {
    const int nitems    = num_ptcls_ * OHMMS_DIM;
    const int curWalker = wc_list_.getActiveWalkers();
    wc_list_.createWalkers(nw_in, num_ptcls_);
    Buffer_t::iterator it(posin.begin() + woffsets[myComm->rank()] * nitems);
    for (int i = 0, iw = curWalker; i < nw_in; ++i, ++iw)
    {
      copy(it, it + nitems, get_first_address(wc_list_[iw]->R));
      it += nitems;
    }
  }

  return true;
}

bool HDFWalkerInput_0_4::read_hdf5_scatter(std::string h5name)
{
  size_t nw_in = 0;
  h5name.append(hdf::config_ext);

  if (myComm->rank() == 0)
  {
    hdf_archive hin(myComm); //everone reads this
    bool success = hin.open(h5name, H5F_ACC_RDONLY);
    //check if hdf and xml versions can work together
    HDFVersion aversion;

    hin.read(aversion, hdf::version);
    if (!(aversion < i_info.version))
    {
      int found_group = hin.is_group(hdf::main_state);
      hin.push(hdf::main_state);
      hin.read(nw_in, hdf::num_walkers);
    }
    else
    {
      app_error() << " Mismatched version. xml = " << i_info.version << " hdf = " << aversion << std::endl;
    }
  }

  myComm->barrier();
  mpi::bcast(*myComm, nw_in);

  if (nw_in == 0)
  {
    app_error() << " No walkers in " << h5name << std::endl;
    return false;
  }

  using Buffer_t = std::vector<QMCTraits::RealType>;

  const int np1 = myComm->size() + 1;
  std::vector<int> counts(myComm->size()), woffsets(np1, 0);
  FairDivideLow(nw_in, myComm->size(), woffsets);

  const size_t nw_loc = woffsets[myComm->rank() + 1] - woffsets[myComm->rank()];

  const int nitems = num_ptcls_ * OHMMS_DIM;
  for (int i = 0; i < woffsets.size(); ++i)
    woffsets[i] *= nitems;
  for (int i = 0; i < counts.size(); ++i)
    counts[i] = woffsets[i + 1] - woffsets[i];

  std::array<size_t, 3> dims{nw_in, num_ptcls_, OHMMS_DIM};
  Buffer_t posin(nw_in * nitems), posout(counts[myComm->rank()]);

  if (myComm->rank() == 0)
  {
    hdf_archive hin(myComm);
    bool success = hin.open(h5name, H5F_ACC_RDONLY);
    hin.push(hdf::main_state);
    hin.readSlabReshaped(posin, dims, hdf::walkers);
  }

  mpi::scatterv(*myComm, posin, posout, counts, woffsets);

  const int curWalker = wc_list_.getActiveWalkers();
  wc_list_.createWalkers(nw_loc, num_ptcls_);
  Buffer_t::iterator it(posout.begin());
  for (int i = 0, iw = curWalker; i < nw_loc; ++i, ++iw)
  {
    copy(it, it + nitems, get_first_address(wc_list_[iw]->R));
    it += nitems;
  }
  return true;
}

bool HDFWalkerInput_0_4::read_phdf5(std::string h5name)
{
  size_t nw_in = 0;
  h5name.append(hdf::config_ext);
  std::vector<int> woffsets;
  int woffsets_size = 0;
  bool success      = false;

  { // handle small dataset with master rank
    hdf_archive hin(myComm, false);
    if (!myComm->rank())
    {
      success = hin.open(h5name, H5F_ACC_RDONLY);
      //check if hdf and xml versions can work together
      HDFVersion aversion;

      hin.read(aversion, hdf::version);
      if (!(aversion < i_info.version))
      {
        int found_group = hin.is_group(hdf::main_state);
        hin.push(hdf::main_state);
        hin.read(nw_in, hdf::num_walkers);
        if (nw_in == 0)
        {
          app_error() << " No walkers in " << h5name << std::endl;
          success = false;
        }
      }
      else
      {
        app_error() << " Mismatched version. xml = " << i_info.version << " hdf = " << aversion << std::endl;
        success = false;
      }
    }
    mpi::bcast(*myComm, success);
    if (!success)
      return false;

    // load woffsets by master
    // can not read collectively since the size may differ from Nranks+1.
    if (!myComm->rank())
    {
      hin.read(woffsets, "walker_partition");
      woffsets_size = woffsets.size();
      assert(woffsets[woffsets_size - 1] == nw_in);
    }

    mpi::bcast(*myComm, woffsets_size);
    woffsets.resize(woffsets_size);
    mpi::bcast(*myComm, woffsets.data(), woffsets_size);
    nw_in = woffsets[woffsets_size - 1];
  }

  hdf_archive hin(myComm, true); //everone reads this
  success         = hin.open(h5name, H5F_ACC_RDONLY);
  int found_group = hin.is_group(hdf::main_state);
  hin.push(hdf::main_state);

  using Buffer_t = std::vector<QMCTraits::RealType>;
  Buffer_t posin;
  std::array<size_t, 3> dims{nw_in, num_ptcls_, OHMMS_DIM};

  if (woffsets.size() != myComm->size() + 1)
  {
    woffsets.resize(myComm->size() + 1, 0);
    FairDivideLow(nw_in, myComm->size(), woffsets);
  }

  const size_t nw_loc = woffsets[myComm->rank() + 1] - woffsets[myComm->rank()];

  std::array<size_t, 3> counts{nw_loc, num_ptcls_, OHMMS_DIM};
  std::array<size_t, 3> offsets{static_cast<size_t>(woffsets[myComm->rank()]), 0, 0};
  posin.resize(nw_loc * dims[1] * dims[2]);

  hyperslab_proxy<Buffer_t, 3> slab(posin, dims, counts, offsets);
  hin.read(slab, hdf::walkers);

  app_log() << " HDFWalkerInput_0_4::put getting " << dims[0] << " walkers " << posin.size() << std::endl;
  nw_in = woffsets[myComm->rank() + 1] - woffsets[myComm->rank()];
  {
    const int nitems    = num_ptcls_ * OHMMS_DIM;
    const int curWalker = wc_list_.getActiveWalkers();
    wc_list_.createWalkers(nw_in, num_ptcls_);
    Buffer_t::iterator it(posin.begin());
    for (int i = 0, iw = curWalker; i < nw_in; ++i, ++iw)
    {
      copy(it, it + nitems, get_first_address(wc_list_[iw]->R));
      it += nitems;
    }
  }
  return true;
}

} // namespace qmcplusplus
