//////////////////////////////////////////////////////////////////////////////////////
// This file is distributed under the University of Illinois/NCSA Open Source License.
// See LICENSE file in top directory for details.
//
// Copyright (c) 2016 Jeongnim Kim and QMCPACK developers.
//
// File developed by: Jeremy McMinnis, jmcminis@gmail.com, University of Illinois at Urbana-Champaign
//                    Jeongnim Kim, jeongnim.kim@gmail.com, University of Illinois at Urbana-Champaign
//                    Cynthia Gu, zg1@ornl.gov, Oak Ridge National Laboratory
//                    Mark A. Berrill, berrillma@ornl.gov, Oak Ridge National Laboratory
//
// File created by: Jeongnim Kim, jeongnim.kim@gmail.com, University of Illinois at Urbana-Champaign
//////////////////////////////////////////////////////////////////////////////////////
    
    



#include <Particle/MCWalkerConfiguration.h>
#include <Particle/HDFWalkerInput_0_4.h>
#include <io/hdf_archive.h>
#include <mpi/mpi_datatype.h>
#include <mpi/collectives.h>
#ifdef HAVE_ADIOS
#include "ADIOS/ADIOS_config.h"
#endif

namespace qmcplusplus
{

HDFWalkerInput_0_4::HDFWalkerInput_0_4(MCWalkerConfiguration& W, Communicate* c, const HDFVersion& v)
  : targetW(W), myComm(c), cur_version(0,4)
{
  i_info.version=v;
}

HDFWalkerInput_0_4::~HDFWalkerInput_0_4()
{
  //if(h_plist != H5P_DEFAULT) H5Pclose(h_plist);
}

void HDFWalkerInput_0_4::checkOptions(xmlNodePtr cur)
{
  i_info.reset();
  std::string froot,cfile;
  std::string collected("no");
  OhmmsAttributeSet pAttrib;
  pAttrib.add(i_info.nprocs,"nprocs");
  pAttrib.add(i_info.rank,"node");
  pAttrib.add(cfile,"href");
  pAttrib.add(cfile,"file");
  pAttrib.add(froot,"fileroot");
  pAttrib.add(collected,"collected");
  pAttrib.put(cur);
  if(froot.empty())
    return;
  int ext;
#ifdef HAVE_ADIOS
  if(ADIOS::getRdADIOS())
  {
    ext=froot.find(".config.bp");
  }
  else if(ADIOS::getRdHDF5())
#endif
  {
    ext=froot.find(hdf::config_ext);
  }
  if(ext<froot.size())
  {
    //remove extenstion
    froot.erase(froot.begin()+ext,froot.end());
  }
  //file generated by a serial run is automatically collected
  i_info.collected = ((collected == "yes") || (i_info.nprocs == 1));
  if(i_info.collected)
    FileStack.push(froot);
  else
  {
    if(i_info.nprocs>1)//need to process multiple files
    {
      int nprocs_now=myComm->size();
      if(i_info.nprocs>nprocs_now)//using less nodes
      {
        int np=i_info.nprocs/nprocs_now;
        int pid=myComm->rank(), ip=0;
        while(pid<i_info.nprocs && ip<np)
        {
          char *h5name=new char[froot.size()+10];
          sprintf(h5name,"%s.p%03d",froot.c_str(),pid++);
          FileStack.push(h5name);
          delete [] h5name;
          pid += nprocs_now;
        }
      }
      else
      {
        int pid=myComm->rank()%i_info.nprocs;
        char *h5name=new char[froot.size()+10];
        sprintf(h5name,"%s.p%03d",froot.c_str(),pid);
        FileStack.push(h5name);
        delete [] h5name;
      }
    }
    else
    {
      FileStack.push(froot);
    }
  }
}

bool HDFWalkerInput_0_4::put(xmlNodePtr cur)
{
  checkOptions(cur);
  if(FileStack.empty())
  {
    app_error() << "  No valid input hdf5 is found." << std::endl;
    return false;
  }
#ifdef HAVE_ADIOS
  return read_adios(cur);
#else
  bool success = true;
  while(FileStack.size())
  {
    FileName=FileStack.top();
    FileStack.pop();
    std::string h5name(FileName);
    //success |= read_hdf5_scatter(h5name);
#ifdef ENABLE_PHDF5
    success |= read_phdf5(h5name);
#else
    success |= read_hdf5(h5name);
#endif
  }
  return success;
#endif
}

bool HDFWalkerInput_0_4::read_hdf5( std::string h5name)
{

  int nw_in=0;

  h5name.append(hdf::config_ext);
  hdf_archive hin(myComm,false); //everone reads this
  bool success=hin.open(h5name,H5F_ACC_RDONLY);
  //check if hdf and xml versions can work together
  HDFVersion aversion;

  hin.read(aversion,hdf::version);
  if(!(aversion < i_info.version))
  {
    int found_group=hin.is_group(hdf::main_state);
    hin.push(hdf::main_state);
    hin.read(nw_in,hdf::num_walkers);
  }
  else
  {
    app_error() << " Mismatched version. xml = " << i_info.version << " hdf = " << aversion << std::endl;
  }

  if(nw_in==0)
  {
    app_error() << " No walkers in " << h5name << std::endl;
    return false;
  }

  typedef std::vector<QMCTraits::RealType>  Buffer_t;
  Buffer_t posin;
  TinyVector<size_t,3> dims(nw_in,targetW.getTotalNum(),OHMMS_DIM);
  posin.resize(dims[0]*dims[1]*dims[2]);

  hyperslab_proxy<Buffer_t,3> slab(posin,dims);
  hin.read(slab,hdf::walkers);

  std::vector<int> woffsets;
  hin.read(woffsets,"walker_partition");

  int np1=myComm->size()+1;
  std::vector<int> counts(np1);
  if(woffsets.size()!= np1)
  {
    woffsets.resize(myComm->size()+1,0);
    FairDivideLow(nw_in,myComm->size(),woffsets);
  }

  app_log() << " HDFWalkerInput_0_4::put getting " << dims[0] << " walkers " << posin.size() << std::endl;
  nw_in=woffsets[myComm->rank()+1]-woffsets[myComm->rank()];
  {
    int nitems=targetW.getTotalNum()*OHMMS_DIM;
    int curWalker = targetW.getActiveWalkers();
    targetW.createWalkers(nw_in);
    Buffer_t::iterator it(posin.begin()+woffsets[myComm->rank()]*nitems);
    for(int i=0,iw=curWalker; i<nw_in; ++i,++iw)
    {
      copy(it,it+nitems,get_first_address(targetW[iw]->R));
      it += nitems;
    }
  }

  //{
  //  char fname[128];
  //  sprintf(fname,"%s.p%03d.xyz",FileName.c_str(),myComm->rank());
  //  std::ofstream fout(fname);
  //  MCWalkerConfiguration::iterator it = targetW.begin();
  //  int iw=0;
  //  while(it != targetW.end())
  //  {
  //    fout << iw << std::endl;
  //    MCWalkerConfiguration::Walker_t& thisWalker(**it);
  //    for(int iat=0; iat<targetW.getTotalNum(); ++iat)
  //      fout << thisWalker.R[iat] << std::endl;
  //    ++it; ++iw;
  //  }
  //}
  return true;
}

bool HDFWalkerInput_0_4::read_hdf5_scatter( std::string h5name)
{

  int nw_in=0;
  h5name.append(hdf::config_ext);

  if(myComm->rank()==0)
  {
    hdf_archive hin(myComm); //everone reads this
    bool success=hin.open(h5name,H5F_ACC_RDONLY);
    //check if hdf and xml versions can work together
    HDFVersion aversion;

    hin.read(aversion,hdf::version);
    if(!(aversion < i_info.version))
    {
      int found_group=hin.is_group(hdf::main_state);
      hin.push(hdf::main_state);
      hin.read(nw_in,hdf::num_walkers);
    }
    else
    {
      app_error() << " Mismatched version. xml = " << i_info.version << " hdf = " << aversion << std::endl;
    }
  }

  myComm->barrier();
  mpi::bcast(*myComm,nw_in);

  if(nw_in==0)
  {
    app_error() << " No walkers in " << h5name << std::endl;
    return false;
  }

  typedef std::vector<QMCTraits::RealType>  Buffer_t;

  int np1=myComm->size()+1;
  std::vector<int> counts(myComm->size()),woffsets(np1,0);
  FairDivideLow(nw_in,myComm->size(),woffsets);

  int nw_loc=woffsets[myComm->rank()+1]-woffsets[myComm->rank()];

  int nitems=targetW.getTotalNum()*OHMMS_DIM;
  for(int i=0; i<woffsets.size(); ++i) woffsets[i]*=nitems;
  for(int i=0; i<counts.size(); ++i) counts[i]=woffsets[i+1]-woffsets[i];

  TinyVector<size_t,3> dims(nw_in,targetW.getTotalNum(),OHMMS_DIM);
  Buffer_t posin(nw_in*nitems),posout(counts[myComm->rank()]);

  if(myComm->rank()==0)
  {
    hdf_archive hin(myComm); 
    bool success=hin.open(h5name,H5F_ACC_RDONLY);
    hyperslab_proxy<Buffer_t,3> slab(posin,dims);
    hin.push(hdf::main_state);
    hin.read(slab,hdf::walkers);
  }

  mpi::scatterv(*myComm,posin,posout,counts,woffsets);

  int curWalker=targetW.getActiveWalkers();
  targetW.createWalkers(nw_loc);
  Buffer_t::iterator it(posout.begin());
  for(int i=0,iw=curWalker; i<nw_loc;++i,++iw)
  {
    copy(it,it+nitems,get_first_address(targetW[iw]->R));
    it += nitems;
  }
  return true;
}

bool HDFWalkerInput_0_4::read_phdf5( std::string h5name)
{

  int nw_in=0;
  h5name.append(hdf::config_ext);
  std::vector<int> woffsets;
  int woffsets_size;
  bool success;

  { // handle small dataset with master rank
    hdf_archive hin(myComm,false);
    if(!myComm->rank())
    {
      success=hin.open(h5name,H5F_ACC_RDONLY);
      //check if hdf and xml versions can work together
      HDFVersion aversion;

      hin.read(aversion,hdf::version);
      if(!(aversion < i_info.version))
      {
        int found_group=hin.is_group(hdf::main_state);
        hin.push(hdf::main_state);
        hin.read(nw_in,hdf::num_walkers);
        if(nw_in==0)
        {
          app_error() << " No walkers in " << h5name << std::endl;
          success=false;
        }
      }
      else
      {
        app_error() << " Mismatched version. xml = " << i_info.version << " hdf = " << aversion << std::endl;
        success=false;
      }
    }
    mpi::bcast(*myComm,success);
    if(!success) return false;

    // load woffsets by master
    // can not read collectively since the size may differ from Nranks+1.
    if(!myComm->rank())
    {
      hin.read(woffsets,"walker_partition");
      woffsets_size = woffsets.size();
      assert(woffsets[woffsets_size-1] == nw_in);
    }

    mpi::bcast(*myComm,woffsets_size);
    woffsets.resize(woffsets_size);
    mpi::bcast(*myComm,woffsets.data(),woffsets_size);
    nw_in = woffsets[woffsets_size-1];
  }

  hdf_archive hin(myComm,true); //everone reads this
  success=hin.open(h5name,H5F_ACC_RDONLY);
  int found_group=hin.is_group(hdf::main_state);
  hin.push(hdf::main_state);

  typedef std::vector<QMCTraits::RealType>  Buffer_t;
  Buffer_t posin;
  TinyVector<int,3> dims(nw_in,targetW.getTotalNum(), OHMMS_DIM);

  if(woffsets.size()!=myComm->size()+1)
  {
    woffsets.resize(myComm->size()+1,0);
    FairDivideLow(nw_in,myComm->size(),woffsets);
  }

  int nw_loc=woffsets[myComm->rank()+1]-woffsets[myComm->rank()];

  TinyVector<int,3> counts(nw_loc, targetW.getTotalNum(), OHMMS_DIM);
  TinyVector<int,3> offsets(woffsets[myComm->rank()], 0, 0);
  posin.resize(nw_loc*dims[1]*dims[2]);

  hyperslab_proxy<Buffer_t,3> slab(posin, dims, counts, offsets);
  hin.read(slab,hdf::walkers);

  app_log() << " HDFWalkerInput_0_4::put getting " << dims[0] << " walkers " << posin.size() << std::endl;
  nw_in=woffsets[myComm->rank()+1]-woffsets[myComm->rank()];
  {
    int nitems=targetW.getTotalNum()*OHMMS_DIM;
    int curWalker = targetW.getActiveWalkers();
    targetW.createWalkers(nw_in);
    Buffer_t::iterator it(posin.begin());
    for(int i=0,iw=curWalker; i<nw_in; ++i,++iw)
    {
      copy(it,it+nitems,get_first_address(targetW[iw]->R));
      it += nitems;
    }
  }
  return true;
}
bool HDFWalkerInput_0_4::read_adios(xmlNodePtr cur)
{
  //this is too messy. cleanup or use read_hdf5 
#ifdef HAVE_ADIOS
  checkOptions(cur);
  if(FileStack.empty())
  {
    app_error() << "  No valid input hdf5 is found." << std::endl;
    return false;
  }
  //use collective I/O  for parallel runs with a file
  //i_info.parallel = ((myComm->size()>1) && i_info.collected);
  while(FileStack.size())
  {
    FileName=FileStack.top();
    FileStack.pop();
    std::string h5name(FileName);
    int success = 0;
    hdf_archive hin(myComm,true);
    if(ADIOS::getRdADIOS())
    {
      h5name.append(".config.bp");
      success=ADIOS::open(h5name, myComm->getMPI());
    }
    else if(ADIOS::getRdHDF5())
    { 
      h5name.append(hdf::config_ext);
      success=hin.open(h5name,H5F_ACC_RDONLY);
    }
    mpi::bcast(*myComm,success);
    if(!success)
    {
      app_error() << "  HDFWalkerInput_0_4::put Cannot open " << h5name << std::endl;
      continue;
    }
    //check if hdf and xml versions can work together
    HDFVersion aversion;
    typedef std::vector<QMCTraits::RealType>  Buffer_t;
    Buffer_t posin;
    if(ADIOS::getRdHDF5())
    {
      hin.read(aversion,hdf::version);
      mpi::bcast(*myComm,aversion.version);
      if(aversion < i_info.version)
      {
        app_error() << " Mismatched version. xml = " << i_info.version << " hdf = " << aversion << std::endl;
        continue;
      }
      int found_group=hin.is_group(hdf::main_state);
      mpi::bcast(*myComm,found_group);
      if(!found_group)
        continue;
      hin.push(hdf::main_state);
    }
    int nw_in=0;
    if(ADIOS::getRdADIOS())
    {
      int * data;
      int index;
      ADIOS::read_scalar(data, "walker_num", index);
      for(int i=0; i<index; i++)
      {
        nw_in += data[i];
      }
      free(data);
    }
    else if(ADIOS::getRdHDF5())
    {
      hin.read(nw_in,hdf::num_walkers);
      mpi::bcast(*myComm,nw_in);
    }
    if(nw_in==0)
    {
      app_error() << "  HDFWalkerInput_0_4::put empty walkers " << std::endl;
      continue;
    }
    TinyVector<size_t,3> dims(nw_in,targetW.getTotalNum(),OHMMS_DIM);
    if(!myComm->rank())
    {
      posin.resize(dims[0]*dims[1]*dims[2]);
      if(ADIOS::getRdADIOS())
      {
        ADIOS::read_walkers(posin, "walkers");
      } 
      else if(ADIOS::getRdHDF5())
      {
        hyperslab_proxy<Buffer_t,3> slab(posin,dims);
        hin.read(slab,hdf::walkers);
      }
    }
    if(ADIOS::getRdADIOS())
    {
      ADIOS::close();
    }
    app_log() << " HDFWalkerInput_0_4::put getting " << dims[0] << " walkers " << posin.size() << std::endl;
    int nitems=targetW.getTotalNum()*OHMMS_DIM;
    int curWalker = targetW.getActiveWalkers();
    if(myComm->size()==1)
    {
      targetW.createWalkers(nw_in);
      Buffer_t::iterator it(posin.begin());
      for(int i=0,iw=curWalker; i<nw_in; ++i,++iw)
      {
        copy(it,it+nitems,get_first_address(targetW[iw]->R));
        it += nitems;
      }
    }
    else
    {
      std::vector<int> counts(myComm->size()),woffsets(myComm->size()+1,0);
      FairDivideLow(nw_in,myComm->size(),woffsets);
      //reset the number of walkers
      nw_in=woffsets[myComm->rank()+1]-woffsets[myComm->rank()];
      for(int i=0; i<woffsets.size(); ++i)
        woffsets[i]*=nitems;
      for(int i=0; i<counts.size(); ++i)
        counts[i]=woffsets[i+1]-woffsets[i];
      Buffer_t posout(nw_in*nitems);
      mpi::scatterv(*myComm,posin,posout,counts,woffsets);
      targetW.createWalkers(nw_in);
      Buffer_t::iterator it(posout.begin());
      for(int i=0,iw=curWalker; i<nw_in; ++i,++iw)
      {
        copy(it,it+nitems,get_first_address(targetW[iw]->R));
        it += nitems;
      }
    }
  }
#endif
  return true;
}

}
