//////////////////////////////////////////////////////////////////////////////////////
// This file is distributed under the University of Illinois/NCSA Open Source License.
// See LICENSE file in top directory for details.
//
// Copyright (c) 2016 Jeongnim Kim and QMCPACK developers.
//
// File developed by: Ken Esler, kpesler@gmail.com, University of Illinois at Urbana-Champaign
//                    Miguel Morales, moralessilva2@llnl.gov, Lawrence Livermore National Laboratory
//                    Jeremy McMinnis, jmcminis@gmail.com, University of Illinois at Urbana-Champaign
//                    Jeongnim Kim, jeongnim.kim@gmail.com, University of Illinois at Urbana-Champaign
//                    Mark A. Berrill, berrillma@ornl.gov, Oak Ridge National Laboratory
//
// File created by: Ken Esler, kpesler@gmail.com, University of Illinois at Urbana-Champaign
//////////////////////////////////////////////////////////////////////////////////////


#include "QMCDrivers/QMCLinearOptimize.h"
#include "Particle/HDFWalkerIO.h"
#include "OhmmsData/AttributeSet.h"
#include "Message/CommOperators.h"
//#if defined(ENABLE_OPENMP)
#include "QMCDrivers/VMC/VMC.h"
#include "QMCDrivers/QMCCostFunction.h"
//#endif
//#include "QMCDrivers/VMC/VMCSingle.h"
//#include "QMCDrivers/QMCCostFunctionSingle.h"
#include "QMCApp/HamiltonianPool.h"
#include "Numerics/Blasf.h"
#include "Numerics/MatrixOperators.h"
#include <cassert>
#if defined(QMC_CUDA)
#include "QMCDrivers/VMC/VMC_CUDA.h"
#include "QMCDrivers/QMCCostFunctionCUDA.h"
#endif
#include "Numerics/LinearFit.h"
#include <iostream>
#include <fstream>

/*#include "Message/Communicate.h"*/

namespace qmcplusplus
{
QMCLinearOptimize::QMCLinearOptimize(MCWalkerConfiguration& w,
                                     TrialWaveFunction& psi,
                                     QMCHamiltonian& h,
                                     HamiltonianPool& hpool,
                                     WaveFunctionPool& ppool,
                                     Communicate* comm)
    : QMCDriver(w, psi, h, ppool, comm),
      PartID(0),
      NumParts(1),
      WarmupBlocks(10),
      hamPool(hpool),
      optTarget(0),
      vmcEngine(0),
      wfNode(NULL),
      optNode(NULL),
      param_tol(1e-4)
{
  IsQMCDriver = false;
  //     //set the optimization flag
  qmc_driver_mode.set(QMC_OPTIMIZE, 1);
  //read to use vmc output (just in case)
  m_param.add(param_tol, "alloweddifference", "double");
  //Set parameters for line minimization:
  this->add_timers(myTimers);
}

/** Clean up the vector */
QMCLinearOptimize::~QMCLinearOptimize()
{
  delete vmcEngine;
  delete optTarget;
}

void QMCLinearOptimize::add_timers(std::vector<NewTimer*>& timers)
{
  timers.push_back(new NewTimer("QMCLinearOptimize::GenerateSamples"));
  timers.push_back(new NewTimer("QMCLinearOptimize::Initialize"));
  timers.push_back(new NewTimer("QMCLinearOptimize::Eigenvalue"));
  timers.push_back(new NewTimer("QMCLinearOptimize::Line_Minimization"));
  timers.push_back(new NewTimer("QMCLinearOptimize::CostFunction"));
  for (int i = 0; i < timers.size(); ++i)
    TimerManager.addTimer(timers[i]);
}

/** Add configuration files for the optimization
* @param a root of a hdf5 configuration file
*/
void QMCLinearOptimize::addConfiguration(const std::string& a)
{
  if (a.size())
    ConfigFile.push_back(a);
}

void QMCLinearOptimize::start()
{
  //close files automatically generated by QMCDriver
  //     branchEngine->finalize();
  //generate samples
  myTimers[0]->start();
  generateSamples();
  myTimers[0]->stop();
  //store active number of walkers
  NumOfVMCWalkers = W.getActiveWalkers();
  app_log() << "<opt stage=\"setup\">" << std::endl;
  app_log() << "  <log>" << std::endl;
  //reset the rootname
  optTarget->setRootName(RootName);
  optTarget->setWaveFunctionNode(wfNode);
  app_log() << "   Reading configurations from h5FileRoot " << h5FileRoot << std::endl;
  //get configuration from the previous run
  Timer t1;
  myTimers[1]->start();
  optTarget->getConfigurations(h5FileRoot);
  optTarget->setRng(vmcEngine->getRng());
  optTarget->checkConfigurations();
  myTimers[1]->stop();
  app_log() << "  Execution time = " << std::setprecision(4) << t1.elapsed() << std::endl;
  app_log() << "  </log>" << std::endl;
  app_log() << "</opt>" << std::endl;
  app_log() << "<opt stage=\"main\" walkers=\"" << optTarget->getNumSamples() << "\">" << std::endl;
  app_log() << "  <log>" << std::endl;
  t1.restart();
}

#ifdef HAVE_LMY_ENGINE
void QMCLinearOptimize::engine_start(cqmc::engine::LMYEngine* EngineObj)
{
  app_log() << "entering engine_start function" << std::endl;

  // generate samples
  myTimers[0]->start();
  generateSamples();
  myTimers[0]->stop();

  // store active number of walkers
  NumOfVMCWalkers = W.getActiveWalkers();
  app_log() << "<opt stage=\"setup\">" << std::endl;
  app_log() << "  <log>" << std::endl;

  // reset the root name
  optTarget->setRootName(RootName);
  optTarget->setWaveFunctionNode(wfNode);
  app_log() << "     Reading configurations from h5FileRoot " << h5FileRoot << std::endl;

  // get configuration from the previous run
  Timer t1;
  myTimers[1]->start();
  optTarget->getConfigurations(h5FileRoot);
  optTarget->setRng(vmcEngine->getRng());
  optTarget->engine_checkConfigurations(EngineObj); // computes derivative ratios and pass into engine
  myTimers[1]->stop();
  app_log() << "  Execution time = " << std::setprecision(4) << t1.elapsed() << std::endl;
  app_log() << "  </log>" << std::endl;
  app_log() << "</opt>" << std::endl;
  app_log() << "<opt stage=\"main\" walkers=\"" << optTarget->getNumSamples() << "\">" << std::endl;
  app_log() << "  <log>" << std::endl;
  t1.restart();
}
#endif

void QMCLinearOptimize::finish()
{
  MyCounter++;
  app_log() << "  Execution time = " << std::setprecision(4) << t1.elapsed() << std::endl;
  app_log() << "  </log>" << std::endl;

  if (optTarget->reportH5)
    optTarget->reportParametersH5();
  optTarget->reportParameters();


  int nw_removed = W.getActiveWalkers() - NumOfVMCWalkers;
  app_log() << "   Restore the number of walkers to " << NumOfVMCWalkers << ", removing " << nw_removed << " walkers."
            << std::endl;
  if (nw_removed > 0)
    W.destroyWalkers(nw_removed);
  else
    W.createWalkers(-nw_removed);
  app_log() << "</opt>" << std::endl;
  app_log() << "</optimization-report>" << std::endl;
}

void QMCLinearOptimize::generateSamples()
{
  app_log() << "<optimization-report>" << std::endl;
  //if(WarmupBlocks)
  //{
  //  app_log() << "<vmc stage=\"warm-up\" blocks=\"" << WarmupBlocks << "\">" << std::endl;
  //  //turn off QMC_OPTIMIZE
  //  vmcEngine->setValue("blocks",WarmupBlocks);
  vmcEngine->qmc_driver_mode.set(QMC_WARMUP, 1);
  //  vmcEngine->run();
  //  vmcEngine->setValue("blocks",nBlocks);
  //  app_log() << "  Execution time = " << std::setprecision(4) << t1.elapsed() << std::endl;
  //  app_log() << "</vmc>" << std::endl;
  //}
  //     if (W.getActiveWalkers()>NumOfVMCWalkers)
  //     {
  //         W.destroyWalkers(W.getActiveWalkers()-NumOfVMCWalkers);
  //         app_log() << "  QMCLinearOptimize::generateSamples removed walkers." << std::endl;
  //         app_log() << "  Number of Walkers per node " << W.getActiveWalkers() << std::endl;
  //     }
  vmcEngine->qmc_driver_mode.set(QMC_OPTIMIZE, 1);
  vmcEngine->qmc_driver_mode.set(QMC_WARMUP, 0);
  //vmcEngine->setValue("recordWalkers",1);//set record
  vmcEngine->setValue("current", 0); //reset CurrentStep
  app_log() << "<vmc stage=\"main\" blocks=\"" << nBlocks << "\">" << std::endl;
  t1.restart();
  //     W.reset();
  branchEngine->flush(0);
  branchEngine->reset();
  vmcEngine->run();
  app_log() << "  Execution time = " << std::setprecision(4) << t1.elapsed() << std::endl;
  app_log() << "</vmc>" << std::endl;
  //write parameter history and energies to the parameter file in the trial wave function through opttarget
  FullPrecRealType e, w, var;
  vmcEngine->Estimators->getEnergyAndWeight(e, w, var);
  //     NumOfVMCWalkers=W.getActiveWalkers();
  //branchEngine->Eref=vmcEngine->getBranchEngine()->Eref;
  //         branchEngine->setTrialEnergy(vmcEngine->getBranchEngine()->getEref());
  //set the h5File to the current RootName
  h5FileRoot = RootName;
}

QMCLinearOptimize::RealType QMCLinearOptimize::getLowestEigenvector(Matrix<RealType>& A,
                                                                    Matrix<RealType>& B,
                                                                    std::vector<RealType>& ev)
{
  int Nl(ev.size());
  //Tested the single eigenvalue speed and It was no faster.
  //segfault issues with single eigenvalue problem for some machines
  //  bool singleEV(false);
  //  if (singleEV)
  //  {
  /*
    Matrix<double> TAU(Nl,Nl);
    int INFO;
    int LWORK(-1);
    std::vector<RealType> WORK(1);
    //optimal work size
    dgeqrf( &Nl, &Nl, B.data(), &Nl, TAU.data(), &WORK[0], &LWORK, &INFO);
    LWORK=int(WORK[0]);
    WORK.resize(LWORK);
    //QR factorization of S, or H2 matrix. to be applied to H before solve.
    dgeqrf( &Nl, &Nl, B.data(), &Nl, TAU.data(), &WORK[0], &LWORK, &INFO);
    char SIDE('L');
    char TRANS('T');
    LWORK=-1;
    //optimal work size
    dormqr(&SIDE, &TRANS, &Nl, &Nl, &Nl, B.data(), &Nl, TAU.data(), A.data(), &Nl, &WORK[0], &LWORK, &INFO);
    LWORK=int(WORK[0]);
    WORK.resize(LWORK);
    //Apply Q^T to H
    dormqr(&SIDE, &TRANS, &Nl, &Nl, &Nl, B.data(), &Nl, TAU.data(), A.data(), &Nl, &WORK[0], &LWORK, &INFO);
    //now we have a pair (A,B)=(Q^T*H,Q^T*S) where B is upper triangular and A is general matrix.
    //reduce the matrix pair to generalized upper Hesenberg form
    char COMPQ('N'), COMPZ('I');
    int ILO(1);
    int LDQ(Nl);
    Matrix<double> Z(Nl,Nl), Q(Nl,LDQ); //starts as unit matrix
    for (int zi=0; zi<Nl; zi++)
      Z(zi,zi)=1;
    dgghrd(&COMPQ, &COMPZ, &Nl, &ILO, &Nl, A.data(), &Nl, B.data(), &Nl, Q.data(), &LDQ, Z.data(), &Nl, &INFO);
    //Take the pair and reduce to shur form and get eigenvalues
    std::vector<RealType> alphar(Nl),alphai(Nl),beta(Nl);
    char JOB('S');
    COMPQ='N';
    COMPZ='V';
    LWORK=-1;
    //get optimal work size
    dhgeqz(&JOB, &COMPQ, &COMPZ, &Nl, &ILO, &Nl, A.data(), &Nl, B.data(), &Nl, &alphar[0], &alphai[0], &beta[0], Q.data(), &LDQ, Z.data(), &Nl, &WORK[0], &LWORK, &INFO);
    LWORK=int(WORK[0]);
    WORK.resize(LWORK);
    dhgeqz(&JOB, &COMPQ, &COMPZ, &Nl, &ILO, &Nl, A.data(), &Nl, B.data(), &Nl, &alphar[0], &alphai[0], &beta[0], Q.data(), &LDQ, Z.data(), &Nl, &WORK[0], &LWORK, &INFO);
    //find the best eigenvalue
    std::vector<std::pair<RealType,int> > mappedEigenvalues(Nl);
    for (int i=0; i<Nl; i++)
    {
      RealType evi(alphar[i]/beta[i]);
      if (std::abs(evi)<1e10)
      {
        mappedEigenvalues[i].first=evi;
        mappedEigenvalues[i].second=i;
      }
      else
      {
        mappedEigenvalues[i].first=1e100;
        mappedEigenvalues[i].second=i;
      }
    }
    std::sort(mappedEigenvalues.begin(),mappedEigenvalues.end());
    int BestEV(mappedEigenvalues[0].second);
//                   now we rearrange the  the matrices
    if (BestEV!=0)
    {
      bool WANTQ(false);
      bool WANTZ(true);
      int ILST(1);
      int IFST(BestEV+1);
      LWORK=-1;
      dtgexc(&WANTQ, &WANTZ, &Nl, A.data(), &Nl, B.data(), &Nl, Q.data(), &Nl, Z.data(), &Nl, &IFST, &ILST, &WORK[0], &LWORK, &INFO);
      LWORK=int(WORK[0]);
      WORK.resize(LWORK);
      dtgexc(&WANTQ, &WANTZ, &Nl, A.data(), &Nl, B.data(), &Nl, Q.data(), &Nl, Z.data(), &Nl, &IFST, &ILST, &WORK[0], &LWORK, &INFO);
    }
    //now we compute the eigenvector
    SIDE='R';
    char HOWMNY('S');
    int M(0);
    Matrix<double> Z_I(Nl,Nl);
    bool SELECT[Nl];
    for (int zi=0; zi<Nl; zi++)
      SELECT[zi]=false;
    SELECT[0]=true;
    WORK.resize(6*Nl);
    dtgevc(&SIDE, &HOWMNY, &SELECT[0], &Nl, A.data(), &Nl, B.data(), &Nl, Q.data(), &LDQ, Z_I.data(), &Nl, &Nl, &M, &WORK[0], &INFO);
    std::vector<RealType> evec(Nl,0);
    for (int i=0; i<Nl; i++)
      for (int j=0; j<Nl; j++)
        evec[i] += Z(j,i)*Z_I(0,j);
    for (int i=0; i<Nl; i++)
      ev[i] = evec[i]/evec[0];
//     for (int i=0; i<Nl; i++) app_log()<<ev[i]<<" ";
//     app_log()<< std::endl;
    return mappedEigenvalues[0].first;
    */
  // a fake return to reduce warning.
  //    return RealType(0.0);
  //  }
  //  else
  //  {
  // OLD ROUTINE. CALCULATES ALL EIGENVECTORS
  //   Getting the optimal worksize
  char jl('N');
  char jr('V');
  std::vector<RealType> alphar(Nl), alphai(Nl), beta(Nl);
  Matrix<RealType> eigenT(Nl, Nl);
  int info;
  int lwork(-1);
  std::vector<RealType> work(1);
  RealType tt(0);
  int t(1);
  LAPACK::ggev(&jl, &jr, &Nl, A.data(), &Nl, B.data(), &Nl, &alphar[0], &alphai[0], &beta[0], &tt, &t, eigenT.data(),
               &Nl, &work[0], &lwork, &info);
  lwork = int(work[0]);
  work.resize(lwork);
  //~ //Get an estimate of E_lin
  //~ Matrix<RealType> H_tmp(HamT);
  //~ Matrix<RealType> S_tmp(ST);
  //~ dggev(&jl, &jr, &Nl, H_tmp.data(), &Nl, S_tmp.data(), &Nl, &alphar[0], &alphai[0], &beta[0],&tt,&t, eigenT.data(), &Nl, &work[0], &lwork, &info);
  //~ RealType E_lin(alphar[0]/beta[0]);
  //~ int e_min_indx(0);
  //~ for (int i=1; i<Nl; i++)
  //~ if (E_lin>(alphar[i]/beta[i]))
  //~ {
  //~ E_lin=alphar[i]/beta[i];
  //~ e_min_indx=i;
  //~ }
  LAPACK::ggev(&jl, &jr, &Nl, A.data(), &Nl, B.data(), &Nl, &alphar[0], &alphai[0], &beta[0], &tt, &t, eigenT.data(),
               &Nl, &work[0], &lwork, &info);
  if (info != 0)
  {
    APP_ABORT("Invalid Matrix Diagonalization Function!");
  }
  std::vector<std::pair<RealType, int>> mappedEigenvalues(Nl);
  for (int i = 0; i < Nl; i++)
  {
    RealType evi(alphar[i] / beta[i]);
    if (std::abs(evi) < 1e10)
    {
      mappedEigenvalues[i].first  = evi;
      mappedEigenvalues[i].second = i;
    }
    else
    {
      mappedEigenvalues[i].first  = std::numeric_limits<RealType>::max();
      mappedEigenvalues[i].second = i;
    }
  }
  std::sort(mappedEigenvalues.begin(), mappedEigenvalues.end());
  for (int i = 0; i < Nl; i++)
    ev[i] = eigenT(mappedEigenvalues[0].second, i) / eigenT(mappedEigenvalues[0].second, 0);
  return mappedEigenvalues[0].first;
  //  }
}


QMCLinearOptimize::RealType QMCLinearOptimize::getLowestEigenvector(Matrix<RealType>& A, std::vector<RealType>& ev)
{
  int Nl(ev.size());
  //Tested the single eigenvalue speed and It was no faster.
  //segfault issues with single eigenvalue problem for some machines
  //  bool singleEV(false);
  //     if (singleEV)
  //     {
  //         Matrix<double> TAU(Nl,Nl);
  //         int INFO;
  //         int LWORK(-1);
  //         std::vector<RealType> WORK(1);
  //         //optimal work size
  //         dgeqrf( &Nl, &Nl, B.data(), &Nl, TAU.data(), &WORK[0], &LWORK, &INFO);
  //         LWORK=int(WORK[0]);
  //         WORK.resize(LWORK);
  //         //QR factorization of S, or H2 matrix. to be applied to H before solve.
  //         dgeqrf( &Nl, &Nl, B.data(), &Nl, TAU.data(), &WORK[0], &LWORK, &INFO);
  //
  //         char SIDE('L');
  //         char TRANS('T');
  //         LWORK=-1;
  //         //optimal work size
  //         dormqr(&SIDE, &TRANS, &Nl, &Nl, &Nl, B.data(), &Nl, TAU.data(), A.data(), &Nl, &WORK[0], &LWORK, &INFO);
  //         LWORK=int(WORK[0]);
  //         WORK.resize(LWORK);
  //         //Apply Q^T to H
  //         dormqr(&SIDE, &TRANS, &Nl, &Nl, &Nl, B.data(), &Nl, TAU.data(), A.data(), &Nl, &WORK[0], &LWORK, &INFO);
  //
  //         //now we have a pair (A,B)=(Q^T*H,Q^T*S) where B is upper triangular and A is general matrix.
  //         //reduce the matrix pair to generalized upper Hesenberg form
  //         char COMPQ('N'), COMPZ('I');
  //         int ILO(1);
  //         int LDQ(Nl);
  //         Matrix<double> Z(Nl,Nl), Q(Nl,LDQ); //starts as unit matrix
  //         for (int zi=0; zi<Nl; zi++) Z(zi,zi)=1;
  //         dgghrd(&COMPQ, &COMPZ, &Nl, &ILO, &Nl, A.data(), &Nl, B.data(), &Nl, Q.data(), &LDQ, Z.data(), &Nl, &INFO);
  //
  //         //Take the pair and reduce to shur form and get eigenvalues
  //         std::vector<RealType> alphar(Nl),alphai(Nl),beta(Nl);
  //         char JOB('S');
  //         COMPQ='N';
  //         COMPZ='V';
  //         LWORK=-1;
  //         //get optimal work size
  //         dhgeqz(&JOB, &COMPQ, &COMPZ, &Nl, &ILO, &Nl, A.data(), &Nl, B.data(), &Nl, &alphar[0], &alphai[0], &beta[0], Q.data(), &LDQ, Z.data(), &Nl, &WORK[0], &LWORK, &INFO);
  //         LWORK=int(WORK[0]);
  //         WORK.resize(LWORK);
  //         dhgeqz(&JOB, &COMPQ, &COMPZ, &Nl, &ILO, &Nl, A.data(), &Nl, B.data(), &Nl, &alphar[0], &alphai[0], &beta[0], Q.data(), &LDQ, Z.data(), &Nl, &WORK[0], &LWORK, &INFO);
  //         //find the best eigenvalue
  //         std::vector<std::pair<RealType,int> > mappedEigenvalues(Nl);
  //         for (int i=0; i<Nl; i++)
  //         {
  //             RealType evi(alphar[i]/beta[i]);
  //             if (std::abs(evi)<1e10)
  //             {
  //                 mappedEigenvalues[i].first=evi;
  //                 mappedEigenvalues[i].second=i;
  //             }
  //             else
  //             {
  //                 mappedEigenvalues[i].first=1e100;
  //                 mappedEigenvalues[i].second=i;
  //             }
  //         }
  //         std::sort(mappedEigenvalues.begin(),mappedEigenvalues.end());
  //         int BestEV(mappedEigenvalues[0].second);
  //
  // //                   now we rearrange the  the matrices
  //         if (BestEV!=0)
  //         {
  //             bool WANTQ(false);
  //             bool WANTZ(true);
  //             int ILST(1);
  //             int IFST(BestEV+1);
  //             LWORK=-1;
  //
  //             dtgexc(&WANTQ, &WANTZ, &Nl, A.data(), &Nl, B.data(), &Nl, Q.data(), &Nl, Z.data(), &Nl, &IFST, &ILST, &WORK[0], &LWORK, &INFO);
  //             LWORK=int(WORK[0]);
  //             WORK.resize(LWORK);
  //             dtgexc(&WANTQ, &WANTZ, &Nl, A.data(), &Nl, B.data(), &Nl, Q.data(), &Nl, Z.data(), &Nl, &IFST, &ILST, &WORK[0], &LWORK, &INFO);
  //         }
  //         //now we compute the eigenvector
  //         SIDE='R';
  //         char HOWMNY('S');
  //         int M(0);
  //         Matrix<double> Z_I(Nl,Nl);
  //         bool SELECT[Nl];
  //         for (int zi=0; zi<Nl; zi++) SELECT[zi]=false;
  //         SELECT[0]=true;
  //
  //         WORK.resize(6*Nl);
  //         dtgevc(&SIDE, &HOWMNY, &SELECT[0], &Nl, A.data(), &Nl, B.data(), &Nl, Q.data(), &LDQ, Z_I.data(), &Nl, &Nl, &M, &WORK[0], &INFO);
  //
  //         std::vector<RealType> evec(Nl,0);
  //         for (int i=0; i<Nl; i++) for (int j=0; j<Nl; j++) evec[i] += Z(j,i)*Z_I(0,j);
  //         for (int i=0; i<Nl; i++) ev[i] = evec[i]/evec[0];
  // //     for (int i=0; i<Nl; i++) app_log()<<ev[i]<<" ";
  // //     app_log()<< std::endl;
  //         return mappedEigenvalues[0].first;
  //     }
  //     else
  //     {
  // // OLD ROUTINE. CALCULATES ALL EIGENVECTORS
  // //   Getting the optimal worksize
  RealType zerozero = A(0, 0);
  char jl('N');
  char jr('V');
  std::vector<RealType> alphar(Nl), alphai(Nl), beta(Nl);
  Matrix<RealType> eigenT(Nl, Nl);
  Matrix<RealType> eigenD(Nl, Nl);
  int info;
  int lwork(-1);
  std::vector<RealType> work(1);
  LAPACK::geev(&jl, &jr, &Nl, A.data(), &Nl, &alphar[0], &alphai[0], eigenD.data(), &Nl, eigenT.data(), &Nl, &work[0],
               &lwork, &info);
  lwork = int(work[0]);
  work.resize(lwork);
  //~ //Get an estimate of E_lin
  //~ Matrix<RealType> H_tmp(HamT);
  //~ Matrix<RealType> S_tmp(ST);
  //~ dggev(&jl, &jr, &Nl, H_tmp.data(), &Nl, S_tmp.data(), &Nl, &alphar[0], &alphai[0], &beta[0],&tt,&t, eigenT.data(), &Nl, &work[0], &lwork, &info);
  //~ RealType E_lin(alphar[0]/beta[0]);
  //~ int e_min_indx(0);
  //~ for (int i=1; i<Nl; i++)
  //~ if (E_lin>(alphar[i]/beta[i]))
  //~ {
  //~ E_lin=alphar[i]/beta[i];
  //~ e_min_indx=i;
  //~ }
  LAPACK::geev(&jl, &jr, &Nl, A.data(), &Nl, &alphar[0], &alphai[0], eigenD.data(), &Nl, eigenT.data(), &Nl, &work[0],
               &lwork, &info);
  if (info != 0)
  {
    APP_ABORT("Invalid Matrix Diagonalization Function!");
  }
  std::vector<std::pair<RealType, int>> mappedEigenvalues(Nl);
  for (int i = 0; i < Nl; i++)
  {
    RealType evi(alphar[i]);
    if ((evi < zerozero) && (evi > (zerozero - 1e2)))
    {
      mappedEigenvalues[i].first  = (evi - zerozero + 2.0) * (evi - zerozero + 2.0);
      mappedEigenvalues[i].second = i;
    }
    else
    {
      mappedEigenvalues[i].first  = std::numeric_limits<RealType>::max();
      mappedEigenvalues[i].second = i;
    }
  }
  std::sort(mappedEigenvalues.begin(), mappedEigenvalues.end());
  //         for (int i=0; i<4; i++) app_log()<<i<<": "<<alphar[mappedEigenvalues[i].second]<< std::endl;
  for (int i = 0; i < Nl; i++)
    ev[i] = eigenT(mappedEigenvalues[0].second, i) / eigenT(mappedEigenvalues[0].second, 0);
  return alphar[mappedEigenvalues[0].second];
  //     }
}
bool QMCLinearOptimize::nonLinearRescale(std::vector<RealType>& dP, Matrix<RealType>& S)
{
  RealType rescale = getNonLinearRescale(dP, S);
  for (int i = 1; i < dP.size(); i++)
    dP[i] *= rescale;
  return true;
}


void QMCLinearOptimize::getNonLinearRange(int& first, int& last)
{
  std::vector<int> types;
  optTarget->getParameterTypes(types);
  first = 0;
  last  = types.size();
  //assume all non-linear coeffs are together.
  if (types[0] == optimize::LINEAR_P)
  {
    int i(0);
    while (i < types.size())
    {
      if (types[i] == optimize::LINEAR_P)
        first = i;
      i++;
    }
    first++;
  }
  else
  {
    int i(types.size() - 1);
    while (i >= 0)
    {
      if (types[i] == optimize::LINEAR_P)
        last = i;
      i--;
    }
  }
  //     returns the number of non-linear parameters.
  //    app_log()<<"line params: "<<first<<" "<<last<< std::endl;
}

QMCLinearOptimize::RealType QMCLinearOptimize::getNonLinearRescale(std::vector<RealType>& dP, Matrix<RealType>& S)
{
  int first(0), last(0);
  getNonLinearRange(first, last);
  if (first == last)
    return 1.0;
  RealType rescale(1.0);
  RealType xi(0.5);
  RealType D(0.0);
  for (int i = first; i < last; i++)
    for (int j = first; j < last; j++)
      D += S(i + 1, j + 1) * dP[i + 1] * dP[j + 1];
  rescale = (1 - xi) * D / ((1 - xi) + xi * std::sqrt(1 + D));
  rescale = 1.0 / (1.0 - rescale);
  //     app_log()<<"rescale: "<<rescale<< std::endl;
  return rescale;
}

void QMCLinearOptimize::orthoScale(std::vector<RealType>& dP, Matrix<RealType>& S)
{
  //     int first(0),last(0);
  //     getNonLinearRange(first,last);
  //     if (first==last) return;
  int x(dP.size());
  Matrix<RealType> T(S);
  std::vector<RealType> nP(dP);
  Matrix<RealType> lS(x, x);
  for (int i = 0; i < x; i++)
    for (int j = 0; j < x; j++)
      lS(i, j) = S(i + 1, j + 1);
  RealType Det = invert_matrix(lS, true);
  for (int i = 0; i < x; i++)
  {
    dP[i] = 0;
    for (int j = 0; j < x; j++)
    {
      dP[i] += nP[j] * lS(i, j);
    }
  }
  RealType rs = getNonLinearRescale(dP, T);
  for (int i = 0; i < x; i++)
    dP[i] *= rs;
  for (int i = 0; i < dP.size(); i++)
    app_log() << dP[i] << " ";
  app_log() << std::endl;
  //     RealType D(0.0);
  //     for (int i=first; i<last; i++) D += 2.0*S(i+1,0)*dP[i];
  //     for (int i=first; i<last; i++) for (int j=first; j<last; j++) D += S(i+1,j+1)*dP[i]*dP[j];
  //     app_log()<<D<< std::endl;
  //
  //
  //     RealType rescale = 0.5*D/(0.5 + 0.5*std::sqrt(1.0+D));
  //     rescale = 1.0/(1.0-rescale);
  //     app_log()<<rescale<< std::endl;
  //     for (int i=0; i<dP.size(); i++) dP[i] *= rescale;
}

QMCLinearOptimize::RealType QMCLinearOptimize::getSplitEigenvectors(int first,
                                                                    int last,
                                                                    Matrix<RealType>& FullLeft,
                                                                    Matrix<RealType>& FullRight,
                                                                    std::vector<RealType>& FullEV,
                                                                    std::vector<RealType>& LocalEV,
                                                                    std::string CSF_Option,
                                                                    bool& CSF_scaled)
{
  std::vector<RealType> GEVSplitDirection(N, 0);
  RealType returnValue;
  int N_nonlin = last - first;
  int N_lin    = N - N_nonlin - 1;
  //  matrices are one larger than parameter sets
  int M_nonlin = N_nonlin + 1;
  int M_lin    = N_lin + 1;
  //  index mapping for the matrices
  int J_begin(first + 1), J_end(last + 1);
  int CSF_begin(1), CSF_end(first + 1);
  if (first == 0)
  {
    CSF_begin = last + 1;
    CSF_end   = N;
  }
  //the Mini matrix composed of just the Nonlinear terms
  Matrix<RealType> LeftTJ(M_nonlin, M_nonlin), RightTJ(M_nonlin, M_nonlin);
  //                     assume all jastrow parameters are together either first or last
  LeftTJ(0, 0)  = FullLeft(0, 0);
  RightTJ(0, 0) = FullRight(0, 0);
  for (int i = J_begin; i < J_end; i++)
  {
    LeftTJ(i - J_begin + 1, 0)  = FullLeft(i, 0);
    RightTJ(i - J_begin + 1, 0) = FullRight(i, 0);
    LeftTJ(0, i - J_begin + 1)  = FullLeft(0, i);
    RightTJ(0, i - J_begin + 1) = FullRight(0, i);
    for (int j = J_begin; j < J_end; j++)
    {
      LeftTJ(i - J_begin + 1, j - J_begin + 1)  = FullLeft(i, j);
      RightTJ(i - J_begin + 1, j - J_begin + 1) = FullRight(i, j);
    }
  }
  std::vector<RealType> J_parms(M_nonlin);
  myTimers[2]->start();
  RealType lowest_J_EV = getLowestEigenvector(LeftTJ, RightTJ, J_parms);
  myTimers[2]->stop();
  //the Mini matrix composed of just the Linear terms
  Matrix<RealType> LeftTCSF(M_lin, M_lin), RightTCSF(M_lin, M_lin);
  LeftTCSF(0, 0)  = FullLeft(0, 0);
  RightTCSF(0, 0) = FullRight(0, 0);
  for (int i = CSF_begin; i < CSF_end; i++)
  {
    LeftTCSF(i - CSF_begin + 1, 0)  = FullLeft(i, 0);
    RightTCSF(i - CSF_begin + 1, 0) = FullRight(i, 0);
    LeftTCSF(0, i - CSF_begin + 1)  = FullLeft(0, i);
    RightTCSF(0, i - CSF_begin + 1) = FullRight(0, i);
    for (int j = CSF_begin; j < CSF_end; j++)
    {
      LeftTCSF(i - CSF_begin + 1, j - CSF_begin + 1)  = FullLeft(i, j);
      RightTCSF(i - CSF_begin + 1, j - CSF_begin + 1) = FullRight(i, j);
    }
  }
  std::vector<RealType> CSF_parms(M_lin);
  myTimers[2]->start();
  RealType lowest_CSF_EV = getLowestEigenvector(LeftTCSF, RightTCSF, CSF_parms);
  myTimers[2]->stop();
  // //                   Now we have both eigenvalues and eigenvectors
  //                   app_log()<<" Jastrow eigenvalue: "<<lowest_J_EV<< std::endl;
  //                   app_log()<<"     CSF eigenvalue: "<<lowest_CSF_EV<< std::endl;
  //                We can rescale the matrix and re-solve the whole thing or take the CSF parameters
  //                  as solved in the matrix and opt the Jastrow instead
  if (CSF_Option == "freeze")
  {
    returnValue = std::min(lowest_J_EV, lowest_CSF_EV);
    //                   Line minimize for the nonlinear components
    for (int i = J_begin; i < J_end; i++)
      GEVSplitDirection[i] = J_parms[i - J_begin + 1];
    //                   freeze the CSF components at this minimum
    for (int i = CSF_begin; i < CSF_end; i++)
      LocalEV[i - 1] = CSF_parms[i - CSF_begin + 1];
    FullEV[0] = 1.0;
    for (int i = J_begin; i < J_end; i++)
      FullEV[i] = GEVSplitDirection[i];
  }
  else if (CSF_Option == "rescale")
  {
    RealType matrixRescaler = std::sqrt(std::abs(lowest_CSF_EV / lowest_J_EV));
    for (int i = 0; i < N; i++)
      for (int j = 0; j < N; j++)
      {
        if ((i >= J_begin) && (i < J_end))
        {
          FullLeft(i, j) *= matrixRescaler;
          FullRight(i, j) *= matrixRescaler;
        }
        if ((j >= J_begin) && (j < J_end))
        {
          FullLeft(i, j) *= matrixRescaler;
          FullRight(i, j) *= matrixRescaler;
        }
      }
    myTimers[2]->start();
    returnValue = getLowestEigenvector(FullLeft, FullRight, FullEV);
    myTimers[2]->stop();
  }
  else if (CSF_Option == "stability")
  {
    //       just return the value of the CSF part
    if (lowest_J_EV > lowest_CSF_EV)
      CSF_scaled = true;
    else
      CSF_scaled = false;
    returnValue = std::min(lowest_J_EV, lowest_CSF_EV);
  }
  return returnValue;
}

/** Parses the xml input file for parameter definitions for the wavefunction optimization.
* @param q current xmlNode
* @return true if successful
*/
bool QMCLinearOptimize::put(xmlNodePtr q)
{
  std::string useGPU("no");
  std::string vmcMove("pbyp");
  OhmmsAttributeSet oAttrib;
  oAttrib.add(useGPU, "gpu");
  oAttrib.add(vmcMove, "move");
  oAttrib.put(q);
  optNode        = q;
  xmlNodePtr cur = optNode->children;
  int pid        = OHMMS::Controller->rank();
  while (cur != NULL)
  {
    std::string cname((const char*)(cur->name));
    if (cname == "mcwalkerset")
    {
      mcwalkerNodePtr.push_back(cur);
    }
    cur = cur->next;
  }
  //no walkers exist, add 10
  if (W.getActiveWalkers() == 0)
    addWalkers(omp_get_max_threads());
  NumOfVMCWalkers = W.getActiveWalkers();
  bool success    = true;
  if (optTarget == 0)
  {
#if defined(QMC_CUDA)
    if (useGPU == "yes")
      optTarget = new QMCCostFunctionCUDA(W, Psi, H, myComm);
    else
#endif
      optTarget = new QMCCostFunction(W, Psi, H, myComm);
    //#if defined(ENABLE_OPENMP)
    //            if (omp_get_max_threads()>1)
    //            {
    //                optTarget = new QMCCostFunctionOMP(W,Psi,H,hamPool);
    //            }
    //            else
    //#endif
    //        optTarget = new QMCCostFunctionSingle(W,Psi,H);
    optTarget->setStream(&app_log());
    success = optTarget->put(q);
  }
  //create VMC engine
  if (vmcEngine == 0)
  {
#if defined(QMC_CUDA)
    if (useGPU == "yes")
      vmcEngine = new VMCcuda(W, Psi, H, psiPool, myComm);
    else
#endif
      vmcEngine = new VMC(W, Psi, H, psiPool, myComm);
    vmcEngine->setUpdateMode(vmcMove[0] == 'p');
  }

  vmcEngine->setStatus(RootName, h5FileRoot, AppendRun);
  vmcEngine->process(optNode);
  return success;
}

bool QMCLinearOptimize::fitMappedStabilizers(std::vector<std::pair<RealType, RealType>>& mappedStabilizers,
                                             RealType& XS,
                                             RealType& val,
                                             RealType tooBig)
{
  int nms(0);
  for (int i = 0; i < mappedStabilizers.size(); i++)
    if (mappedStabilizers[i].second == mappedStabilizers[i].second)
      nms++;
  bool SuccessfulFit(false);
  if (nms >= 5)
  {
    //Quartic fit the stabilizers we have tried and try to choose the best we can
    std::vector<RealType> Y(nms), Coefs(5);
    Matrix<RealType> X(nms, 5);
    for (int i = 0; i < nms; i++)
      if (mappedStabilizers[i].second == mappedStabilizers[i].second)
      {
        X(i, 0) = 1.0;
        X(i, 1) = mappedStabilizers[i].first;
        X(i, 2) = std::pow(mappedStabilizers[i].first, 2);
        X(i, 3) = std::pow(mappedStabilizers[i].first, 3);
        X(i, 4) = std::pow(mappedStabilizers[i].first, 4);
        Y[i]    = mappedStabilizers[i].second;
      }
    LinearFit(Y, X, Coefs);
    RealType Xmin = QuarticMinimum(Coefs);
    val           = 0;
    for (int i = 0; i < 5; i++)
      val += std::pow(Xmin, i) * Coefs[i];
    app_log() << "quartic Fit min: " << Xmin << " val: " << val << std::endl;
    ;
    //         for (int i=0; i<5; i++) app_log()<<Coefs[i]<<" ";
    //         app_log()<< std::endl;
    SuccessfulFit = true;
    for (int i = 0; i < nms; i++)
      if (mappedStabilizers[i].second == mappedStabilizers[i].second)
        if (val > mappedStabilizers[i].second)
          SuccessfulFit = false;
    if (Xmin > tooBig)
      SuccessfulFit = false;
    if (SuccessfulFit)
      XS = Xmin;
  }
  else if (nms >= 3)
  {
    //Quadratic fit the stabilizers we have tried and try to choose the best we can
    std::sort(mappedStabilizers.begin(), mappedStabilizers.end());
    std::vector<RealType> Y(nms), Coefs(3);
    Matrix<RealType> X(nms, 3);
    for (int i = 0; i < nms; i++)
      if (mappedStabilizers[i].second == mappedStabilizers[i].second)
      {
        X(i, 0) = 1.0;
        X(i, 1) = mappedStabilizers[i].first;
        X(i, 2) = std::pow(mappedStabilizers[i].first, 2);
        Y[i]    = mappedStabilizers[i].second;
      }
    LinearFit(Y, X, Coefs);
    //extremum really.
    RealType Xmin = -0.5 * Coefs[1] / Coefs[2];
    val           = 0;
    for (int i = 0; i < 3; i++)
      val += std::pow(Xmin, i) * Coefs[i];
    app_log() << "quadratic Fit min: " << Xmin << " val: " << val << std::endl;
    //         for (int i=0; i<3; i++) app_log()<<Coefs[i]<<" ";
    //         app_log()<< std::endl;
    SuccessfulFit = true;
    if (Xmin > tooBig)
      SuccessfulFit = false;
    for (int i = 0; i < nms; i++)
      if (mappedStabilizers[i].second == mappedStabilizers[i].second)
        if (val > mappedStabilizers[i].second)
          SuccessfulFit = false;
    if (SuccessfulFit)
      XS = Xmin;
  }
  return SuccessfulFit;
}
} // namespace qmcplusplus
