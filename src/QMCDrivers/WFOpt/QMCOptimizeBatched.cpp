//////////////////////////////////////////////////////////////////////////////////////
// This file is distributed under the University of Illinois/NCSA Open Source License.
// See LICENSE file in top directory for details.
//
// Copyright (c) 2020 QMCPACK developers.
//
// File developed by: Miguel Morales, moralessilva2@llnl.gov, Lawrence Livermore National Laboratory
//                    Ken Esler, kpesler@gmail.com, University of Illinois at Urbana-Champaign
//                    Jeremy McMinnis, jmcminis@gmail.com, University of Illinois at Urbana-Champaign
//                    Jeongnim Kim, jeongnim.kim@gmail.com, University of Illinois at Urbana-Champaign
//                    Mark A. Berrill, berrillma@ornl.gov, Oak Ridge National Laboratory
//                    Mark Dewing, mdewing@anl.gov, Argonne National Laboratory
//
// File created by: Jeongnim Kim, jeongnim.kim@gmail.com, University of Illinois at Urbana-Champaign
//////////////////////////////////////////////////////////////////////////////////////


#include "QMCOptimizeBatched.h"
#include "Particle/HDFWalkerIO.h"
#include "OhmmsData/AttributeSet.h"
#include "Message/CommOperators.h"
#include "Optimize/CGOptimization.h"
#include "Optimize/testDerivOptimization.h"
#include "Optimize/DampedDynamics.h"
#include "QMCDrivers/VMC/VMCBatched.h"
#include "QMCDrivers/WFOpt/QMCCostFunctionBatched.h"
#include "QMCHamiltonians/HamiltonianPool.h"
#include "Concurrency/Info.hpp"

namespace qmcplusplus
{
QMCOptimizeBatched::QMCOptimizeBatched(const ProjectData& project_data,
                                       MCWalkerConfiguration& w,
                                       QMCDriverInput&& qmcdriver_input,
                                       VMCDriverInput&& vmcdriver_input,
                                       WFOptDriverInput&& wfoptdriver_input,
                                       MCPopulation&& population,
                                       SampleStack& samples,
                                       Communicate* comm)
    : QMCDriverNew(project_data,
                   std::move(qmcdriver_input),
                   std::move(population),
                   "QMCOptimizeBatched::",
                   comm,
                   "QMCOptimizeBatched"),
      PartID(0),
      NumParts(1),
      optSolver(0),
      vmcEngine(0),
      wfNode(NULL),
      optNode(NULL),
      vmcdriver_input_(vmcdriver_input),
      wfoptdriver_input_(wfoptdriver_input),
      samples_(samples),
      W(w)
{
  optmethod = "test";
}

/** Clean up the vector */
QMCOptimizeBatched::~QMCOptimizeBatched()
{
  delete vmcEngine;
  delete optSolver;
}

/** Add configuration files for the optimization
 * @param a root of a hdf5 configuration file
 */
void QMCOptimizeBatched::addConfiguration(const std::string& a)
{
  if (a.size())
    ConfigFile.push_back(a);
}

/** Reimplement QMCDriver::run
 */
bool QMCOptimizeBatched::run()
{
  //close files automatically generated by QMCDriver
  //branchEngine->finalize();
  //generate samples
  generateSamples();

  app_log() << "<opt stage=\"setup\">" << std::endl;
  app_log() << "  <log>" << std::endl;
  //reset the rootname
  optTarget->setRootName(get_root_name());
  optTarget->setWaveFunctionNode(wfNode);
  optTarget->setRng(vmcEngine->getRng());
  app_log() << "   Reading configurations from h5FileRoot " << std::endl;
  //get configuration from the previous run
  Timer t1;
  optTarget->getConfigurations("");
  optTarget->checkConfigurations();
  app_log() << "  Execution time = " << std::setprecision(4) << t1.elapsed() << std::endl;
  app_log() << "  </log>" << std::endl;
  app_log() << "</opt>" << std::endl;
  app_log() << "<opt stage=\"main\" walkers=\"" << optTarget->getNumSamples() << "\">" << std::endl;
  app_log() << "  <log>" << std::endl;
  // FIXME: Ye to Mark: branch_engine_ of QMCOptimizeBatched doesn't hold anything.
  // Hopefully this was not affecting anything.
  //optTarget->setTargetEnergy(branch_engine_->getEref());
  t1.restart();
  bool success = optSolver->optimize(optTarget.get());
  app_log() << "  Execution time = " << std::setprecision(4) << t1.elapsed() << std::endl;
  ;
  app_log() << "  </log>" << std::endl;
  optTarget->reportParameters();

  app_log() << "</opt>" << std::endl;
  app_log() << "</optimization-report>" << std::endl;

  return (optTarget->getReportCounter() > 0);
}

void QMCOptimizeBatched::generateSamples()
{
  Timer t1;
  app_log() << "<optimization-report>" << std::endl;

  t1.restart();

  samples_.resetSampleCount();
  population_.set_variational_parameters(optTarget->getOptVariables());

  vmcEngine->run();
  app_log() << "  Execution time = " << std::setprecision(4) << t1.elapsed() << std::endl;
  app_log() << "</vmc>" << std::endl;

  h5_file_root_ = get_root_name();
}

/** Parses the xml input file for parameter definitions for the wavefunction optimization.
 * @param q current xmlNode
 * @return true if successful
 */
void QMCOptimizeBatched::process(xmlNodePtr q)
{
  int crowd_size     = wfoptdriver_input_.get_opt_crowd_size();
  int opt_num_crowds = wfoptdriver_input_.get_opt_num_crowds();
  // Code to check and set crowds take from QMCDriverNew::adjustGlobalWalkerCount
  checkNumCrowdsLTNumThreads(opt_num_crowds);
  if (opt_num_crowds == 0)
    opt_num_crowds = Concurrency::maxCapacity<>();

  app_log() << " Number of crowds for optimizer: " << opt_num_crowds << std::endl;

  //create VMC engine
  if (vmcEngine == 0)
  {
    QMCDriverInput qmcdriver_input_copy = qmcdriver_input_;
    VMCDriverInput vmcdriver_input_copy = vmcdriver_input_;
    vmcEngine = new VMCBatched(project_data_, std::move(qmcdriver_input_copy), std::move(vmcdriver_input_copy),
                               MCPopulation(myComm->size(), myComm->rank(), population_.getWalkerConfigsRef(),
                                            population_.get_golden_electrons(), &population_.get_golden_twf(),
                                            &population_.get_golden_hamiltonian()),
                               samples_, myComm);

    app_log() << " VMC update mode: " << qmcdriver_input_.get_update_mode() << std::endl;
    vmcEngine->setUpdateMode(qmcdriver_input_.get_update_mode()[0] == 'p');
    bool AppendRun = false;
    vmcEngine->setStatus(get_root_name(), h5_file_root_, AppendRun);
    vmcEngine->process(q);
    vmcEngine->enable_sample_collection();
  }

  if (optSolver == nullptr)
  {
    if (optmethod == "anneal")
    {
      app_log() << " Annealing optimization using DampedDynamics" << std::endl;
      optSolver = new DampedDynamics<RealType>;
    }
    else if (optmethod == "test")
    {
      app_log() << "Test and output parameter derivatives (batched): " << std::endl;
      optSolver = new testDerivOptimization<RealType>(get_root_name());
    }
    else
    {
      app_log() << "Unknown optimize method: " << optmethod << std::endl;
      APP_ABORT("QMCOptimizeBatched::process");
    } //set the stream
    optSolver->setOstream(&app_log());
  }

  optSolver->put(wfoptdriver_input_.get_opt_xml_node());

  bool success = true;
  //allways reset optTarget
  optTarget =
      std::make_unique<QMCCostFunctionBatched>(W, population_.get_golden_twf(), population_.get_golden_hamiltonian(),
                                               samples_, opt_num_crowds, crowd_size, myComm);
  optTarget->setStream(&app_log());
  success = optTarget->put(q);

  // This code is also called when setting up vmcEngine.  Would be nice to not duplicate the call.
  QMCDriverNew::AdjustedWalkerCounts awc =
      adjustGlobalWalkerCount(myComm->size(), myComm->rank(), qmcdriver_input_.get_total_walkers(),
                              qmcdriver_input_.get_walkers_per_rank(), 1.0, qmcdriver_input_.get_num_crowds());
  QMCDriverNew::startup(q, awc);
}
} // namespace qmcplusplus
