//////////////////////////////////////////////////////////////////////////////////////
// This file is distributed under the University of Illinois/NCSA Open Source License.
// See LICENSE file in top directory for details.
//
// Copyright (c) 2022 QMCPACK developers.
//
// File developed by: Peter Doak, doakpw@ornl.gov, Oak Ridge National Laboratory
//
// Some code refactored from: ReferencePoints.h & ReferencePoints.cpp
//////////////////////////////////////////////////////////////////////////////////////

#ifndef QMCPLUSPLUS_REFERNCE_POINTS_INPUT_H
#define QMCPLUSPLUS_REFERNCE_POINTS_INPUT_H

#include <map>
#include <string>
#include <string_view>

#include <Configuration.h>
#include <OhmmsPETE/Tensor.h>
#include <OhmmsPETE/TinyVector.h>
#include "InputSection.h"

namespace qmcplusplus
{
namespace testing
{
template<typename T>
class EnergyDensityTests;
}

class SpaceGrid;

class ReferencePointsInput
{
public:
  using Real     = double;
  using Consumer = SpaceGrid;
  using Point    = TinyVector<Real, OHMMS_DIM>;
  using Points   = std::map<std::string, Point>;
  enum class Coord
  {
    CELL,
    CARTESIAN
  };

  /** mapping for enumerated options of ReferencePointsInput
   *  This data object is the basis of input enum string values
   *  translation to native C++ scoped enums. This boiler plate is
   *  generated by utils/code_tools/qmcpack-elisp-generators.el
   *  qmcp-add-enum-string-map
   *
   *  This plus the virtual assignAnyEnum method are needed by InputSection to
   *  validate and assign enum values from input.
   *
   *  In testing code we assume this map is bidirectional.
   */
  inline static const std::unordered_map<std::string, std::any> lookup_input_enum_value{
      {"coord-cell", Coord::CELL},
      {"coord-cartesian", Coord::CARTESIAN},
  };

  class ReferencePointsInputSection : public InputSection
  {
  public:
    ReferencePointsInputSection()
    {
      section_name = "reference_points";
      enums        = {"coord"};
      attributes   = {"coord"};
      required     = {"coord"};
    }
    std::any assignAnyEnum(const std::string& name) const override;
    ReferencePointsInputSection(const ReferencePointsInputSection&) = default;
  };

  /** Unlike many input classes ReferencePointInputs needs a way to be constructured even if there is no input node.
   *  The ReferencePoints for a space grid are assumed to just be a default ReferencePoints with
   *  the same CoordType.
   */
  ReferencePointsInput() = default;

  ReferencePointsInput(xmlNodePtr cur);
  ReferencePointsInput(const ReferencePointsInput& rpi) = default;

  Coord get_coord_form() const { return coord_form_; }
  const Points& get_points() const { return points_; }

private:
  void readRefPointsXML(xmlNodePtr cur);
  // As far as I can tell if not specified in input this is what is happening in legacy.
  Coord coord_form_ = Coord::CELL;
  Points points_;
  ReferencePointsInputSection input_section_;
  static constexpr std::string_view error_tag{"ReferencePointsInput input: "};
};

/** factory function used by InputSection to make reference points Input
   *  \param[out]  value_label     key value in delegating InputSection for storing the constructed Input from processed node.
   */
std::any makeReferencePointsInput(xmlNodePtr, std::string& value_label);

extern template bool InputSection::setIfInInput<ReferencePointsInput::Coord>(ReferencePointsInput::Coord& var,
                                                                             const std::string& tag);
} // namespace qmcplusplus
#endif
