//////////////////////////////////////////////////////////////////////////////////////
// This file is distributed under the University of Illinois/NCSA Open Source License.
// See LICENSE file in top directory for details.
//
// Copyright (c) 2016 Jeongnim Kim and QMCPACK developers.
//
// File developed by: Jeongnim Kim, jeongnim.kim@gmail.com, University of Illinois at Urbana-Champaign
//                    Jeremy McMinnis, jmcminis@gmail.com, University of Illinois at Urbana-Champaign
//                    Mark A. Berrill, berrillma@ornl.gov, Oak Ridge National Laboratory
//
// File created by: Jeongnim Kim, jeongnim.kim@gmail.com, University of Illinois at Urbana-Champaign
//////////////////////////////////////////////////////////////////////////////////////
    
    

#ifndef OHMMS_PARTICLEATTRIB_PEPE_OPERATORS_H
#define OHMMS_PARTICLEATTRIB_PEPE_OPERATORS_H
///////////////////////////////////////////////////////////////////////////////
//
// WARNING: THIS FILE WAS GENERATED AUTOMATICALLY!
// YOU SHOULD MODIFY THE INPUT FILES INSTEAD OF CHANGING THIS FILE DIRECTLY!
//
// THE FOLLOWING INPUT FILES WERE USED TO MAKE THIS FILE:
//
// MakeOperators
// matrixOps.in
// MatrixDefs.in
//
///////////////////////////////////////////////////////////////////////////////

namespace qmcplusplus
{

template<class T1>
inline typename MakeReturn<UnaryNode<OpUnaryMinus,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t> >::Expression_t
       operator-(const ParticleAttrib<T1> & l)
{
  typedef UnaryNode<OpUnaryMinus,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<OpUnaryPlus,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t> >::Expression_t
       operator+(const ParticleAttrib<T1> & l)
{
  typedef UnaryNode<OpUnaryPlus,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<OpBitwiseNot,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t> >::Expression_t
       operator~(const ParticleAttrib<T1> & l)
{
  typedef UnaryNode<OpBitwiseNot,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<OpIdentity,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t> >::Expression_t
       PETE_identity(const ParticleAttrib<T1> & l)
{
  typedef UnaryNode<OpIdentity,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l)));
}

template<class T1,class T2>
inline typename MakeReturn<UnaryNode<OpCast<T1>,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       peteCast(const T1&, const ParticleAttrib<T2> & l)
{
  typedef UnaryNode<OpCast<T1>,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T2> >::make(l)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpAdd,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       operator+(const ParticleAttrib<T1> & l,const ParticleAttrib<T2> & r)
{
  typedef BinaryNode<OpAdd,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l),
                                    CreateLeaf<ParticleAttrib<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpSubtract,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       operator-(const ParticleAttrib<T1> & l,const ParticleAttrib<T2> & r)
{
  typedef BinaryNode<OpSubtract,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l),
                                    CreateLeaf<ParticleAttrib<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMultiply,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       operator*(const ParticleAttrib<T1> & l,const ParticleAttrib<T2> & r)
{
  typedef BinaryNode<OpMultiply,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l),
                                    CreateLeaf<ParticleAttrib<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMod,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       operator%(const ParticleAttrib<T1> & l,const ParticleAttrib<T2> & r)
{
  typedef BinaryNode<OpMod,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l),
                                    CreateLeaf<ParticleAttrib<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       operator&(const ParticleAttrib<T1> & l,const ParticleAttrib<T2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l),
                                    CreateLeaf<ParticleAttrib<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       operator|(const ParticleAttrib<T1> & l,const ParticleAttrib<T2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l),
                                    CreateLeaf<ParticleAttrib<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       operator^(const ParticleAttrib<T1> & l,const ParticleAttrib<T2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l),
                                    CreateLeaf<ParticleAttrib<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpAdd,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator+(const ParticleAttrib<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpAdd,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpSubtract,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator-(const ParticleAttrib<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpSubtract,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMultiply,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator*(const ParticleAttrib<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpMultiply,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMod,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator%(const ParticleAttrib<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpMod,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator&(const ParticleAttrib<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator|(const ParticleAttrib<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator^(const ParticleAttrib<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpAdd,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       operator+(const Expression<T1> & l,const ParticleAttrib<T2> & r)
{
  typedef BinaryNode<OpAdd,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<ParticleAttrib<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpSubtract,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       operator-(const Expression<T1> & l,const ParticleAttrib<T2> & r)
{
  typedef BinaryNode<OpSubtract,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<ParticleAttrib<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMultiply,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       operator*(const Expression<T1> & l,const ParticleAttrib<T2> & r)
{
  typedef BinaryNode<OpMultiply,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<ParticleAttrib<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMod,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       operator%(const Expression<T1> & l,const ParticleAttrib<T2> & r)
{
  typedef BinaryNode<OpMod,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<ParticleAttrib<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       operator&(const Expression<T1> & l,const ParticleAttrib<T2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<ParticleAttrib<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       operator|(const Expression<T1> & l,const ParticleAttrib<T2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<ParticleAttrib<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       operator^(const Expression<T1> & l,const ParticleAttrib<T2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<ParticleAttrib<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpAdd,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator+(const ParticleAttrib<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpAdd,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpSubtract,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator-(const ParticleAttrib<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpSubtract,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMultiply,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator*(const ParticleAttrib<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpMultiply,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMod,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator%(const ParticleAttrib<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpMod,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator&(const ParticleAttrib<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpBitwiseAnd,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator|(const ParticleAttrib<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpBitwiseOr,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator^(const ParticleAttrib<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpBitwiseXor,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpAdd,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       operator+(const T1 & l,const ParticleAttrib<T2> & r)
{
  typedef BinaryNode<OpAdd,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<ParticleAttrib<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpSubtract,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       operator-(const T1 & l,const ParticleAttrib<T2> & r)
{
  typedef BinaryNode<OpSubtract,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<ParticleAttrib<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMultiply,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       operator*(const T1 & l,const ParticleAttrib<T2> & r)
{
  typedef BinaryNode<OpMultiply,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<ParticleAttrib<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMod,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       operator%(const T1 & l,const ParticleAttrib<T2> & r)
{
  typedef BinaryNode<OpMod,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<ParticleAttrib<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       operator&(const T1 & l,const ParticleAttrib<T2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<ParticleAttrib<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       operator|(const T1 & l,const ParticleAttrib<T2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<ParticleAttrib<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> >::Expression_t
       operator^(const T1 & l,const ParticleAttrib<T2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<ParticleAttrib<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<ParticleAttrib<T2> >::make(r)));
}
#ifdef PETE_ALLOW_SCALAR_SHIFT
#endif // PETE_ALLOW_SCALAR_SHIFT

template<class T1,class T2,class T3>
inline typename MakeReturn<TrinaryNode<FnWhere,
       typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t,
       typename CreateLeaf<T3 >::Leaf_t> >::Expression_t
       where(const ParticleAttrib<T1> & c,const T2 & t,const T3 & f)
{
  typedef TrinaryNode<FnWhere,
          typename CreateLeaf<ParticleAttrib<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t,
          typename CreateLeaf<T3 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<ParticleAttrib<T1> >::make(c),
                                    CreateLeaf<T2 >::make(t),
                                    CreateLeaf<T3 >::make(f)));
}
#ifndef PETE_EXPRESSION_OPERATORS
#define PETE_EXPRESSION_OPERATORS

template<class T1>
inline typename MakeReturn<UnaryNode<OpUnaryMinus,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       operator-(const Expression<T1> & l)
{
  typedef UnaryNode<OpUnaryMinus,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<OpUnaryPlus,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       operator+(const Expression<T1> & l)
{
  typedef UnaryNode<OpUnaryPlus,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<OpBitwiseNot,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       operator~(const Expression<T1> & l)
{
  typedef UnaryNode<OpBitwiseNot,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1>
inline typename MakeReturn<UnaryNode<OpIdentity,
       typename CreateLeaf<Expression<T1> >::Leaf_t> >::Expression_t
       PETE_identity(const Expression<T1> & l)
{
  typedef UnaryNode<OpIdentity,
          typename CreateLeaf<Expression<T1> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l)));
}

template<class T1,class T2>
inline typename MakeReturn<UnaryNode<OpCast<T1>,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       peteCast(const T1&, const Expression<T2> & l)
{
  typedef UnaryNode<OpCast<T1>,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T2> >::make(l)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpAdd,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator+(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpAdd,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpSubtract,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator-(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpSubtract,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMultiply,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator*(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpMultiply,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMod,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator%(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpMod,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator&(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator|(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator^(const Expression<T1> & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpAdd,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator+(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpAdd,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpSubtract,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator-(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpSubtract,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMultiply,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator*(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpMultiply,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMod,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator%(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpMod,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator&(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpBitwiseAnd,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator|(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpBitwiseOr,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t> >::Expression_t
       operator^(const Expression<T1> & l,const T2 & r)
{
  typedef BinaryNode<OpBitwiseXor,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(l),
                                    CreateLeaf<T2 >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpAdd,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator+(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpAdd,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpSubtract,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator-(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpSubtract,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMultiply,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator*(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpMultiply,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpMod,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator%(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpMod,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseAnd,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator&(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpBitwiseAnd,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseOr,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator|(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpBitwiseOr,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}

template<class T1,class T2>
inline typename MakeReturn<BinaryNode<OpBitwiseXor,
       typename CreateLeaf<T1 >::Leaf_t,
       typename CreateLeaf<Expression<T2> >::Leaf_t> >::Expression_t
       operator^(const T1 & l,const Expression<T2> & r)
{
  typedef BinaryNode<OpBitwiseXor,
          typename CreateLeaf<T1 >::Leaf_t,
          typename CreateLeaf<Expression<T2> >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<T1 >::make(l),
                                    CreateLeaf<Expression<T2> >::make(r)));
}
#ifdef PETE_ALLOW_SCALAR_SHIFT
#endif // PETE_ALLOW_SCALAR_SHIFT

template<class T1,class T2,class T3>
inline typename MakeReturn<TrinaryNode<FnWhere,
       typename CreateLeaf<Expression<T1> >::Leaf_t,
       typename CreateLeaf<T2 >::Leaf_t,
       typename CreateLeaf<T3 >::Leaf_t> >::Expression_t
       where(const Expression<T1> & c,const T2 & t,const T3 & f)
{
  typedef TrinaryNode<FnWhere,
          typename CreateLeaf<Expression<T1> >::Leaf_t,
          typename CreateLeaf<T2 >::Leaf_t,
          typename CreateLeaf<T3 >::Leaf_t> Tree_t;
  return MakeReturn<Tree_t>::make(Tree_t(
                                    CreateLeaf<Expression<T1> >::make(c),
                                    CreateLeaf<T2 >::make(t),
                                    CreateLeaf<T3 >::make(f)));
}
#endif  // PETE_EXPRESSION_OPERATORS

template<class T1,class RHS>
inline
ParticleAttrib<T1>& assign(ParticleAttrib<T1>& lhs,const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs,OpAssign(),MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1,class RHS>
inline
ParticleAttrib<T1>& operator+=(ParticleAttrib<T1>& lhs,const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs,OpAddAssign(),MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1,class RHS>
inline
ParticleAttrib<T1>& operator-=(ParticleAttrib<T1>& lhs,const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs,OpSubtractAssign(),MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1,class RHS>
inline
ParticleAttrib<T1>& operator*=(ParticleAttrib<T1>& lhs,const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs,OpMultiplyAssign(),MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1,class RHS>
inline
ParticleAttrib<T1>& operator%=(ParticleAttrib<T1>& lhs,const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs,OpModAssign(),MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1,class RHS>
inline
ParticleAttrib<T1>& operator|=(ParticleAttrib<T1>& lhs,const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs,OpBitwiseOrAssign(),MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1,class RHS>
inline
ParticleAttrib<T1>& operator&=(ParticleAttrib<T1>& lhs,const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs,OpBitwiseAndAssign(),MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

template<class T1,class RHS>
inline
ParticleAttrib<T1>& operator^=(ParticleAttrib<T1>& lhs,const RHS& rhs)
{
  typedef typename CreateLeaf<RHS>::Leaf_t Leaf_t;
  evaluate(lhs,OpBitwiseXorAssign(),MakeReturn<Leaf_t>::make(CreateLeaf<RHS>::make(rhs)));
  return lhs;
}

/////////////////////////////////////////////////////////////////////////////
// specialization of CreateLeaf for ParticleAttrib
/////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
// We need to specialize CreateLeaf<T> for our class, so that operators
// know what to stick in the leaves of the expression tree.
//-----------------------------------------------------------------------------
template<class T>
struct CreateLeaf<ParticleAttrib<T> >
{
  typedef Reference<ParticleAttrib<T> > Leaf_t;
  inline static
  Leaf_t make(const ParticleAttrib<T> &a)
  {
    return Leaf_t(a);
  }
};

//-----------------------------------------------------------------------------
// We need to write a functor that is capable of comparing the size of
// the vector with a stored value. Then, we supply LeafFunctor specializations
// for Scalar<T> and STL vector leaves.
//-----------------------------------------------------------------------------
class SizeLeafPA
{
public:

  SizeLeafPA(int s) : size_m(s) { }
  SizeLeafPA(const SizeLeafPA &model) : size_m(model.size_m) { }
  bool operator()(int s) const
  {
    return size_m == s;
  }

private:

  int size_m;

};

template<class T>
struct LeafFunctor<Scalar<T>, SizeLeafPA>
{
  typedef bool Type_t;
  inline static
  bool apply(const Scalar<T> &, const SizeLeafPA &)
  {
    // Scalars always conform.
    return true;
  }
};

template<class T>
struct LeafFunctor<ParticleAttrib<T>, SizeLeafPA>
{
  typedef bool Type_t;
  inline static
  bool apply(const ParticleAttrib<T> &v, const SizeLeafPA &s)
  {
    return s(v.size());
  }
};

//-----------------------------------------------------------------------------
// EvalLeaf1 is used to evaluate expression with vectors.
// (It's already defined for Scalar values.)
//-----------------------------------------------------------------------------

template<class T>
struct LeafFunctor<ParticleAttrib<T>,EvalLeaf1>
{
  typedef T Type_t;
  inline static
  Type_t apply(const ParticleAttrib<T>& vec,const EvalLeaf1 &f)
  {
    return vec[f.val1()];
  }
};

//////////////////////////////////////////////////////////////////////////////////
// LOOP is done by evaluate function
//////////////////////////////////////////////////////////////////////////////////
template<class T, class Op, class RHS>
inline void evaluate(ParticleAttrib<T> &lhs,
                     const Op &op, const Expression<RHS> &rhs)
{
  if (forEach(rhs, SizeLeafPA(lhs.size()), AndCombine()))
  {
    // We get here if the vectors on the RHS are the same size as those on
    // the LHS.
    for (int i = 0; i < lhs.size(); ++i)
    {
      // The actual assignment operation is performed here.
      // PETE operator tags all define operator() to perform the operation.
      // (In this case op performs an assignment.) forEach is used
      // to compute the rhs value.  EvalLeaf1 gets the
      // values at each node using random access, and the tag
      // OpCombine tells forEach to use the operator tags in the expression
      // to combine values together.
      op(lhs[i], forEach(rhs, EvalLeaf1(i), OpCombine()));
    }
  }
  else
  {
    std::cerr << "Error: LHS and RHS don't conform in ParticleAttrib." << std::endl;
    exit(1);
  }
}

// I/O
template<class T>
std::ostream& operator<<(std::ostream& out, const ParticleAttrib<T>& rhs)
{
  for(int i=0; i<rhs.size(); i++)
    out << rhs[i] << std::endl;
  return out;
}

}
#endif // OHMMS_PARTICLEATTRIB_PEPE_OPERATORS_H


