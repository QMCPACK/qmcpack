
Finish:
1. Wave-function parallelization routines. 
    - Partition hamiltonian and write versions for MultiSD
    - Implement DGEMM version of eloc calculation
2. Modify distributed LA code to overlap communication with computation.
3. Speed-up/parallelize creation of Vijkl and Spvn with cholesky integrals
    - Use Vijkl.add(std::vector<>) instead of term-by-term
    - parallelize the routines that currently occur at rank()==0.
4. Enable object reuse, e.g. multiple calls to Drivers with the same Wfn/Ham/Prop/etc objects
    - Initialize only one, e.g. integrals can't change in Hamiltonian, Spvn can only be rescaled, etc 
    - If already initialized, write a set of routines to reset that will be called instead of init.
       -- reset will do necessary setup for the new run if anything changes, e.g. # walkers, etc.
5. Write post-processing driver to process stored configurations.
6. Fix single precision. Revert back to implementation where the only step done at single precision is
   the GEMM with Spvn and SpHijkl. Everything else should be turned back to double precision.
7. Implement back-propagation.
8. Add estimators, e.g. density matrix. 
9. Finish GHF walkers.

Ideas to implement:
- Test and use idea where the projection is done with a large cutoff, but the energy is corrected by postprocessing configurations with a small cutoff. See how well it works.

