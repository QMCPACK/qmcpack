//////////////////////////////////////////////////////////////////////////////////////
// This file is distributed under the University of Illinois/NCSA Open Source License.
// See LICENSE file in top directory for details.
//
// Copyright (c) 2016 Jeongnim Kim and QMCPACK developers.
//
// File developed by: Miguel Morales, moralessilva2@llnl.gov, Lawrence Livermore National Laboratory
//
// File created by: Miguel Morales, moralessilva2@llnl.gov, Lawrence Livermore National Laboratory 
//////////////////////////////////////////////////////////////////////////////////////

#ifndef QMCPLUSPLUS_AFQMC_SHAREDWALKERSET_ICC
#define QMCPLUSPLUS_AFQMC_SHAREDWALKERSET_ICC

#include<cassert>
#include<cstdlib>

namespace qmcplusplus
{

namespace afqmc
{

// load balancing algorithm
template<class Mat>
inline void SharedWalkerSet::loadBalance(Mat&& M) {

  Timers[LoadBalance]->start();
  if(load_balance == SIMPLE) {

    if(TG.TG_local().root())
      afqmc::swapWalkersSimple(*this,std::forward<Mat>(M),
          nwalk_counts_old,nwalk_counts_new,TG.TG_heads());

  } else if(load_balance == ASYNC) {

    if(TG.TG_local().root())
      afqmc::swapWalkersAsync(*this,std::forward<Mat>(M),
          nwalk_counts_old,nwalk_counts_new,TG.TG_heads());

  }
  TG.local_barrier();
  // since tot_num_walkers is local, you need to sync it
  TG.TG_local().broadcast_n(&tot_num_walkers,1,0);
  Timers[LoadBalance]->stop();
}

template<class MatA, class MatB>
inline void SharedWalkerSet::resize(int n, MatA&& A, MatB&& B) {
  reserve(n);
  if(n > tot_num_walkers) {
    if(TG.TG_local().root()) {
      auto W = Wlk_Buff(std::addressof(*walker_buffer.origin()),{n,walker_size}); 
      auto pos = tot_num_walkers; 
      // careful here!!!
      while(pos < n) {
        std::fill_n(W[pos].origin(),W[pos].shape()[0],ComplexType(0,0));
        walker w0(W[pos],data_displ,wlk_desc);
        w0.SlaterMatrix(Alpha) = A;
        if(walkerType == COLLINEAR)
          w0.SlaterMatrix(Beta) = B; 
        w0.weight() = ComplexType(1.0,0.0);
        w0.overlap() = ComplexType(1.0,0.0);
        w0.phase() = ComplexType(1.0,0.0);
        if(nback_prop > 0) {
          // Initialise back propagation data.
          w0.resetForBackPropagation();
        }
        pos++;
      }
    }
  }
  tot_num_walkers=n;
  targetN_per_TG = tot_num_walkers;
  targetN = GlobalPopulation(); 
  if(targetN != targetN_per_TG*TG.getNumberOfTGs())  {
    std::cerr<<" targetN, targetN_per_TG, # of TGs: "
               <<targetN <<" " <<targetN_per_TG <<" " <<TG.getNumberOfTGs() <<std::endl;
    std::cout<<" targetN, targetN_per_TG, # of TGs: "
               <<targetN <<" " <<targetN_per_TG <<" " <<TG.getNumberOfTGs() <<std::endl;
    APP_ABORT("Error in SharedWalkerSet::resize(n,A,B).\n");
  }
}


// remove n walkers from the set and return their data
template<class Mat>
inline void SharedWalkerSet::pop_walkers(Mat&& M) {

  static_assert(std::decay<Mat>::type::dimensionality == 2, "Wrong dimensionality");
  if(tot_num_walkers < int(M.shape()[0]))
    APP_ABORT("Insufficient walkers");
  if(walker_size != int(M.shape()[1]))
    APP_ABORT("Incorrect dimensions.");
  if(M.strides()[1] != 1)
    APP_ABORT("Incorrect strides.");

  if(!TG.TG_local().root()) {
    tot_num_walkers -= int(M.shape()[0]);
    return;
  }  
  for(int i=0; i<M.shape()[0]; i++)
    M[i] = walker_buffer[--tot_num_walkers];  

}

// add n walkers to the set. There must be enough space since this is called in serial
template<class Mat>
inline void SharedWalkerSet::push_walkers(Mat&& M) {

  static_assert(std::decay<Mat>::type::dimensionality == 2, "Wrong dimensionality");
  if(tot_num_walkers+M.shape()[0] > capacity())
    APP_ABORT("Insufficient capacity");
  if(walker_size != M.shape()[1])
    APP_ABORT("Incorrect dimensions.");
  if(M.strides()[1] != 1)
    APP_ABORT("Incorrect strides.");

  if(!TG.TG_local().root()) {
    tot_num_walkers += M.shape()[0];
    return;
  }  

  auto W = Wlk_Buff(std::addressof(*walker_buffer.origin()),{tot_num_walkers+M.shape()[0],walker_size}); 
  for(int i=0; i<M.shape()[0]; i++)
    W[tot_num_walkers++] = M[i];

}

// given a list of new weights and counts, add/remove walkers and reassign weight accordingly
template<class Mat>
inline void SharedWalkerSet::branch(std::vector<std::pair<double,int>>::iterator itbegin,
            std::vector<std::pair<double,int>>::iterator itend,
            Mat& M) {

  if(std::distance(itbegin,itend) != tot_num_walkers)
    APP_ABORT("Error in SharedWalkerSet::branch(): ptr_range != # walkers. \n");

  // checking purposes
  int nW = 0;
  for(auto it=itbegin; it!=itend; ++it) nW += it->second;
  if(int(M.shape()[0]) < std::max(0,nW-targetN_per_TG)) {
    std::cout<<" Error in SharedWalkerSet::branch(): Not enough space in excess matrix. \n"
               <<M.shape()[0] <<" " <<nW <<" " <<targetN_per_TG <<std::endl; 
    APP_ABORT("Error in SharedWalkerSet::branch(): Not enough space in excess matrix.\n");
  }
  if(int(M.shape()[1]) < walker_size) 
    APP_ABORT("Error in SharedWalkerSet::branch(): Wrong dimensions in excess matrix.\n"); 

  // if all walkers are dead, don't bother with routine, reset tot_num_walkers and return
  if(nW==0) {
    tot_num_walkers=0;
    return;
  } 

  //1. push/swap all dead walkers to the end and adjust tot_num_walkers 
  {
    auto kill = itbegin;
    auto keep = itend-1;
    int nkills=0;

    while( keep > kill ) { 
 
      // 1. look for next keep
      while(keep->second==0 && keep > kill) {
        tot_num_walkers--;
        --keep;
      }
      if(keep==kill) break;

      // 2. look for next kill
      while(kill->second!=0 && kill < keep) ++kill; 
      if(keep==kill) break;

      // 3. swap
      std::swap(*kill,*keep); 
      walker_buffer[std::distance(itbegin,kill)] = walker_buffer[--tot_num_walkers]; 
      --keep;  

    }
    
    // check
    int n = 0;
    for(auto it=itbegin; it!=itbegin+tot_num_walkers; ++it) n += it->second;  
    if(n != nW)
      APP_ABORT("Error in SharedWalkerSet::branch(): Problems with walker counts after sort.\n");
    for(auto it=itbegin+tot_num_walkers; it!=itend; ++it)
      if(it->second != 0)
        APP_ABORT("Error in SharedWalkerSet::branch(): Problems after sort.\n");
    // you can also check the energy if things look incorrect
  }

  //2. Adjust weights and replicate walkers. Those beyond targetN_per_TG go in M
  itend = itbegin+tot_num_walkers;
  int pos = 0;
  int cnt=0;
  for(; itbegin!=itend; ++itbegin, ++pos) {
    if(itbegin->second <= 0) { // just checking
      APP_ABORT("Error in SharedWalkerSet::branch(): Problems during branch.\n");
    } else if(itbegin->second == 1) {
      walker_buffer[pos][data_displ[WEIGHT]] = ComplexType(itbegin->first,0.0);
    } else {
      // if there is space, branch within walker set
      // otherwise send excess to M
      int n = std::min(targetN_per_TG-tot_num_walkers,itbegin->second-1);
      walker_buffer[pos][data_displ[WEIGHT]] = ComplexType(itbegin->first,0.0);
      for(int i=0; i<n; i++) 
        walker_buffer[tot_num_walkers++] = walker_buffer[pos];
      for(int i=0, in=itbegin->second-1-n; i<in; i++, cnt++) 
        M[cnt] = walker_buffer[pos];  
    }
  }

}

}

}

#endif

